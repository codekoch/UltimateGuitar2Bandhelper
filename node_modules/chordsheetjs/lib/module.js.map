{"mappings":"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K;YACjB,GAAG,UAAU;QACf;IACF;AACF;IAEA,2CAAe;;ADlPf;;AGAA,MAAM,oCAAsD;IAC1D,MAAM;QACJ,KAAK;IACP;IACA,MAAM;QACJ,KAAK;QACL,MAAM;QACN,KAAK;IACP;IACA,KAAK;QACH,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,KAAK;QACL,MAAM;IACR;IACA,KAAK;QACH,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,KAAK;QACH,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,KAAK;QACH,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,KAAK;QACL,KAAK;IACP;IACA,KAAK;QACH,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,OAAO;QACL,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;IACR;IACA,OAAO;QACL,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,OAAO;QACL,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,MAAM;QACJ,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;QACN,MAAM;IACR;IACA,OAAO;QACL,MAAM;QACN,MAAM;IACR;IACA,KAAK;QACH,MAAM;IACR;AACF;IAEA,2CAAe;;;AC7If;AAIO,MAAM,4CAAmB,CAAC,OAC/B,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,OAAS,AAAC,gBAAgB,CAAA,GAAA,wCAAc,KAAM,CAAC,CAAC,KAAK,MAAM;AAGvE,MAAM,4CAAgB,CAAC,OAAwB,AAAC,cAAc,QAAU,OAAO,KAAK,QAAQ,KAAK;AAEjG,MAAM,4CAAU,CAAC,QAAgB,SAA2B;IACjE,IAAI,eAAe;IACnB,IAAK,IAAI,IAAI,OAAO,MAAM,EAAE,IAAI,QAAQ,KAAK,GAAG,gBAAgB,GAAG;IACnE,OAAO;AACT;AAIO,MAAM,4CAAY,CAAC,SAAsC,CAAC,CAAC,UAAU,OAAO,MAAM,GAAG;AACrF,MAAM,4CAAW,CAAC,MAAuB,OAAO,QAAQ;AAE/D,SAAS,gCAAU,MAAc,EAAU;IACzC,OAAO,OAAO,OAAO,CAAC,UAAU,CAAC,QAAU,CAAC,CAAC,EAAE,MAAM,WAAW,GAAG,CAAC;AACtE;AAIO,SAAS,0CAAS,GAAc,EAAE,QAAQ,EAAE,EAAU;IAC3D,OAAO,OACJ,OAAO,CAAC,KACR,GAAG,CAAC,CAAC,CAAC,UAAU,OAAO,GAAK;QAC3B,MAAM,QAAQ,OACX,OAAO,CAAC,QACR,GAAG,CAAC,CAAC,CAAC,UAAU,MAAM,GAAK,CAAC,EAAE,gCAAU,UAAU,EAAE,EAAE,MAAM,CAAC,CAAC,EAC9D,IAAI,CAAC;QAER,MAAM,iBAAiB,CAAC,EAAE,MAAM,CAAC,EAAE,SAAS,CAAC,CAAC,IAAI;QAElD,OAAO,CAAC;AACd,EAAE,eAAe;EACf,EAAE,MAAM;CACT,CAAC,CAAC,SAAS,CAAC;IACT,GACC,IAAI,CAAC;AACV;AAEO,SAAS,0CAAU,OAAe,EAAQ;IAC/C,IAAI;QACF,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,QAAQ,CAAC,EAAE;IAC7C,EAAE,OAAO,GAAG;QACV,MAAM,QAAS;QACf,MAAM,OAAO,WAAW,OAAO;QAE/B,IAAI,OAAO,SAAS,YAAY,OAAO,KAAK,WAAW,KAAK,YAC1D,KAAK,WAAW,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,MAAM,KAAK,CAAC,CAAC;aAE7C,QAAQ,IAAI,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,MAAM,KAAK,CAAC,CAAC;IAE7C;AACF;AAEO,SAAS,0CAAe,OAAe,EAAQ;IACpD,MAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,QAAQ,CAAC,EAAE;AACjD;AAEO,SAAS,0CAAc,MAAiC,EAAW;IACxE,OAAQ,WAAW,IAAI,IAAI,WAAW,aAAa,WAAW;AAChE;AAEO,SAAS,0CAAQ,MAAW,EAAW;IAC5C,IAAI,OAAO,WAAW,UACpB,OAAO,KAAK;IAGd,OAAO,MAAM,CAAC,EAAE,KAAK,OAAO,OAAO,SAAS,CAAC,GAAG,GAAG,WAAW,OAAO;AACvE;AAEO,SAAS,0CAAqB,MAAc,EAAU;IAC3D,OAAO,OAAO,OAAO,CAAC,UAAU;AAClC;;;AJxEA,MAAM,6BAAO;AACb,MAAM,8BAAQ;AAEd,MAAM,uCAAiB;AACvB,MAAM,wCAAkB;AACxB,MAAM,wCAAkB;AAExB,MAAM,gCAAU;IAAC;IAAgB;IAAiB;CAAgB;AAElE,SAAS,4CAAsB,QAAyB,EAAU;IAChE,OAAQ;QACN,KAAK;YAAO,OAAO;QACnB,KAAK;YAAM,OAAO;QAClB;YAAS,OAAO;IAClB;AACF;AAQA;;;;CAIC,GACD,MAAM;IAGJ,WAA4B,IAAI,CAAC;IAEjC,IAAI,kBAAiC;QACnC,OAAQ,IAAI,CAAC,QAAQ;YACnB,KAAK;gBACH,OAAO;YACT,KAAK;gBACH,OAAO;YACT;gBACE,OAAO,IAAI;QACf;IACF;IAEA,QAAQ,KAAK,CAAC;IAEd,OAAO,MAAM,SAAwB,EAAc;QACjD,IAAI,CAAC,aAAa,CAAA,GAAA,yCAAa,AAAD,EAAE,YAAY,OAAO,IAAI;QAEvD,IAAK,IAAI,IAAI,GAAG,QAAQ,8BAAQ,MAAM,EAAE,IAAI,OAAO,KAAK,EAAG;YACzD,MAAM,QAAQ,UAAU,KAAK,CAAC,6BAAO,CAAC,EAAE;YAExC,IAAI,OAAO;gBACT,MAAM,QAAE,KAAI,YAAE,SAAQ,SAAE,MAAK,EAAE,GAAG,MAAM,MAAM;gBAC9C,OAAO,IAAI,0BAAI;0BAAE;8BAAM;oBAAU,OAAO,CAAC,CAAC;gBAAM;YAClD,CAAC;QACH;QAEA,OAAO,IAAI;IACb;IAEA,OAAO,YAAY,SAAwB,EAAO;QAChD,MAAM,SAAS,IAAI,CAAC,KAAK,CAAC;QAE1B,IAAI,CAAC,QAAQ,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,UAAU,CAAC,EAAE;QAE7D,OAAO;IACT;IAEA,OAAO,KAAK,iBAA+B,EAAc;QACvD,IAAI,6BAA6B,2BAAK,OAAO;QAE7C,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB;IAEA,OAAO,WAAW,oBAAyC,IAAI,EAAO;QACpE,IAAI,sBAAsB,IAAI,EAAE,MAAM,IAAI,MAAM,uBAAuB;QAEvE,MAAM,UAAU,IAAI,CAAC,IAAI,CAAC;QAE1B,IAAI,YAAY,IAAI,EAAE,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,kBAAkB,CAAC,EAAE;QAElF,OAAO;IACT;IAEA,OAAO,SAAS,iBAA+B,EAAE;QAC/C,OAAO,CAAC,EAAE,0BAAI,UAAU,CAAC,mBAAmB,CAAC;IAC/C;IAEA;;;;;GAKC,GACD,OAAO,SAAS,MAAoB,EAAE,QAAsB,EAAU;QACpE,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ,UAAU,CAAC;IAC5C;IAEA,WAAW,QAAsB,EAAU;QACzC,MAAM,cAAc,0BAAI,UAAU,CAAC;QACnC,IAAI,MAAM,IAAI,CAAC,WAAW,CAAC,YAAY,QAAQ;QAC/C,IAAI,QAAQ;QAEZ,MAAO,CAAC,IAAI,MAAM,CAAC,gBAAgB,QAAQ,GAAI;YAC7C,MAAM,IAAI,WAAW,GAAG,WAAW,CAAC,YAAY,QAAQ;YACxD,SAAS;QACX;QAEA,OAAO;IACT;IAEA,YACE,QAAE,KAAI,YAAE,WAAW,IAAI,UAAE,QAAQ,KAAK,GACyC,CAC/E;QACA,IAAI,CAAC,IAAI,GAAG,AAAC,gBAAgB,CAAA,GAAA,wCAAG,IAAK,OAAO,CAAA,GAAA,wCAAG,EAAE,KAAK,CAAC,KAAK;QAC5D,IAAI,CAAC,QAAQ,GAAG,YAAY,IAAI;QAChC,IAAI,CAAC,KAAK,GAAG,SAAS,KAAK;QAE3B,IAAI,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI;IACxC;IAEA,UAAmB;QACjB,OAAO,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO;IACxC;IAEA,QAAa;QACX,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;IACnB;IAEA,cAAc,GAAQ,EAAO;QAC3B,IAAI,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAK,IAAI,OAAO,IAAI,CAAC,KAAK;QAEtC,MAAM,oBAAoB,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,IAAI,KAAK,IAAI,4CAAsB,IAAI,CAAC,QAAQ;QAEzG,OAAO,IAAI,SAAS,CAAC,mBAAmB,SAAS,GAAG,WAAW,CAAC,IAAI,QAAQ;IAC9E;IAEA,oBAAoB,GAAQ,EAAU;QACpC,OAAO,IAAI,CAAC,aAAa,CAAC,KAAK,QAAQ;IACzC;IAEA,GAAG,IAAe,EAAW;QAC3B,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;IACtB;IAEA,YAAqB;QACnB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAO,AAAD;IACvB;IAEA,gBAAyB;QACvB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAM,AAAD;IACtB;IAEA,YAAqB;QACnB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAO,AAAD;IACvB;IAEA,OAAO,QAAa,EAAW;QAC7B,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,IAAI,KAAK,IAAI,CAAC,QAAQ,KAAK,SAAS,QAAQ;IAC/E;IAEA,UAAU,MAAkB,IAAI,EAAO;QACrC,IAAI,IAAI,CAAC,SAAS,IAAI,OAAO,IAAI,CAAC,KAAK;QAEvC,IAAI,IAAI,CAAC,SAAS,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS;QAAG;QAEpE,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM,mBAAmB;QAE7C,OAAO,IAAI,CAAC,oBAAoB,CAAC,GAAG;IACtC;IAEA,gBAAgB,MAAkB,IAAI,EAAU;QAC9C,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,QAAQ;IACrC;IAEA,UAAU,MAAkB,IAAI,EAAO;QACrC,IAAI,IAAI,CAAC,SAAS,IAAI,OAAO,IAAI,CAAC,KAAK;QAEvC,IAAI,IAAI,CAAC,SAAS,IAAI,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS;QAAG;QAEpE,IAAI,KAAK,OAAO,IAAI,CAAC,oBAAoB,CAAC,KAAK;QAE/C,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA,gBAAgB,MAAkB,IAAI,EAAU;QAC9C,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,QAAQ;IACrC;IAEA,SAAS,aAAE,YAAY,IAAI,uBAAE,qBAAqB,KAAK,GAAE,GAAG,CAAC,CAAC,EAAU;QACtE,OAAQ,IAAI,CAAC,IAAI,CAAC,IAAI;YACpB,KAAK,GAAA,yCAAM;gBACT,OAAO,IAAI,CAAC,uBAAuB,CAAC,WAAW;YACjD,KAAK,GAAA,yCAAO;gBACV,OAAO,IAAI,CAAC,mBAAmB,CAAC;YAClC,KAAK,GAAA,yCAAO;gBACV,OAAO,IAAI,CAAC,mBAAmB;YACjC;gBACE,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;QAC9D;IACF;IAEQ,wBAAwB,SAAkB,EAAE,eAAwB,EAAU;QACpF,MAAM,WAAW,kBAAkB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ;QACvE,OAAO,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,YAAY,GAAG,EAAE,IAAI,CAAC,KAAK,IAAI,YAAY,MAAM,EAAE,CAAC,CAAC;IAC7E;IAEQ,oBAAoB,SAAkB,EAAU;QACtD,OAAO,CAAC,EAAE,IAAI,CAAC,QAAQ,IAAI,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,IAAI,YAAY,MAAM,EAAE,CAAC,CAAC;IAClF;IAEQ,sBAA8B;QACpC,OAAO,CAAC,EAAE,IAAI,CAAC,QAAQ,IAAI,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IAC7C;IAEA,UAAU,KAAa,EAAO;QAC5B,IAAI,UAAU,GAAG,OAAO,IAAI;QAE5B,MAAM,mBAAmB,IAAI,CAAC,QAAQ;QACtC,IAAI,gBAAgB,IAAI,CAAC,KAAK;QAC9B,MAAM,OAAO,AAAC,QAAQ,IAAK,kBAAkB,aAAa;QAE1D,IAAK,IAAI,IAAI,GAAG,QAAQ,KAAK,GAAG,CAAC,QAAQ,IAAI,OAAO,KAAK,EACvD,gBAAgB,aAAa,CAAC,KAAK;QAGrC,OAAO,cAAc,WAAW,CAAC;IACnC;IAEA,cAAmB;QACjB,IAAI,IAAI,CAAC,QAAQ,KAAK,4BAAM,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,UAAU,IAAI;QAAC;QAE7D,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG,KAAK,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE;QAAG;QAE9E,IAAI,IAAI,CAAC,QAAQ,KAAK,6BAAO,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE;YAAI,UAAU,IAAI;QAAC;QAEpF,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,UAAU;QAAM;IACpC;IAEA,gBAAqB;QACnB,IAAI,IAAI,CAAC,QAAQ,KAAK,6BAAO,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,UAAU,IAAI;QAAC;QAE9D,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG,KAAK,MAC/B,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI;QAAG;QAG3C,IAAI,IAAI,CAAC,QAAQ,KAAK,4BAAM,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI;YAAI,UAAU,IAAI;QAAC;QAErF,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,UAAU;QAAK;IACnC;IAEA,YAAY,WAA4B,EAAO;QAC7C,IAAI,IAAI,CAAC,QAAQ,KAAK,8BAAQ,gBAAgB,6BAC5C,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI;YAAI,UAAU;QAAM;QAG5D,IAAI,IAAI,CAAC,QAAQ,KAAK,+BAAS,gBAAgB,4BAC7C,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE;YAAI,UAAU;QAAK;QAGzD,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA,YAAiB;QACf,IAAI,IAAI,CAAC,QAAQ,KAAK,+BAAS,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG,KAAK,MAC1D,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE;YAAI,UAAU,IAAI;QAAC;QAGzD,IAAI,IAAI,CAAC,QAAQ,KAAK,8BAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,GAAG,KAAK,MACzD,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI;YAAI,UAAU,IAAI;QAAC;QAG3D,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA,cAAmB;QACjB,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,OAAO,KAAK;QAAC;IACjC;IAEA,qBAAqB,GAAwB,EAAO;QAClD,IAAI,KAAK;YACP,MAAM,gBAAgB,0BAAI,UAAU,CAAC,KAAK,QAAQ,CAAC;gBAAE,WAAW,IAAI;YAAC;YACrE,MAAM,cAAc,CAAA,GAAA,wCAAkB,AAAD,CAAC,CAAC,cAAc;YACrD,MAAM,gBAAgB,IAAI,CAAC,QAAQ,CAAC;gBAAE,WAAW,KAAK;YAAC;YAEvD,IAAI,eAAe,WAAW,CAAC,cAAc,EAC3C,OAAO,0BAAI,WAAW,CAAC,WAAW,CAAC,cAAc;QAErD,CAAC;QAED,OAAO,IAAI,CAAC,KAAK;IACnB;IAEQ,IAAI,UAAyB,EAAO;QAC1C,OAAO,IAAI,0BAAI;YACb,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK;YACrB,UAAU,IAAI,CAAC,QAAQ;YACvB,OAAO,IAAI,CAAC,KAAK;YACjB,GAAG,UAAU;QACf;IACF;IAEQ,qBAAqB,IAAqB,EAAE,GAAQ,EAAE;QAC5D,IAAI,aAAa,IAAI,0BAAI;kBAAE;QAAK;QAChC,IAAI,YAAY,IAAI,KAAK;QACzB,MAAM,YAAY,IAAI,CAAC,KAAK,GAAG,SAAS,GAAG,WAAW,CAAC,IAAI,QAAQ,EAAE,oBAAoB,CAAC;QAE1F,MAAO,CAAC,UAAU,MAAM,CAAC,WAAY;YACnC,aAAa,WAAW,WAAW,GAAG,WAAW,CAAC,IAAI,QAAQ;YAC9D,YAAY,UAAU,WAAW,GAAG,SAAS,GAAG,WAAW,CAAC,IAAI,QAAQ,EAAE,oBAAoB,CAAC;QACjG;QAEA,OAAO;IACT;AACF;IAEA,2CAAe;;;AKrUf,MAAM,gCAAkC;IACtC,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,QAAQ;IACR,MAAM;IACN,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,WAAW;IACX,QAAQ;IACR,SAAS;IACT,WAAW;IACX,OAAO;IACP,QAAQ;IACR,UAAU;IACV,OAAO;IACP,QAAQ;IACR,UAAU;IACV,UAAU;IACV,OAAO;IACP,QAAQ;IACR,UAAU;IACV,OAAO;IACP,OAAO;IACP,QAAQ;IACR,UAAU;IACV,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,QAAQ;IACR,WAAW;IACX,OAAO;IACP,SAAS;IACT,KAAK;IACL,MAAM;IACN,MAAM;IACN,QAAQ;IACR,KAAK;IACL,OAAO;IACP,QAAQ;IACR,MAAM;IACN,MAAM;IACN,QAAQ;IACR,KAAK;IACL,SAAS;IACT,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,SAAS;IACT,WAAW;IACX,UAAU;IACV,SAAS;IACT,UAAU;IACV,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,QAAQ;IACR,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,aAAa;IACb,UAAU;IACV,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,SAAS;IACT,mBAAmB;IACnB,SAAS;IACT,QAAQ;IACR,WAAW;IACX,UAAU;IACV,UAAU;IACV,QAAQ;IACR,SAAS;IACT,OAAO;IACP,SAAS;IACT,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,SAAS;IACT,UAAU;IACV,QAAQ;IACR,WAAW;IACX,QAAQ;IACR,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,SAAS;IACT,QAAQ;IACR,OAAO;IACP,OAAO;IACP,SAAS;IACT,MAAM;IACN,SAAS;IACT,WAAW;IACX,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,WAAW;IACX,QAAQ;IACR,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,WAAW;IACX,UAAU;IACV,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY;IACZ,SAAS;IACT,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,QAAQ;IACR,MAAM;IACN,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,QAAQ;IACR,SAAS;IACT,QAAQ;IACR,UAAU;IACV,SAAS;IACT,YAAY;IACZ,UAAU;IACV,SAAS;IACT,OAAO;IACP,SAAS;IACT,OAAO;IACP,OAAO;IACP,SAAS;IACT,SAAS;IACT,OAAO;IACP,QAAQ;IACR,MAAM;IACN,SAAS;IACT,WAAW;IACX,KAAK;IACL,MAAM;IACN,OAAO;IACP,SAAS;IACT,KAAK;IACL,SAAS;IACT,YAAY;IACZ,QAAQ;IACR,WAAW;IACX,QAAQ;IACR,WAAW;IACX,UAAU;IACV,SAAS;IACT,YAAY;IACZ,aAAa;IACb,WAAW;IACX,SAAS;IACT,OAAO;IACP,UAAU;IACV,SAAS;IACT,YAAY;IACZ,aAAa;IACb,WAAW;IACX,SAAS;IACT,OAAO;IACP,UAAU;IACV,OAAO;IACP,QAAQ;IACR,SAAS;IACT,OAAO;IACP,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,QAAQ;IACR,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,aAAa;IACb,WAAW;IACX,UAAU;IACV,aAAa;IACb,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,cAAc;IACd,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,QAAQ;IACR,WAAW;IACX,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,cAAc;IACd,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,aAAa;IACb,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,aAAa;IACb,WAAW;IACX,UAAU;IACV,aAAa;IACb,cAAc;IACd,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,OAAO;IACP,QAAQ;IACR,SAAS;IACT,OAAO;IACP,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,MAAM;IACN,OAAO;IACP,QAAQ;IACR,WAAW;IACX,SAAS;IACT,MAAM;IACN,MAAM;IACN,OAAO;IACP,QAAQ;IACR,MAAM;IACN,UAAU;IACV,SAAS;IACT,UAAU;IACV,YAAY;IACZ,OAAO;IACP,WAAW;IACX,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,MAAM;IACN,OAAO;IACP,QAAQ;IACR,MAAM;IACN,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,UAAU;IACV,SAAS;IACT,YAAY;IACZ,aAAa;IACb,OAAO;IACP,SAAS;IACT,YAAY;IACZ,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,WAAW;IACX,aAAa;IACb,UAAU;IACV,SAAS;IACT,MAAM;IACN,OAAO;IACP,QAAQ;IACR,MAAM;IACN,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,UAAU;IACV,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,UAAU;IACV,QAAQ;IACR,UAAU;IACV,WAAW;IACX,YAAY;IACZ,UAAU;IACV,UAAU;IACV,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,OAAO;IACP,OAAO;IACP,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,aAAa;IACb,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,cAAc;IACd,WAAW;IACX,WAAW;IACX,aAAa;IACb,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,aAAa;IACb,WAAW;IACX,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,aAAa;IACb,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,UAAU;IACV,OAAO;IACP,OAAO;IACP,aAAa;IACb,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,YAAY;IACZ,UAAU;IACV,UAAU;IACV,YAAY;IACZ,cAAc;IACd,UAAU;IACV,WAAW;IACX,aAAa;IACb,eAAe;IACf,cAAc;IACd,cAAc;IACd,gBAAgB;IAChB,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,gBAAgB;IAChB,YAAY;IACZ,aAAa;IACb,eAAe;IACf,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,aAAa;IACb,WAAW;IACX,WAAW;IACX,SAAS;IACT,WAAW;IACX,SAAS;IACT,aAAa;IACb,UAAU;IACV,YAAY;IACZ,UAAU;IACV,cAAc;IACd,aAAa;IACb,eAAe;IACf,aAAa;IACb,aAAa;IACb,WAAW;IACX,aAAa;IACb,WAAW;IACX,eAAe;IACf,WAAW;IACX,cAAc;IACd,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,cAAc;IACd,aAAa;IACb,aAAa;IACb,eAAe;IACf,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,eAAe;IACf,WAAW;IACX,YAAY;IACZ,cAAc;IACd,OAAO;IACP,UAAU;IACV,QAAQ;IACR,OAAO;IACP,MAAM;IACN,MAAM;IACN,MAAM;IACN,QAAQ;IACR,QAAQ;IACR,cAAc;IACd,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,YAAY;IACZ,WAAW;IACX,WAAW;IACX,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,WAAW;IACX,YAAY;IACZ,aAAa;IACb,WAAW;IACX,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,UAAU;IACV,YAAY;IACZ,WAAW;IACX,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,YAAY;IACZ,SAAS;IACT,MAAM;IACN,MAAM;IACN,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,YAAY;IACZ,cAAc;IACd,aAAa;IACb,aAAa;IACb,eAAe;IACf,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,eAAe;IACf,YAAY;IACZ,cAAc;IACd,WAAW;IACX,WAAW;IACX,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,WAAW;IACX,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,SAAS;IACT,SAAS;IACT,WAAW;IACX,aAAa;IACb,UAAU;IACV,YAAY;IACZ,cAAc;IACd,aAAa;IACb,aAAa;IACb,eAAe;IACf,aAAa;IACb,WAAW;IACX,WAAW;IACX,aAAa;IACb,eAAe;IACf,YAAY;IACZ,YAAY;IACZ,cAAc;IACd,WAAW;IACX,UAAU;IACV,UAAU;IACV,YAAY;IACZ,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,UAAU;IACV,YAAY;IACZ,SAAS;IACT,SAAS;IACT,WAAW;IACX,OAAO;IACP,QAAQ;IACR,YAAY;IACZ,UAAU;AACZ;IAEA,2CAAe;;;;;APp4Bf,SAAS,2CAAqB,MAAqB,EAAiB;IAClE,IAAI,WAAW,IAAI,EACjB,OAAO,IAAI;IAGb,IAAI,CAAA,GAAA,wCAAa,CAAC,CAAC,OAAO,KAAK,WAC7B,OAAO,IAAI;IAGb,OAAO,CAAA,GAAA,wCAAa,CAAC,CAAC,OAAO,IAAI;AACnC;AAQA;;CAEC,GACD,MAAM;IAOJ;;;;;GAKC,GACD,OAAO,MAAM,WAAmB,EAAgB;QAC9C,IAAI;YACF,OAAO,IAAI,CAAC,WAAW,CAAC;QAC1B,EAAE,OAAO,QAAQ;YACf,OAAO,IAAI;QACb;IACF;IAEA,OAAO,YAAY,WAAmB,EAAS;QAC7C,MAAM,MAAM,CAAA,GAAA,yCAAK,AAAD,EAAE,YAAY,IAAI;QAClC,OAAO,IAAI,4BAAM;IACnB;IAEA;;;GAGC,GACD,QAAe;QACb,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;IACnB;IAEA;;;;;;;GAOC,GACD,cAAc,eAAoC,IAAI,EAAS;QAC7D,IAAI,IAAI,CAAC,aAAa,IACpB,OAAO,IAAI,CAAC,KAAK;QAGnB,MAAM,SAAS,CAAA,GAAA,wCAAG,AAAD,EAAE,UAAU,CAAC;QAE9B,IAAI,mBAAmB,IAAI,4BAAM;YAC/B,QAAQ,IAAI,CAAC,MAAM,GAAG,2CAAqB,IAAI,CAAC,MAAM,IAAI,IAAI;YAC9D,MAAM,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;YAC9B,MAAM,IAAI,CAAC,IAAI,EAAE,cAAc,WAAW,IAAI;QAChD;QAEA,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,IACnB,mBAAmB,iBAAiB,SAAS;QAG/C,mBAAmB,iBAAiB,SAAS,CAAC;QAE9C,OAAO;IACT;IAEA;;;;;;;;GAQC,GACD,oBAAoB,eAAoC,IAAI,EAAU;QACpE,OAAO,IAAI,CAAC,aAAa,CAAC,cAAc,QAAQ;IAClD;IAEA;;;GAGC,GACD,gBAAyB;QACvB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAM,AAAD;IACtB;IAEA;;;;;GAKC,GACD,UAAU,eAAoC,IAAI,EAAS;QACzD,IAAI,IAAI,CAAC,SAAS,IAChB,OAAO,IAAI,CAAC,KAAK;QAGnB,IAAI,IAAI,CAAC,SAAS,IAChB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,MAAQ,IAAI,SAAS;QAG9C,MAAM,SAAS,CAAA,GAAA,wCAAG,AAAD,EAAE,UAAU,CAAC;QAE9B,OAAO,IAAI,4BAAM;YACf,QAAQ,2CAAqB,IAAI,CAAC,MAAM;YACxC,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC;YAC1B,MAAM,IAAI,CAAC,IAAI,EAAE,UAAU,WAAW,IAAI;QAC5C;IACF;IAEA;;;;;GAKC,GACD,UAAU,eAAoC,IAAI,EAAS;QACzD,IAAI,IAAI,CAAC,SAAS,IAChB,OAAO,IAAI,CAAC,KAAK;QAGnB,IAAI,IAAI,CAAC,SAAS,IAChB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,MAAQ,IAAI,SAAS;QAG9C,MAAM,SAAS,CAAA,GAAA,wCAAG,AAAD,EAAE,UAAU,CAAC;QAE9B,OAAO,IAAI,4BAAM;YACf,QAAQ,2CAAqB,IAAI,CAAC,MAAM;YACxC,MAAM,SAAS,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI;YACjD,MAAM,IAAI,CAAC,IAAI,EAAE,UAAU,WAAW,IAAI;QAC5C;IACF;IAEA;;;;;;GAMC,GACD,gBAAgB,eAAoC,IAAI,EAAU;QAChE,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,QAAQ;IAC9C;IAEA;;;GAGC,GACD,YAAqB;QACnB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAO,AAAD;IACvB;IAEA;;;;;;GAMC,GACD,gBAAgB,eAAoC,IAAI,EAAU;QAChE,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,QAAQ;IAC9C;IAEA;;;GAGC,GACD,YAAqB;QACnB,OAAO,IAAI,CAAC,EAAE,CAAC,CAAA,GAAA,yCAAO,AAAD;IACvB;IAEA;;;;;;GAMC,GACD,SAAS,sBAAE,qBAAqB,KAAK,GAAE,GAAG,CAAC,CAAC,EAAU;QACpD,MAAM,cAAc,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YAAE,WAAW,KAAK;gCAAE;QAAmB,KAAM,CAAA,IAAI,CAAC,MAAM,IAAI,EAAC;QAEpG,IAAI,IAAI,CAAC,IAAI,EACX,OAAO,CAAC,EAAE,YAAY,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;gCAAE;QAAmB,GAAG,CAAC;QAGvE,OAAO;IACT;IAEA;;;;;;;;;;;;;;;;;;;;;GAqBC,GACD,UAAU,MAA2B,IAAI,EAAE,mBAAE,kBAAkB,IAAI,GAAE,GAAG,CAAC,CAAC,EAAS;QACjF,MAAM,SAAS,kBAAkB,2CAAqB,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM;QAEhF,IAAI,cAAc,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,oBAAoB,CAAC;QAC7D,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,MAAM,IAAI,CAAC,IAAI,EAClC,cAAc,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,WAAW,GAAG,SAAS;QAG9D,OAAO,IAAI,CAAC,GAAG,CAAC;oBACd;YACA,MAAM,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,oBAAoB,CAAC;YACjD,MAAM,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,oBAAoB,CAAC,eAAe,IAAI;QAClF;IACF;IAEA;;;;GAIC,GACD,YAAY,WAAqB,EAAS;QACxC,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,MAAQ,IAAI,WAAW,CAAC;IACjD;IAEA;;;GAGC,GACD,cAAqB;QACnB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,MAAQ,IAAI,WAAW;IAChD;IAEA;;;GAGC,GACD,gBAAuB;QACrB,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,MAAQ,IAAI,aAAa;IAClD;IAEA;;;;GAIC,GACD,UAAU,KAAa,EAAS;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,MAAQ,IAAI,SAAS,CAAC;IAC/C;IAEA,YACE,QACE,OAAO,IAAI,aACX,WAAW,IAAI,WACf,SAAS,IAAI,aACb,WAAW,IAAI,iBACf,eAAe,IAAI,SACnB,OAAO,IAAI,SACX,OAAO,IAAI,GASZ,CACD;QACA,IAAI,CAAC,MAAM,GAAG,UAAU,IAAI;QAC5B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,MAAM,UAAU;QACrD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,UAAU;IACjD;IAEA,cAAc,IAAgB,EAAE,IAA4B,EAAE,QAAyB,EAAE,MAAqB,EAAO;QACnH,IAAI,MACF,OAAO;QAGT,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM,iBAAiB;QAE5C,OAAO,IAAI,CAAA,GAAA,wCAAE,EAAE;YAAE,MAAM;sBAAM;YAAU,OAAO,CAAA,GAAA,yCAAM,EAAE;QAAQ;IAChE;IAEA,cAAc,IAAgB,EAAE,QAAgC,EAAE,YAA6B,EAAc;QAC3G,IAAI,MACF,OAAO;QAGT,IAAI,UACF,OAAO,IAAI,CAAA,GAAA,wCAAE,EAAE;YAAE,MAAM;YAAU,UAAU,gBAAgB,IAAI;YAAE,OAAO,KAAK;QAAC;QAGhF,OAAO,IAAI;IACb;IAEA,YAAmB;QACjB,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,KACrC,OAAO,IAAI,CAAC,GAAG,CAAC;YAAE,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,IAAI,GAAG,CAAC;QAAC;QAGpD,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA,IAAI,UAA2B,EAAS;QACtC,OAAO,IAAI,4BACT;YACE,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK;YACrB,QAAQ,IAAI,CAAC,MAAM;YACnB,MAAM,IAAI,CAAC,IAAI,EAAE,WAAW,IAAI;YAChC,GAAG,UAAU;QACf;IAEJ;IAEQ,GAAG,IAAe,EAAW;QACnC,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,SAAU,CAAA,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAI;IAC/D;IAEQ,UAAU,aAAiC,EAAS;QAC1D,OAAO,IAAI,CAAC,GAAG,CAAC;YACd,MAAM,cAAc,IAAI,CAAC,IAAI;YAC7B,MAAM,IAAI,CAAC,IAAI,GAAG,cAAc,IAAI,CAAC,IAAI,IAAI,IAAI;QACnD;IACF;AACF;AAQO,SAAS,0CAAW,WAAmB,EAAgB;IAC5D,CAAA,GAAA,yCAAS,AAAD,EAAE;IACV,OAAO,4BAAM,KAAK,CAAC;AACrB;IAEA,2CAAe;;ADxXf;AAGA;;CAEC,GACD,MAAM;IAKJ;;;;GAIC,GACD,YAAY,SAAS,EAAE,EAAE,SAAwB,IAAI,CAAE;QACrD;;;;KAIC,GACD,IAAI,CAAC,MAAM,GAAG,UAAU;QAExB;;;;KAIC,GACD,IAAI,CAAC,MAAM,GAAG,UAAU;IAC1B;IAEA;;;GAGC,GACD,eAAwB;QACtB,OAAO,IAAI;IACb;IAEA;;;GAGC,GACD,QAAyB;QACvB,OAAO,IAAI,sCAAgB,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM;IACrD;IAEA,WAAmB;QACjB,OAAO,CAAC,uBAAuB,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IACxE;IAEA,IAAI,UAAE,OAAM,UAAE,OAAM,EAAwC,EAAmB;QAC7E,OAAO,IAAI,sCACT,UAAU,IAAI,CAAC,MAAM,EACrB,UAAU,IAAI,CAAC,MAAM;IAEzB;IAEA,UAAU,MAAc,EAAmB;QACzC,OAAO,IAAI,CAAC,GAAG,CAAC;oBAAE;QAAO;IAC3B;IAEA,UACE,KAAa,EACb,MAA2B,IAAI,EAC/B,wBAAE,qBAAoB,EAAqC,GAAG;QAAE,sBAAsB,KAAK;IAAC,CAAC,EAC5E;QACjB,MAAM,WAAW,CAAA,GAAA,wCAAK,AAAD,EAAE,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI;QAE7C,IAAI,UAAU;YACZ,IAAI,kBAAkB,SAAS,SAAS,CAAC;YAEzC,IAAI,KACF,kBAAkB,gBAAgB,SAAS,CAAC,KAAK;gBAAE,iBAAiB;YAAqB;YAG3F,OAAO,IAAI,CAAC,GAAG,CAAC;gBAAE,QAAQ,gBAAgB,QAAQ;YAAG;QACvD,CAAC;QAED,OAAO,IAAI,CAAC,KAAK;IACnB;AACF;IAEA,2CAAe;;ADpFf;AYAA;ACIO,MAAM,4CAAgE;IAC3E,WAAW;AACb;AAEA,MAAM;IAGJ,YAAY,wBAAyD,yCAA4B,CAAE;QACjG,IAAI,CAAC,SAAS,GAAG,sBAAsB,SAAS;IAClD;AACF;IAEA,2CAAe;;;;ADAR,MAAM,4CAAgD;IAC3D,UAAU,KAAK;IACf,UAAU;QAAE,WAAW;IAAI;IAC3B,KAAK,IAAI;IACT,uBAAuB,KAAK;IAC5B,qBAAqB,KAAK;IAC1B,iBAAiB,IAAI;AACvB;AAEA,MAAM;IAeJ,YAAY,gBAAyC,yCAAoB,CAAE;QACzE,MAAM,eAAwC;YAAE,GAAG,yCAAoB;YAAE,GAAG,aAAa;QAAC;QAC1F,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC,aAAa,QAAQ;QACvC,IAAI,CAAC,qBAAqB,GAAG,CAAC,CAAC,aAAa,qBAAqB;QACjE,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC,aAAa,mBAAmB;QAC7D,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,aAAa,eAAe;QACrD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAA,GAAA,wCAAqB,AAAD,EAAE,cAAc,QAAQ;QAChE,IAAI,CAAC,GAAG,GAAG,cAAc,GAAG,GAAG,CAAA,GAAA,wCAAE,EAAE,IAAI,CAAC,cAAc,GAAG,IAAI,IAAI;QACjE,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA,IAAI,GAAW,EAAU;QACvB,OAAO,CAAA,GAAA,gBAAS,AAAD,EAAE,IAAI,EAAE;IACzB;AACF;IAEA,2CAAe;;ADxDf;AAEA;;CAEC,GACD,MAAM;IAGJ;;;;;;;;;;;;;;;;KAgBG,GACH,YAAY,gBAAgD,IAAI,CAAE;QAChE,IAAI,CAAC,aAAa,GAAG,IAAI,CAAA,GAAA,wCAAa,AAAD,EAAE,iBAAiB,CAAC;IAC3D;AACF;IAEA,2CAAe;;AD9Bf;AIAA;;;ACEA,MAAe;IACb,OAAsB,IAAI,CAAC;IAE3B,SAAwB,IAAI,CAAC;IAE7B,SAAwB,IAAI,CAAC;IAE7B,YAAsB,YAA8B,IAAI,CAAE;QACxD,IAAI,WAAW;YACb,IAAI,CAAC,IAAI,GAAG,UAAU,IAAI,IAAI,IAAI;YAClC,IAAI,CAAC,MAAM,GAAG,UAAU,MAAM,IAAI,IAAI;YACtC,IAAI,CAAC,MAAM,GAAG,UAAU,MAAM,IAAI,IAAI;QACxC,CAAC;IACH;AAGF;IAEA,2CAAe;;CDjBd,GACD;AAGO,MAAM,4CAAQ;AAMd,MAAM,2CAAS;AAMf,MAAM,4CAAO;AAMb,MAAM,4CAAU;AAMhB,MAAM,4CAAW;AAMjB,MAAM,4CAAY;AAMlB,MAAM,4CAAW;AAMjB,MAAM,4CAAgB;AAMtB,MAAM,4CAAgB;AAMtB,MAAM,4CAAa;AAMnB,MAAM,4CAAe;AAMrB,MAAM,4CAAM;AAOZ,MAAM,2CAAO;AAMb,MAAM,4CAAW;AAMjB,MAAM,4CAAkB;AAMxB,MAAM,4CAAkB;AAMxB,MAAM,4CAAe;AAMrB,MAAM,4CAAiB;AAMvB,MAAM,4CAAW;AAMjB,MAAM,4CAAQ;AAMd,MAAM,4CAAO;AAMb,MAAM,4CAAQ;AAMd,MAAM,4CAAY;AAKlB,MAAM,4CAAU;AAMhB,MAAM,4CAAO;AAMb,MAAM,4CAAY;AAMlB,MAAM,4CAAY;AAMlB,MAAM,4CAAc;AAMpB,MAAM,4CAAW;AAMjB,MAAM,4CAAW;AAMjB,MAAM,4CAAa;AAMnB,MAAM,4CAAY;AAMlB,MAAM,4CAAY;AAMlB,MAAM,4CAAc;AAOpB,MAAM,4CAAS;AAEtB,MAAM,oCAAc;AACpB,MAAM,uCAAiB;AACvB,MAAM,sCAAgB;AACtB,MAAM,8CAAwB;AAC9B,MAAM,4CAAsB;AAC5B,MAAM,2CAAqB;AAC3B,MAAM,yCAAmB;AACzB,MAAM,sCAAgB;AACtB,MAAM,wCAAkB;AACxB,MAAM,wCAAkB;AACxB,MAAM,uCAAiB;AACvB,MAAM,uCAAiB;AAEvB,MAAM,wCAAkB;IAAC;CAAQ;AAE1B,MAAM,2CAAY;IACvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAEM,MAAM,4CAAiB;IAAC;CAAK;AAEpC,MAAM,2CAAqB;IACzB;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,yCAAmB;IACvB;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,yDAAmC;IACvC;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,gCAAkC;IACtC,CAAC,kCAAY,EAAE;IACf,CAAC,qCAAe,EAAE;IAClB,CAAC,oCAAc,EAAE;IACjB,CAAC,4CAAsB,EAAE;IACzB,CAAC,0CAAoB,EAAE;IACvB,CAAC,yCAAmB,EAAE;IACtB,CAAC,uCAAiB,EAAE;IACpB,CAAC,oCAAc,EAAE;IACjB,CAAC,sCAAgB,EAAE;IACnB,CAAC,sCAAgB,EAAE;IACnB,CAAC,qCAAe,EAAE;IAClB,CAAC,qCAAe,EAAE;AACpB;AAEA,MAAM,kCAAY;AAClB,MAAM,mDAA6B;AAE5B,SAAS,0CAAc,OAAe,EAAE;IAC7C,OAAO,0CAAe,QAAQ,CAAC;AACjC;AAEA,MAAM,8CAAwB,CAAC,OAAiB;IAC9C,IAAI,CAAC,MACH,OAAO;IAGT,MAAM,gBAAgB,KAAK,IAAI;IAE/B,IAAI,iBAAiB,+BACnB,OAAO,6BAAO,CAAC,cAAc;IAG/B,OAAO;AACT;AAEA;;CAEC,GACD,MAAM,kCAAY,CAAA,GAAA,wCAAY,AAAD;IAC3B,gBAAgB,GAAG;IAEnB,QAAQ,GAAG;IAEX,SAAS,GAAG;IAEZ,aAAa,KAAK,CAAC;IAEnB,YAAY,IAAY,EAAE,QAAuB,IAAI,EAAE,YAA8B,IAAI,CAAE;QACzF,KAAK,CAAC;QACN,IAAI,CAAC,cAAc,CAAC,MAAM;IAC5B;IAEQ,eAAe,IAAY,EAAE,KAAoB,EAAQ;QAC/D,IAAI,SAAS,QACX,IAAI,CAAC,YAAY,CAAC;aACb;YACL,IAAI,CAAC,IAAI,GAAG;YACZ,IAAI,CAAC,KAAK,GAAG,SAAS;QACxB,CAAC;IACH;IAEQ,aAAa,KAAoB,EAAE;QACzC,IAAI,CAAC,OACH,MAAM,IAAI,MAAM,kBAAkB;QAGpC,MAAM,CAAC,UAAU,UAAU,GAAG,MAAM,KAAK,CAAC;QAC1C,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG,aAAa;QAC1B,IAAI,CAAC,UAAU,GAAG,IAAI;IACxB;IAEA,OAAO,MAAM,GAAiB,EAAc;QAC1C,IAAI,eAAe,2BACjB,OAAO;QAGT,OAAO,IAAI,CAAC,cAAc,CAAC,KAAK;IAClC;IAEA,OAAO,eAAe,GAAW,EAAE,KAAa,EAAc;QAC5D,MAAM,UAAU,IAAI,KAAK,CAAC;QAE1B,IAAI,YAAY,IAAI,EAClB,OAAO,IAAI,0BAAI,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,IAAI,IAAI;QAG/C,OAAO,IAAI;IACb;IAEA,OAAO,YAAY,GAAiB,EAAO;QACzC,MAAM,SAAS,IAAI,CAAC,KAAK,CAAC;QAE1B,IAAI,CAAC,QACH,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,EAAE;QAG5C,OAAO;IACT;IAEA,qBAA8B;QAC5B,OAAO,yCAAmB,QAAQ,CAAC,IAAI,CAAC,IAAI;IAC9C;IAEA,kBAA2B;QACzB,OAAO,uCAAiB,QAAQ,CAAC,IAAI,CAAC,IAAI;IAC5C;IAEA,IAAI,KAAK,IAAI,EAAE;QACb,IAAI,CAAC,KAAK,GAAG,4CAAsB;QACnC,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA;;;;GAIC,GACD,IAAI,OAAO;QACT,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI;IACxB;IAEA;;;;GAIC,GACD,IAAI,eAAe;QACjB,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI;IAChC;IAEA,IAAI,MAAM,KAAK,EAAE;QACf,IAAI,CAAC,MAAM,GAAG,SAAS;IACzB;IAEA;;;;GAIC,GACD,IAAI,QAAgB;QAClB,OAAO,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI;IAC9B;IAEA;;;GAGC,GACD,WAAoB;QAClB,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;IAC7B;IAEA;;;GAGC,GACD,eAAwB;QACtB,OAAO,sCAAgB,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,kBAAkB;IACvE;IAEA;;;;;GAKC,GACD,qBAA8B;QAC5B,OAAO,uDAAiC,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ;IAC9E;IAEA;;;GAGC,GACD,YAAqB;QACnB,OAAO,IAAI,CAAC,UAAU,IAAI,iDAA2B,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,yCAAU,OAAO,CAAC,IAAI,CAAC,IAAI,MAAM;IAC3G;IAEA;;;GAGC,GACD,QAAa;QACX,OAAO,IAAI,0BAAI,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,KAAK;IAC/C;IAEA,WAAmB;QACjB,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACtD;IAEA,IAAI,SAAE,MAAK,EAAqB,EAAO;QACrC,OAAO,IAAI,0BAAI,IAAI,CAAC,aAAa,EAAE;IACrC;AACF;IAEA,2CAAe;;;;AGrdf,MAAM,8CAAwB;IAC5B,OAAsB,IAAI,CAAC;IAE3B,SAAwB,IAAI,CAAC;IAE7B,SAAwB,IAAI,CAAC;IAE7B,YAAY,OAAe,EAAE,OAAsB,IAAI,EAAE,SAAwB,IAAI,EAAE,SAAwB,IAAI,CAAE;QACnH,KAAK,CAAC,CAAC,EAAE,QAAQ,SAAS,EAAE,KAAK,QAAQ,EAAE,OAAO,CAAC;QACnD,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;IAChB;AACF;IAEA,2CAAe;;ADhBf;;AGAA;AAGA,MAAe,0CAAoB,CAAA,GAAA,wCAAY,AAAD;AAI9C;IAEA,2CAAe;;ADTf;AAGA,MAAM,wCAAkB,CAAA,GAAA,wCAAW,AAAD;IAChC,cAA6B,EAAE,CAAC;IAIhC,YAAY,WAA0B,EAAE,WAA0B,IAAI,CAAE;QACtE,KAAK;QACL,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,SAAS,QAAkB,EAAE,iBAAyB,EAAU;QAC9D,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,aAC3B,WAAW,QAAQ,CAAC,UAAU,mBAAmB,IAAI,CAAC,QAAQ,GAC7D,IAAI,CAAC;IACV;IAEA,eAAwB;QACtB,OAAO,IAAI;IACb;IAEA,QAAmB;QACjB,OAAO,IAAI,gCACT,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,aAAe,WAAW,KAAK,KACrD,IAAI,CAAC,QAAQ;IAEjB;AACF;IAEA,2CAAe;;;;AFlBf,MAAM,sCAAgB,CAAA,GAAA,wCAAW,AAAD;IAK9B,iBAAgC,EAAE,CAAC;IAEnC,kBAAiC,EAAE,CAAC;IAEpC,YACE,YACE,WAAW,IAAI,cACf,YAAY,IAAI,mBAChB,iBAAiB,EAAE,oBACnB,kBAAkB,EAAE,SACpB,OAAO,IAAI,WACX,SAAS,IAAI,WACb,SAAS,IAAI,GACK,CACpB;QACA,KAAK,CAAC;kBAAE;oBAAM;oBAAQ;QAAO;QAC7B,IAAI,CAAC,QAAQ,GAAG,YAAY,IAAI;QAChC,IAAI,CAAC,SAAS,GAAG,aAAa,IAAI;QAClC,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,eAAe,GAAG;IACzB;IAEA;;;;;GAKC,GACD,SAAS,QAAkB,EAAE,iBAAyB,EAAE,eAA8B,IAAI,EAAU;QAClG,IAAI,IAAI,CAAC,QAAQ,EACf,OAAO,IAAI,CAAC,oBAAoB,CAAC,UAAU;QAG7C,IAAI,CAAC,cACH,MAAM,IAAI,CAAA,GAAA,wCAAc,EAAE,+BAA+B,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE;QAGhG,OAAO,IAAI,CAAC,gBAAgB,CAAC,SAAS,GAAG,CAAC,iBAAiB,IAAI;IACjE;IAEA,iBAAiB,KAAwB,EAAE,iBAAyB,EAAU;QAC5E,IAAI,MAAM,OAAO,CAAC,QAChB,OAAO,MAAM,IAAI,CAAC;QAGpB,OAAO;IACT;IAEA,qBAAqB,QAAkB,EAAE,iBAAyB,EAAU;QAC1E,IAAI,CAAC,IAAI,CAAC,QAAQ,EAChB,MAAM,IAAI,MAAM,wCAAwC;QAG1D,MAAM,QAAQ,SAAS,GAAG,CAAC,IAAI,CAAC,QAAQ;QAExC,IAAI,SAAU,CAAA,CAAA,GAAA,yCAAa,AAAD,EAAE,IAAI,CAAC,SAAS,KAAK,UAAU,IAAI,CAAC,SAAS,AAAD,GACpE,OAAO,IAAI,CAAC,sBAAsB,CAAC,UAAU,mBAAmB;QAGlE,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,EAC7B,OAAO,IAAI,CAAA,GAAA,wCAAQ,EAAE,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,UAAU;QAG/E,OAAO;IACT;IAEA,uBAAuB,QAAkB,EAAE,iBAAyB,EAAE,KAAwB,EAAU;QACtG,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,EAC5B,OAAO,IAAI,CAAA,GAAA,wCAAQ,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,UAAU;QAG9E,OAAO,IAAI,CAAC,gBAAgB,CAAC,OAAO;IACtC;IAEA,eAAwB;QACtB,OAAO,IAAI;IACb;IAEA,QAAiB;QACf,OAAO,IAAI,8BAAQ;YACjB,UAAU,IAAI,CAAC,QAAQ;YACvB,WAAW,IAAI,CAAC,SAAS;YACzB,gBAAgB,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,OAAS,KAAK,KAAK;YAC5D,iBAAiB,IAAI,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,OAAS,KAAK,KAAK;YAC9D,MAAM,IAAI,CAAC,IAAI;YACf,QAAQ,IAAI,CAAC,MAAM;YACnB,QAAQ,IAAI,CAAC,MAAM;QACrB;IACF;AACF;IAEA,2CAAe;;;AI9Gf;AAEA,MAAM,sCAAgB,CAAA,GAAA,wCAAW,AAAD;IAG9B,YAAY,UAAkB,CAAE;QAC9B,KAAK;QACL,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA,WAAmB;QACjB,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA,eAAwB;QACtB,OAAO,IAAI;IACb;IAEA,QAAiB;QACf,OAAO,IAAI,8BAAQ,IAAI,CAAC,MAAM;IAChC;AACF;IAEA,2CAAe;;;AVZf,MAAM,iCAAW;AAEjB;;CAEC,GACD,MAAM,gDAA0B,CAAA,GAAA,wCAAS,AAAD;IACtC;;;;GAIC,GACD,OAAO,IAAU,EAAU;QACzB,MAAM,SAAE,MAAK,YAAE,SAAQ,EAAE,GAAG;QAE5B,OAAO,MACJ,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,UAAU,CAAC,MAAM,WACpC,IAAI,CAAC;IACV;IAEA,WAAW,IAAU,EAAE,QAAkB,EAAU;QACjD,OAAO,KAAK,KAAK,CACd,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,UAAU,CAAC,MAAM,WACpC,IAAI,CAAC;IACV;IAEA,WAAW,IAAU,EAAE,QAAkB,EAAU;QACjD,IAAI,gBAAgB,CAAA,GAAA,wCAAE,GACpB,OAAO,IAAI,CAAC,SAAS,CAAC;QAGxB,IAAI,gBAAgB,CAAA,GAAA,wCAAc,GAChC,OAAO,IAAI,CAAC,qBAAqB,CAAC;QAGpC,IAAI,cAAc,MAChB,OAAO,IAAI,CAAC,oBAAoB,CAAC,MAAM;QAGzC,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,KAAK,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;IACzE;IAEA,qBAAqB,IAAiB,EAAE,QAAkB,EAAU;QAClE,IAAI,IAAI,CAAC,aAAa,CAAC,QAAQ,EAC7B,OAAO,KAAK,QAAQ,CAAC,UAAU,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC;QAGxD,IAAI,gBAAgB,CAAA,GAAA,wCAAM,GACxB,OAAO,IAAI,CAAC,aAAa,CAAC;QAG5B,IAAI,gBAAgB,CAAA,GAAA,wCAAO,AAAD,GACxB,OAAO,KAAK,QAAQ;QAGtB,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,KAAK,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;IACzE;IAEA,cAAc,OAAgB,EAAU;QACtC,MAAM,YACJ,SAAQ,aACR,UAAS,kBACT,eAAc,mBACd,gBAAe,EAChB,GAAG;QAEJ,OAAO;YACL;YACA,YAAY;YACZ,IAAI,CAAC,eAAe,CAAC;YACrB,IAAI,CAAC,qBAAqB,CAAC;YAC3B,IAAI,CAAC,qBAAqB,CAAC;YAC3B;SACD,CAAC,IAAI,CAAC;IACT;IAEA,gBAAgB,SAAwB,EAAU;QAChD,IAAI,CAAC,WACH,OAAO;QAGT,OAAO,CAAC,CAAC,EAAE,UAAU,CAAC;IACxB;IAEA,sBAAsB,eAA8B,EAAU;QAC5D,IAAI,CAAC,gBAAgB,MAAM,EACzB,OAAO;QAGT,OAAO,CAAC,CAAC,EAAE,gBAAgB,GAAG,CAAC,CAAC,aAAe,IAAI,CAAC,gBAAgB,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC;IAC9F;IAEA,iBAAiB,UAAuB,EAAU;QAChD,IAAI,sBAAsB,CAAA,GAAA,wCAAM,GAC9B,OAAO,IAAI,CAAC,aAAa,CAAC;QAG5B,IAAI,sBAAsB,CAAA,GAAA,wCAAO,AAAD,GAC9B,OAAO,WAAW,MAAM;QAG1B,OAAO;IACT;IAEA,UAAU,GAAG,EAAU;QACrB,IAAI,IAAI,QAAQ,IACd,OAAO,CAAC,CAAC,EAAE,IAAI,YAAY,CAAC,EAAE,EAAE,IAAI,KAAK,CAAC,CAAC,CAAC;QAG9C,OAAO,CAAC,CAAC,EAAE,IAAI,YAAY,CAAC,CAAC,CAAC;IAChC;IAEA,sBAAsB,eAAe,EAAU;QAC7C,OAAO;YACL,IAAI,CAAC,2BAA2B,CAAC;YACjC,IAAI,CAAC,2BAA2B,CAAC;SAClC,CAAC,IAAI,CAAC;IACT;IAEA,4BAA4B,eAAe,EAAU;QACnD,IAAI,gBAAgB,MAAM,EACxB,OAAO,CAAC,CAAC,EAAE,gBAAgB,MAAM,CAAC,CAAC,CAAC;QAGtC,OAAO;IACT;IAEA,4BAA4B,eAAe,EAAU;QACnD,OAAO,gBAAgB,MAAM,IAAI;IACnC;AACF;IAEA,2CAAe;;;AY9If,2CAA2C;AAC3C;ACDA;AEAA;;ACAA;;CAEC,GACD,MAAM;IAGJ,YAAY,OAAe,CAAE;QAC3B,IAAI,CAAC,OAAO,GAAG;IACjB;IAEA;;;GAGC,GACD,eAAwB;QACtB,OAAO,KAAK;IACd;IAEA;;;GAGC,GACD,QAAiB;QACf,OAAO,IAAI,8BAAQ,IAAI,CAAC,OAAO;IACjC;IAEA,WAAmB;QACjB,OAAO,CAAC,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAC3C;AACF;IAEA,2CAAe;;;;ACvBf,MAAM;IACJ;;;GAGC,GACD,OAAsB,IAAI,CAAC;IAE3B;;;GAGC,GACD,OAAwB,IAAI,CAAC;IAE7B;;;GAGC,GACD,SAAwB,IAAI,CAAC;IAE7B,YAAY,QAAE,KAAI,QAAE,KAAI,UAAE,OAAM,EAAkB,GAAG;QAAE,MAAM,IAAI;QAAE,MAAM,IAAI;QAAE,QAAQ,IAAI;IAAC,CAAC,CAAE;QAC7F,IAAI,CAAC,IAAI,GAAG,OAAO,KAAK,OAAO,CAAC,MAAM,OAAQ,IAAI;QAClD,IAAI,CAAC,IAAI,GAAG,QAAQ,IAAI;QACxB,IAAI,CAAC,MAAM,GAAG,UAAU,IAAI;IAC9B;IAEA,QAAQ;QACN,OAAO,IAAI,2BAAK;YACd,MAAM,IAAI,CAAC,IAAI;YACf,MAAM,IAAI,CAAC,IAAI;YACf,QAAQ,IAAI,CAAC,MAAM;QACrB;IACF;IAEA;;;;;;;;;;;;;;;;;;;GAmBC,GACD,cAAsB;QACpB,MAAM,aAAqC,CAAC;QAE5C,IAAI,IAAI,CAAC,MAAM,EACb,WAAW,KAAK,GAAG,IAAI,CAAC,MAAM;QAGhC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,EACxB,WAAW,IAAI,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;aACxC,IAAI,IAAI,CAAC,IAAI,EAClB,UAAU,CAAC,cAAc,GAAG,IAAI,CAAC,IAAI;aAChC,IAAI,IAAI,CAAC,IAAI,EAClB,UAAU,CAAC,YAAY,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QAG1C,OAAO,OACJ,IAAI,CAAC,YACL,GAAG,CAAC,CAAC,MAAQ,CAAC,EAAE,IAAI,EAAE,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC,EACzC,IAAI,CAAC;IACV;AACF;IAEA,2CAAe;;;AFxEf;;CAEC,GACD,MAAM;IACJ;;;GAGC,GACD,QAAgB,EAAE,CAAC;IAEnB;;;;GAIC,GACD,QAAiB,GAAA,yCAAI,EAAC;IAEtB,yBAA0C,IAAI,CAAA,GAAA,wCAAc,IAAI;IAEhE,MAAqB,IAAI,CAAC;IAE1B,eAA8B,IAAI,CAAC;IAEnC,aAA4B,IAAI,CAAC;IAEjC;;;;;GAKC,GACD,WAAiB,IAAI,CAAA,GAAA,wCAAG,IAAI;IAE5B;;;;;GAKC,GACD,YAAkB,IAAI,CAAA,GAAA,wCAAG,IAAI;IAE7B,YAAY,QAAE,KAAI,SAAE,MAAK,EAAoC,GAAG;QAAE,MAAM,CAAA,GAAA,yCAAG;QAAG,OAAO,EAAE;IAAC,CAAC,CAAE;QACzF,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;;GAGC,GACD,UAAmB;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK;IAC/B;IAEA,aAAsB;QACpB,OAAO,CAAC,IAAI,CAAC,OAAO;IACtB;IAEA;;;GAGC,GACD,QAAQ,IAAU,EAAQ;QACxB,IAAI,gBAAgB,CAAA,GAAA,wCAAE,GACpB,IAAI,CAAC,MAAM,CAAC;aACP,IAAI,gBAAgB,CAAA,GAAA,wCAAc,GACvC,IAAI,CAAC,kBAAkB,CAAC;aACnB,IAAI,gBAAgB,CAAA,GAAA,wCAAM,GAC/B,IAAI,CAAC,UAAU,CAAC;aAEhB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;IAEpB;IAEA;;;GAGC,GACD,qBAA8B;QAC5B,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAAS,KAAK,YAAY;IACpD;IAEA;;;GAGC,GACD,QAAc;QACZ,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI;IAC3B;IAEA,SAAS,IAAwB,EAAQ;QACvC,MAAM,aAAa,IAAI;QAEvB,WAAW,KAAK,GAAG,IAAI,CAAC,KAAK,CAC1B,GAAG,CAAC,CAAC,OAAS;YACb,MAAM,aAAa,KAAK,KAAK;YAC7B,OAAO,OAAO,KAAK,cAAc,UAAU;QAC7C,GACC,MAAM,CAAC,CAAC,OAAS,SAAS,IAAI;QAEjC,WAAW,IAAI,GAAG,IAAI,CAAC,IAAI;QAC3B,OAAO;IACT;IAEA;;;GAGC,GACD,UAAmB;QACjB,OAAO,IAAI,CAAC,IAAI,KAAK,CAAA,GAAA,yCAAK,AAAD;IAC3B;IAEA;;;GAGC,GACD,WAAoB;QAClB,OAAO,IAAI,CAAC,IAAI,KAAK,CAAA,GAAA,yCAAM,AAAD;IAC5B;IAEA;;;;GAIC,GACD,aAAsB;QACpB,OAAO,IAAI,CAAC,kBAAkB;IAChC;IAEA,mBAAmB,SAA0C,IAAI,EAAE,SAAS,IAAI,EAAmB;QACjG,IAAI,kBAAkB,CAAA,GAAA,wCAAc,GAClC,IAAI,CAAC,sBAAsB,GAAG;aAE9B,IAAI,CAAC,sBAAsB,GAAG,IAAI,CAAA,GAAA,wCAAc,EAAE,UAAU,IAAI,UAAU;QAG5E,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,sBAAsB;QAC3C,OAAO,IAAI,CAAC,sBAAsB;IACpC;IAEA,wBAA8B;QAC5B,IAAI,CAAC,IAAI,CAAC,sBAAsB,EAC9B,IAAI,CAAC,kBAAkB;IAE3B;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,qBAAqB;QAC1B,IAAI,CAAC,sBAAsB,CAAC,MAAM,IAAI;IACxC;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,qBAAqB;QAC1B,IAAI,CAAC,sBAAsB,CAAC,MAAM,IAAI;IACxC;IAEA,OAAO,SAAuB,EAAE,QAAuB,IAAI,EAAO;QAChE,MAAM,MAAM,AAAC,qBAAqB,CAAA,GAAA,wCAAG,AAAD,IAAK,YAAY,IAAI,CAAA,GAAA,wCAAG,AAAD,EAAE,WAAW,MAAM;QAC9E,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,OAAO;IACT;IAEA,WAAW,OAAyB,EAAW;QAC7C,MAAM,UAAU,AAAC,mBAAmB,CAAA,GAAA,wCAAO,AAAD,IAAK,UAAU,IAAI,CAAA,GAAA,wCAAO,AAAD,EAAE,QAAQ;QAC7E,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,OAAO;IACT;IAEA,IAAI,UAA+C,EAAQ;QACzD,OAAO,IAAI,2BACT;YACE,MAAM,IAAI,CAAC,IAAI;YACf,OAAO,IAAI,CAAC,KAAK;YACjB,GAAG,UAAU;QACf;IAEJ;AACF;IAEA,2CAAe;;AD9Lf;AIAA;AAGA;;CAEC,GACD,MAAM;IACJ;;;;GAIC,GACD,QAAgB,EAAE,CAAC;IAEnB,QAAQ,IAAI,EAAQ;QAClB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;IAClB;IAEA;;;;GAIC,GACD,IAAI,OAAsD;QACxD,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS,KAAK,IAAI;QAChD,MAAM,cAAc;eAAI,IAAI,IAAI;SAAO;QAEvC,IAAI,YAAY,MAAM,KAAK,GACzB,OAAO,WAAW,CAAC,EAAE;QAGvB,OAAO,GAAA,yCAAa;IACtB;IAEA;;;;GAIC,GACD,qBAA8B;QAC5B,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAAS,KAAK,kBAAkB;IAC1D;AACF;IAEA,2CAAe;;;;;;AC5Cf;ACAA;AAgBA,MAAe;IAKb,IAAI,MAAc;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAG,AAAD;IAAI;IAExD,IAAI,QAAgB;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAK,AAAD;IAAI;IAE5D,IAAI,WAAmB;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAQ,AAAD;IAAI;IAElE,IAAI,OAAsC;QAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAA,GAAA,yCAAI,AAAD;IAAI;IAE3E,IAAI,WAAmB;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAQ,AAAD;IAAI;IAElE,IAAI,QAAgB;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAK,AAAD;IAAI;IAE5D,IAAI,OAAsC;QAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAA,GAAA,yCAAI,AAAD;IAAI;IAE3E,IAAI,OAAe;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAI,AAAD;IAAI;IAE1D,IAAI,QAAuC;QAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAA,GAAA,yCAAK,AAAD;IAAI;IAE7E,IAAI,YAAoB;QAAE,OAAO,IAAI,CAAC,iBAAiB,CAAC,CAAA,GAAA,yCAAS,AAAD;IAAI;IAEpE,IAAI,WAA0C;QAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAA,GAAA,yCAAQ,AAAD;IAAI;IAEnF,IAAI,SAAwC;QAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAA,GAAA,wCAAM,AAAD;IAAI;IAE/E,IAAI,WAA0C;QAAE,OAAO,IAAI,CAAC,WAAW,CAAC,CAAA,GAAA,yCAAQ,AAAD;IAAI;AACrF;IAEA,2CAAe;;;;ADtCf,SAAS,kCAAY,KAAe,EAAE,KAAa,EAAQ;IACzD,IAAI,CAAC,MAAM,QAAQ,CAAC,QAClB,MAAM,IAAI,CAAC;AAEf;AAEA;;;;;;;CAOC,GACD,MAAM,uCAAiB,CAAA,GAAA,wCAAiB,AAAD;IACrC,WAA8C,CAAC,EAAE;IAEjD,YAAY,WAA8C,CAAC,CAAC,CAAE;QAC5D,KAAK;QAEL,IAAI,UACF,IAAI,CAAC,MAAM,CAAC;IAEhB;IAEA,MAAM,QAA2C,EAAY;QAC3D,MAAM,QAAQ,IAAI,CAAC,KAAK;QACxB,MAAM,MAAM,CAAC;QACb,OAAO;IACT;IAEA,SAAS,GAAW,EAAW;QAC7B,OAAO,OAAO,IAAI,CAAC,QAAQ;IAC7B;IAEA,IAAI,GAAW,EAAE,KAAa,EAAQ;QACpC,IAAI,CAAA,GAAA,yCAAa,AAAD,EAAE,MAChB;QAGF,IAAI,CAAE,CAAA,OAAO,IAAI,CAAC,QAAQ,AAAD,GAAI;YAC3B,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG;YACrB;QACF,CAAC;QAED,MAAM,eAAe,IAAI,CAAC,QAAQ,CAAC,IAAI;QAEvC,IAAI,iBAAiB,OACnB;QAGF,IAAI,wBAAwB,OAAO;YACjC,kCAAY,cAAc;YAC1B;QACF,CAAC;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG;YAAC;YAAc;SAAM;IAC5C;IAEA,IAAI,GAAW,EAAE,KAAoB,EAAQ;QAC3C,IAAI,OACF,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG;aAErB,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI;IAE7B;IAEA,YAAY,IAAY,EAAiC;QACvD,OAAO,IAAI,CAAC,GAAG,CAAC;IAClB;IAEA,kBAAkB,IAAY,EAAU;QACtC,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB;IAEA;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,IAAI,IAAY,EAAiC;QAC/C,IAAI,SAAS,CAAA,GAAA,wCAAG,GACd,OAAO,IAAI,CAAC,oBAAoB;QAGlC,IAAI,QAAQ,IAAI,CAAC,QAAQ,EACvB,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK;QAG5B,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B;IAEA;;;;;;GAMC,GACD,UAAU,IAAY,EAAU;QAC9B,MAAM,QAAQ,IAAI,CAAC,GAAG,CAAC;QAEvB,IAAI,MAAM,OAAO,CAAC,QAChB,OAAO,KAAK,CAAC,EAAE;QAGjB,OAAO;IACT;IAEA,cAAc,IAAY,EAA2B;QACnD,MAAM,QAAQ,KAAK,KAAK,CAAC;QAEzB,IAAI,CAAC,OACH,OAAO,IAAI;QAGb,MAAM,MAAM,KAAK,CAAC,EAAE;QACpB,MAAM,QAAQ,SAAS,KAAK,CAAC,EAAE,EAAE;QACjC,OAAO;YAAC;YAAK;SAAM;IACrB;IAEA,aAAa,IAAY,EAAsB;QAC7C,MAAM,YAAY,IAAI,CAAC,aAAa,CAAC;QAErC,IAAI,cAAc,IAAI,EACpB,OAAO;QAGT,MAAM,CAAC,KAAK,MAAM,GAAG;QACrB,MAAM,aAAc,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAE;QAC5C,IAAI,YAAY;QAEhB,IAAI,YAAY,GACd,YAAY,WAAW,MAAM,GAAG;aAC3B,IAAI,YAAY,GACrB,aAAa;QAGf,OAAO,UAAU,CAAC,UAAU;IAC9B;IAEA;;;GAGC,GACD,QAAkB;QAChB,OAAO,IAAI,+BAAS,IAAI,CAAC,QAAQ;IACnC;IAEA,uBAA2C;QACzC,MAAM,OAAO,IAAI,CAAC,SAAS,CAAC,CAAA,GAAA,yCAAG;QAC/B,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,CAAA,GAAA,yCAAE;QAE7B,IAAI,QAAQ,KAAK;YACf,MAAM,QAAQ,CAAA,GAAA,wCAAK,AAAD,EAAE,KAAK,CAAC;YAE1B,IAAI,CAAC,OACH,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,EAAE;YAG5C,OAAO,MAAM,SAAS,CAAC,SAAS,MAAM,KAAK,QAAQ;QACrD,CAAC;QAED,OAAO;IACT;IAEQ,OAAO,QAA2C,EAAQ;QAChE,OACG,IAAI,CAAC,UACL,MAAM,CAAC,CAAC,MAAQ,CAAC,CAAA,GAAA,yCAAY,EAAE,MAC/B,OAAO,CAAC,CAAC,MAAQ;YAChB,MAAM,QAAQ,QAAQ,CAAC,IAAI;YAE3B,IAAI,iBAAiB,OACnB,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG;mBAAI;aAAM;iBAE/B,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG;QAEzB;IACJ;AACF;IAEA,2CAAe;;;AElNf;;CAEC,GACD,MAAM;IAQJ;;;;GAIC,GACD,aAA4B,IAAI,CAAC;IAEjC;;;;GAIC,GACD,SAAwB,IAAI,CAAC;IAE7B;;GAEC,GACD,YAAY,OAAe,EAAE,UAAyB,EAAE,MAAqB,CAAE;QAC7E,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA;;;GAGC,GACD,WAAmB;QACjB,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,UAAU,IAAI,IAAI,QAAQ,EAAE,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC;IAClG;AACF;IAEA,2CAAe;;;;AC3Cf;ACEA,MAAM;IAaJ,YAAY,QAAgB,EAAE,IAAU,CAAE;QACxC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG;IACd;IAEA,QAAQ;QACN,OAAO,IAAI,+BAAS,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,IAAI;IAC9C;IAEA,SAAS,UAAU,EAAY;QAC7B,OAAO,IAAI,+BAAS,AAAC,IAAI,CAAC,QAAQ,GAAG,aAAc,KAAK,IAAI,CAAC,IAAI;IACnE;IAEA;;;;;;;;;;;GAWC,GACD,WAAW;QACT,OAAO,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IACvC;IAEA,OAAO,MAAM,QAAgB,EAAE,MAAuB,EAAE;QACtD,MAAM,UAAU,SAAS,IAAI;QAC7B,MAAM,iBAAiB,WAAW;QAElC,IAAI,OAAO,KAAK,CAAC,iBACf,OAAO,IAAI,CAAC,eAAe,CAAC;QAG9B,IAAI,QAAQ,KAAK,CAAC,QAAQ,KACxB,OAAO,IAAI,CAAC,eAAe,CAAC,gBAAgB;QAG9C,OAAO,IAAI,+BAAS,gBAAgB;IACtC;IAEA,OAAO,gBAAgB,MAAuB,EAAE;QAC9C,IAAI,QACF,OAAO,OAAO,KAAK;QAGrB,OAAO,IAAI,+BAAS,KAAK;IAC3B;IAEA,OAAO,gBAAgB,cAAsB,EAAE,MAAuB,EAAE;QACtE,IAAI,QACF,OAAO,OAAO,QAAQ,CAAC;QAGzB,OAAO,IAAI,+BAAS,gBAAgB;IACtC;AACF;IAEA,2CAAe;;;;ADrEf,MAAM;IACJ,sBAAgD;QAC9C,CAAC,CAAA,GAAA,yCAAW,AAAD,EAAE,EAAE,EAAE;QACjB,CAAC,CAAA,GAAA,yCAAS,AAAD,EAAE,EAAE,EAAE;QACf,CAAC,CAAA,GAAA,yCAAU,AAAD,EAAE,EAAE,EAAE;QAChB,CAAC,CAAA,GAAA,yCAAQ,AAAD,EAAE,EAAE,EAAE;IAChB,EAAE;IAEF,aAAyC;QACvC,CAAC,CAAA,GAAA,yCAAS,AAAD,EAAE,EAAE,EAAE;QACf,CAAC,CAAA,GAAA,yCAAQ,AAAD,EAAE,EAAE,EAAE;IAChB,EAAE;IAEF,WAAiB,IAAI,CAAA,GAAA,wCAAG,IAAI;IAE5B,YAAkB,IAAI,CAAA,GAAA,wCAAG,IAAI;IAE7B,SAAS,GAAQ,EAAE;QACjB,OAAQ,IAAI,IAAI;YACd,KAAK,GAAA,yCAAQ;gBACX,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC;gBACvC,KAAM;YAER,KAAK,GAAA,yCAAQ;gBACX,IAAI,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBAC3C,KAAM;YAER,KAAK,GAAA,yCAAU;gBACb,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC;gBACzC,KAAM;YAER,KAAK,GAAA,yCAAS;gBACZ,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC,YAAY,CAAC;gBACxC,KAAM;YAER,KAAK,GAAA,yCAAS;gBACZ,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC;gBAC5C,KAAM;YAER,KAAK,GAAA,yCAAW;gBACd,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC;gBAC1C,KAAM;YAER;gBACE,KAAM;QACV;IACF;IAEQ,aAAa,GAAQ,EAAiB;QAC5C,IAAI,SAAE,MAAK,EAAE,GAA6B;QAE1C,IAAI,IAAI,QAAQ,IACd,IAAI,CAAC,mBAAmB,CAAC,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC;aACnC;YACL,IAAI,CAAC,mBAAmB,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG;YACtC,QAAQ,IAAI,CAAC,mBAAmB,CAAC,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI;QACjE,CAAC;QAED,OAAO;IACT;IAEQ,iBAAiB,GAAQ,EAAmB;QAClD,MAAM,SAAE,MAAK,EAAE,GAA6B;QAE5C,IAAI,IAAI,QAAQ,IAAI;YAClB,MAAM,SAA0B,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI;YAC9E,MAAM,iBAA2B,CAAA,GAAA,wCAAQ,AAAD,EAAE,KAAK,CAAC,OAAO;YACvD,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC;YAC/B,OAAO;QACT,CAAC;QAED,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG;QAC7B,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,IAAI,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI;IACvD;AACF;IAEA,2CAAe;;;;;AR7Cf;;CAEC,GACD,MAAM,mCAAa,CAAA,GAAA,wCAAiB,AAAD;IACjC;;;GAGC,GACD,QAAgB,EAAE,CAAC;IASnB,cAA2B,IAAI,CAAC;IAEhC,WAA4B,EAAE,CAAC;IAE/B,eAA6B,GAAA,yCAAI,EAAC;IAElC,YAAuB,IAAI,CAAA,GAAA,wCAAQ,IAAI;IAEvC,aAA4B,IAAI,CAAC;IAEjC,eAA8B,IAAI,CAAC;IAEnC,kBAAsC,IAAI,CAAC;IAE3C,aAA4B,IAAI,CAAC;IAEjC;;;GAGC,GACD,YAAY,WAAW,CAAC,CAAC,CAAE;QACzB,KAAK;QACL,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAA,GAAA,wCAAQ,AAAD,EAAE;IAC/B;IAEA,IAAI,eAA4B;QAC9B,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM;QAE/B,IAAI,SAAS,GACX,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;QAG9B,OAAO,IAAI;IACb;IAEA;;;;GAIC,GACD,IAAI,YAAoB;QACtB,IAAI,CAAC,IAAI,CAAC,UAAU,EAClB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK;QAGzD,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;;;;GAKC,GACD,IAAI,iBAA8B;QAChC,IAAI,CAAC,IAAI,CAAC,eAAe,EACvB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,qBAAqB,CAAC,IAAI,CAAC,UAAU;QAGnE,OAAO,IAAI,CAAC,eAAe;IAC7B;IAEA,sBAAsB,KAA8B,EAA2B;QAC7E,MAAM,OAAO;eAAI;SAAM;QAEvB,MAAO,KAAK,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,kBAAkB,GAC/C,KAAK,KAAK;QAGZ,OAAO;IACT;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,MAAM,2CAA2C;QAClF,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;IAC1B;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,UAAU;QACf,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,MAAM,2CAA2C;QAClF,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;IAC1B;IAEA,QAAQ,IAAW,EAAQ;QACzB,IAAI,MACF,IAAI,CAAC,WAAW,GAAG;aACd;YACL,IAAI,CAAC,WAAW,GAAG,IAAI,CAAA,GAAA,wCAAI,AAAD;YAC1B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW;QAClC,CAAC;QAED,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,WAAW;QAC1C,IAAI,CAAC,WAAW,CAAC,YAAY,GAAG,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,UAAU;QACpE,IAAI,CAAC,WAAW,CAAC,GAAG,GAAG,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAA,GAAA,yCAAG,AAAD;QACpE,IAAI,CAAC,WAAW,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;QAClD,OAAO,IAAI,CAAC,WAAW;IACzB;IAEQ,WAAW,IAAU,EAAU;QACrC,MAAM,gBAAgB,KAAK,KAAK,CAAC,OAAO,CAAC,CAAC,OAAe;YACvD,IAAI,gBAAgB,CAAA,GAAA,wCAAG,AAAD,KAAK,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAS,GAChD,OAAO,IAAI,CAAC,mBAAmB,CAAC,KAAK,UAAU;YAGjD,OAAO,EAAE;QACX;QAEA,OAAO;YAAC;eAAS;SAAc;IACjC;IAEQ,oBAAoB,UAAyB,EAAU;QAC7D,MAAM,QAAgB,EAAE;QAExB,IAAI,CAAC,YACH,OAAO;QAGT,IAAK,IAAI,IAAI,aAAa,GAAG,KAAK,GAAG,KAAK,EAAG;YAC3C,MAAM,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;YAE1B,IAAI,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAK,GAAG;gBACxB,MAAM,eAAe,IAAI,CAAC,8BAA8B,CAAC;gBAEzD,IAAI,CAAE,CAAA,KAAK,UAAU,MAAM,aAAa,OAAO,EAAC,GAC9C,MAAM,OAAO,CAAC;YAElB,OAAO,IAAI,MAAM,MAAM,GAAG,GACxB,KAAM;QAEV;QAEA,OAAO;IACT;IAEQ,+BAA+B,IAAU,EAAE;QACjD,OAAO,KAAK,QAAQ,CAAC,CAAC,OAAe;YACnC,IAAI,gBAAgB,CAAA,GAAA,wCAAE,GAAG;gBACvB,IAAI,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAc,KAAK,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAa,AAAD,GAC7D,OAAO,IAAI;YAEf,CAAC;YAED,OAAO;QACT;IACF;IAEA;;;GAGC,GACD,IAAI,aAA0B;QAC5B,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK;IAC1C;IAEA;;;GAGC,GACD,IAAI,yBAAsC;QACxC,OAAO,IAAI,CAAC,qBAAqB,CAC/B,IAAI,CAAC,iBAAiB,CACpB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,OAAe,IAAI,CAAC,UAAU,CAAC;IAGzD;IAEA,kBAAkB,KAAa,EAAE;QAC/B,IAAI,mBAAmB,IAAI,CAAA,GAAA,wCAAS,AAAD;QACnC,MAAM,aAAa;YAAC;SAAiB;QAErC,MAAM,OAAO,CAAC,CAAC,OAAS;YACtB,IAAI,KAAK,OAAO,IAAI;gBAClB,mBAAmB,IAAI,CAAA,GAAA,wCAAS,AAAD;gBAC/B,WAAW,IAAI,CAAC;YAClB,OAAO,IAAI,KAAK,kBAAkB,IAChC,iBAAiB,OAAO,CAAC;QAE7B;QAEA,OAAO;IACT;IAEA,qBAAqB,WAA0B,EAAQ;QACrD,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,MAAM,2CAA2C;QAElF,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG;QACxB,IAAI,CAAC,WAAW,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK;QACzD,IAAI,CAAC,WAAW,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,KAAK;IAC7D;IAEA,aAAmB;QACjB,IAAI,IAAI,CAAC,WAAW,KAAK,IAAI,EAC3B,IAAI,CAAC,OAAO;IAEhB;IAEA,OAAO,WAAyB,EAAO;QACrC,MAAM,MAAM,CAAA,GAAA,wCAAG,AAAD,EAAE,WAAW,CAAC;QAC5B,IAAI,CAAC,cAAc,CAAC;QACpB,IAAI,CAAC,cAAc,CAAC;QACpB,OAAO;IACT;IAEQ,eAAe,GAAQ,EAAE;QAC/B,IAAI,CAAC,UAAU;QACf,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,MAAM,2CAA2C;QAClF,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;IAC1B;IAEQ,eAAe,GAAQ,EAAE;QAC/B,IAAI,IAAI,SAAS,IACf,IAAI,CAAC,WAAW,CAAC,IAAI,IAAI,EAAE,IAAI,KAAK,IAAI;aACnC,IAAI,IAAI,IAAI,KAAK,CAAA,GAAA,yCAAQ,GAC9B,IAAI,CAAC,YAAY,GAAG,IAAI,KAAK;aACxB,IAAI,IAAI,IAAI,KAAK,CAAA,GAAA,yCAAM,GAC5B,IAAI,CAAC,UAAU,GAAG,IAAI,KAAK;aACtB,IAAI,IAAI,kBAAkB,IAC/B,IAAI,CAAC,qBAAqB,CAAC;aACtB,IAAI,IAAI,eAAe,IAC5B,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;IAE5B;IAEA,sBAAsB,GAAQ,EAAQ;QACpC,OAAQ,IAAI,IAAI;YACd,KAAK,GAAA,yCAAe;gBAClB,IAAI,CAAC,YAAY,CAAC,CAAA,GAAA,yCAAK,GAAG;gBAC1B,KAAM;YAER,KAAK,GAAA,yCAAa;gBAChB,IAAI,CAAC,UAAU,CAAC,CAAA,GAAA,yCAAK,GAAG;gBACxB,KAAM;YAER,KAAK,GAAA,yCAAY;gBACf,IAAI,CAAC,YAAY,CAAC,CAAA,GAAA,yCAAE,GAAG;gBACvB,KAAM;YAER,KAAK,GAAA,yCAAU;gBACb,IAAI,CAAC,UAAU,CAAC,CAAA,GAAA,yCAAE,GAAG;gBACrB,KAAM;YAER,KAAK,GAAA,yCAAc;gBACjB,IAAI,CAAC,YAAY,CAAC,CAAA,GAAA,yCAAI,GAAG;gBACzB,KAAM;YAER,KAAK,GAAA,yCAAY;gBACf,IAAI,CAAC,UAAU,CAAC,CAAA,GAAA,yCAAI,GAAG;gBACvB,KAAM;YAER;gBACE,KAAM;QACV;IACF;IAEA,aAAa,WAA0B,EAAE,GAAQ,EAAQ;QACvD,IAAI,CAAC,uBAAuB,CAAC,CAAA,GAAA,yCAAG,GAAG;QACnC,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,oBAAoB,CAAC;IAC5B;IAEA,WAAW,WAA0B,EAAE,GAAQ,EAAQ;QACrD,IAAI,CAAC,uBAAuB,CAAC,aAAa;QAC1C,IAAI,CAAC,WAAW,GAAG,CAAA,GAAA,yCAAI,AAAD;IACxB;IAEA,wBAAwB,WAA0B,EAAE,GAAQ,EAAQ;QAClE,IAAI,IAAI,CAAC,WAAW,KAAK,aACvB,IAAI,CAAC,UAAU,CAAC,CAAC,gBAAgB,EAAE,IAAI,YAAY,CAAC,sBAAsB,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,EAAE;IAEpG;IAEA,WAAW,OAAe,EAAE,QAAE,KAAI,UAAE,OAAM,EAAa,EAAQ;QAC7D,MAAM,UAAU,IAAI,CAAA,GAAA,wCAAY,EAAE,SAAS,QAAQ,IAAI,EAAE,UAAU,IAAI;QACvE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;IACrB;IAEA,QAAQ,IAAU,EAAQ;QACxB,IAAI,gBAAgB,CAAA,GAAA,wCAAE,GACpB,IAAI,CAAC,MAAM,CAAC;aACP;YACL,IAAI,CAAC,UAAU;YACf,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,MAAM,IAAI,MAAM,2CAA2C;YAClF,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC;QAC3B,CAAC;IACH;IAEA;;;GAGC,GACD,QAAc;QACZ,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAS;IACjC;IAEA,YAAY,IAAY,EAAE,KAAa,EAAQ;QAC7C,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM;IAC1B;IAEA;;;;GAIC,GACD,IAAI,WAAqB;QACvB,CAAA,GAAA,yCAAS,AAAD,EAAE;QACV,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA,YAAY,IAAY,EAAiC;QACvD,OAAO,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC;IACnC;IAEA,kBAAkB,IAAY,EAAU;QACtC,OAAO,IAAI,CAAC,QAAQ,CAAC,iBAAiB,CAAC;IACzC;IAEA;;;;;;;;GAQC,GACD,OAAO,GAA2B,EAAQ;QACxC,MAAM,SAAS,MAAM,IAAI,QAAQ,KAAK,IAAI;QAC1C,OAAO,IAAI,CAAC,cAAc,CAAC,CAAA,GAAA,yCAAG,AAAD,GAAG;IAClC;IAEA;;;;;;;;GAQC,GACD,QAAQ,IAAmB,EAAQ;QACjC,MAAM,UAAU,OAAO,KAAK,QAAQ,KAAK,IAAI;QAC7C,OAAO,IAAI,CAAC,cAAc,CAAC,CAAA,GAAA,yCAAI,AAAD,GAAG;IACnC;IAEQ,aAAa,IAAY,EAAE,KAAoB,EAAQ;QAC7D,IAAI,UAAU,IAAI,EAChB,OAAO,IAAI,CAAC,UAAU,CAAC,CAAC,OAAe,gBAAgB,CAAA,GAAA,wCAAE,KAAK,KAAK,IAAI,KAAK;QAG9E,OAAO,IAAI,CAAC,UAAU,CACpB,CAAC,OAAe,gBAAgB,CAAA,GAAA,wCAAE,KAAK,KAAK,IAAI,KAAK,MACrD,CAAC,OAAgB,AAAC,SAAS,OAAQ,KAAK,GAAG,CAAC;uBAAE;YAAM,KAAK,IAAI,EAC7D,CAAC,OAAe,KAAK,eAAe,CAAC,MAAM;IAE/C;IAEA;;;;;;;;;GASC,GACD,UAAU,KAAa,EAAE,wBAAE,uBAAuB,KAAK,GAAE,GAAG,CAAC,CAAC,EAAQ;QACpE,MAAM,aAAa,CAAA,GAAA,wCAAE,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG;QACpC,IAAI,gBAA4B,IAAI;QACpC,IAAI,OAAQ,IAAI;QAEhB,IAAI,YAAY;YACd,gBAAgB,WAAW,SAAS,CAAC;YACrC,OAAO,KAAK,MAAM,CAAC,cAAc,QAAQ;QAC3C,CAAC;QAED,OAAO,KAAK,QAAQ,CAAC,CAAC,OAAS;YAC7B,IAAI,gBAAgB,CAAA,GAAA,wCAAe,AAAD,GAChC,OAAO,AAAC,KAAyB,SAAS,CAAC,OAAO,eAAe;sCAAE;YAAqB;YAG1F,OAAO;QACT;IACF;IAEA;;;;;;;;GAQC,GACD,YAAY,wBAAE,uBAAuB,KAAK,GAAE,GAAG,CAAC,CAAC,EAAQ;QACvD,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG;kCAAE;QAAqB;IAClD;IAEA;;;;;;;;GAQC,GACD,cAAc,wBAAE,uBAAuB,KAAK,GAAE,GAAG,CAAC,CAAC,EAAQ;QACzD,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI;kCAAE;QAAqB;IACnD;IAEA;;;;;;;GAOC,GACD,UAAU,MAAoB,EAAQ;QACpC,MAAM,YAAY,IAAI,CAAC,oBAAoB,CAAC;QAE5C,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAS;YAC1C,IAAI,gBAAgB,CAAA,GAAA,wCAAG,AAAD,KAAK,KAAK,IAAI,KAAK,CAAA,GAAA,yCAAG,AAAD,GACzC,OAAO,KAAK,GAAG,CAAC;gBAAE,OAAO,OAAO,QAAQ;YAAG;YAG7C,IAAI,gBAAgB,CAAA,GAAA,wCAAc,GAChC,OAAO,KAAK,SAAS,CAAC,WAAW;YAGnC,OAAO;QACT;QAEA,IAAI,CAAC,MAAM,CAAC,OAAO,QAAQ;QAC3B,OAAO;IACT;IAEA,qBAAqB,MAAoB,EAAU;QACjD,MAAM,aAAa,CAAA,GAAA,wCAAE,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG;QAEpC,IAAI,CAAC,YACH,MAAM,IAAI,MAAM,CAAC;;;;;;;uBAOA,CAAC,CAAC,SAAS,CAAC,IAAI;QAGnC,OAAO,WAAW,UAAU,CAAC;IAC/B;IAEA;;;;;;;GAOC,GACD,eAAe,IAAY,EAAE,KAAoB,EAAQ;QACvD,MAAM,cAAc,IAAI,CAAC,YAAY,CAAC,MAAM;QAC5C,YAAY,QAAQ,CAAC,GAAG,CAAC,MAAM;QAC/B,OAAO;IACT;IAEQ,gBAAgB,IAAY,EAAE,KAAa,EAAE,SAAE,QAAQ,IAAI,GAAE,GAAG,CAAC,CAAC,EAAQ;QAChF,MAAM,cAAc,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,OACxC,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,OACf,CAAE,CAAA,gBAAgB,CAAA,GAAA,wCAAG,AAAD,CAAA,KAAO,SAAS,gBAAgB,CAAA,GAAA,wCAAG,AAAD,KAAK,KAAK,IAAI,KAAK;QAI7E,MAAM,UAAU,IAAI,CAAA,GAAA,wCAAI,AAAD;QACvB,QAAQ,MAAM,CAAC,MAAM;QAErB,MAAM,aAAa,IAAI,CAAC,KAAK;QAC7B,MAAM,SAAE,MAAK,EAAE,GAAG;QAClB,WAAW,KAAK,GAAG;eAAI,MAAM,KAAK,CAAC,GAAG;YAAc;eAAY,MAAM,KAAK,CAAC;SAAa;QAEzF,OAAO;IACT;IAEA;;;;;;;;;;;;;GAaC,GACD,SAAS,IAAsB,EAAQ;QACrC,MAAM,aAAa,IAAI;QAEvB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,OAAS;YAC3B,WAAW,OAAO;YAElB,KAAK,KAAK,CAAC,OAAO,CAAC,CAAC,OAAS;gBAC3B,MAAM,cAAc,KAAK;gBAEzB,IAAI,aACF,WAAW,OAAO,CAAC;YAEvB;QACF;QAEA,OAAO;IACT;IAEA;;;;;;;;;;;;;GAaC,GACD,SAAS,IAAsB,EAAQ;QACrC,MAAM,aAAa,IAAI;QAEvB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,OAAS;YAC3B,MAAM,cAAc,KAAK;YAEzB,IAAI,aAAa;gBACf,WAAW,OAAO;gBAClB,YAAY,KAAK,CAAC,OAAO,CAAC,CAAC,OAAS,WAAW,OAAO,CAAC;YACzD,CAAC;QACH;QAEA,OAAO;IACT;IAEQ,WACN,YAAsC,EACtC,cAAqC,EACrC,gBAAuC,EACjC;QACN,IAAI,QAAQ,KAAK;QAEjB,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAS;YAC1C,IAAI,aAAa,OAAO;gBACtB,QAAQ,IAAI;gBACZ,OAAO,eAAe;YACxB,CAAC;YAED,OAAO;QACT;QAEA,IAAI,CAAC,OACH,OAAO,iBAAiB;QAG1B,OAAO;IACT;IAEQ,WAAW,QAAkC,EAAQ;QAC3D,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAS;YAC7B,MAAM,SAAE,MAAK,EAAE,GAAG;YAClB,MAAM,QAAQ,MAAM,SAAS,CAAC;YAE9B,IAAI,UAAU,IACZ,OAAO;YAGT,IAAI,MAAM,MAAM,KAAK,GACnB,OAAO,IAAI;YAGb,OAAO,KAAK,GAAG,CAAC;gBACd,OAAO;uBAAI,MAAM,KAAK,CAAC,GAAG;uBAAW,MAAM,KAAK,CAAC,QAAQ;iBAAG;YAC9D;QACF;IACF;AACF;IAEA,2CAAe;;;;;;;;ADxnBf,MAAM,oCAAc;AACpB,MAAM,0CAAoB;AAC1B,MAAM,4BAAM;AACZ,MAAM,gCAAU;AAChB,MAAM,gCAAU;AAChB,MAAM,6BAAO;AAuEb;;CAEC,GACD,MAAM;IACJ,OAAa,IAAI,CAAA,GAAA,wCAAG,IAAI;IAExB;;;;GAIC,GACD,UAAU,IAAU,EAAkB;QACpC,OAAO;YACL,MAAM;YACN,OAAO,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,aAAa,CAAC;QACrD;IACF;IAEA,cAAc,IAAU,EAAkB;QACxC,OAAO;YACL,MAAM;YACN,OAAO,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,aAAa,CAAC;QACrD;IACF;IAEA,cAAc,IAAa,EAAuB;QAChD,IAAI,gBAAgB,CAAA,GAAA,wCAAE,GACpB,OAAO,IAAI,CAAC,YAAY,CAAC;QAG3B,IAAI,gBAAgB,CAAA,GAAA,wCAAc,GAChC,OAAO,IAAI,CAAC,wBAAwB,CAAC;QAGvC,IAAI,gBAAgB,CAAA,GAAA,wCAAM,GACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;QAG/B,IAAI,gBAAgB,CAAA,GAAA,wCAAM,GACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;QAG/B,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;IAC1E;IAEA,aAAa,GAAQ,EAAiB;QACpC,OAAO;YACL,MAAM;YACN,MAAM,IAAI,YAAY;YACtB,OAAO,IAAI,KAAK;QAClB;IACF;IAEA,yBAAyB,eAAgC,EAAE;QACzD,OAAO;YACL,MAAM;YACN,QAAQ,gBAAgB,MAAM;YAC9B,OAAO,IAAI;YACX,QAAQ,gBAAgB,MAAM;QAChC;IACF;IAEA,iBAAiB,OAAgB,EAAU;QACzC,OAAO;YACL,MAAM;YACN,UAAU,QAAQ,QAAQ;YAC1B,WAAW,QAAQ,SAAS;YAC5B,gBAAgB,IAAI,CAAC,mBAAmB,CAAC,QAAQ,cAAc;YAC/D,iBAAiB,IAAI,CAAC,mBAAmB,CAAC,QAAQ,eAAe;QACnE;IACF;IAEA,iBAAiB,OAAgB,EAAE;QACjC,OAAO,QAAQ,MAAM;IACvB;IAEA,oBAAoB,UAAqB,EAAE;QACzC,OAAO,WAAW,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,aAAa,CAAC;IACrD;IAEA;;;;GAIC,GACD,YAAY,cAA8B,EAAQ;QAChD,IAAI,CAAC,iBAAiB,CAAC;QACvB,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA,kBAAkB,YAAiC,EAA8D;QAC/G,IAAI,CAAC,cACH,OAAO,IAAI;QAGb,IAAI,OAAO,iBAAiB,UAC1B,OAAO,IAAI,CAAA,GAAA,wCAAO,AAAD,EAAE;QAGrB,MAAM,QAAE,KAAI,EAAE,GAAG;QAEjB,OAAQ;YACN,KAAK;gBACH,IAAI,CAAC,eAAe,CAAC;gBACrB,KAAM;YACR,KAAK;gBACH,OAAO,IAAI,CAAC,oBAAoB,CAAC;YACnC,KAAK;gBACH,OAAO,IAAI,CAAC,QAAQ,CAAC;YACvB,KAAK;gBACH,OAAO,IAAI,CAAC,YAAY,CAAC;YAC3B,KAAK;gBACH,OAAO,IAAI,CAAC,YAAY,CAAC;YAC3B;gBACE,QAAQ,IAAI,CAAC,CAAC,yBAAyB,EAAE,KAAK,CAAC,CAAC,EAAE;QACtD;QAEA,OAAO,IAAI;IACb;IAEA,gBAAgB,YAA4B,EAAQ;QAClD,MAAM,SAAE,MAAK,EAAE,GAAG;QAClB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA,GAAA,wCAAI,AAAD;QACnB,MAAM,OAAO,CAAC,CAAC,OAAS,IAAI,CAAC,SAAS,CAAC;IACzC;IAEA,UAAU,YAA4B,EAAQ;QAC5C,MAAM,SAAE,MAAK,EAAE,GAAG;QAClB,IAAI,CAAC,IAAI,CAAC,OAAO;QAEjB,MAAM,OAAO,CAAC,CAAC,OAAS;YACtB,MAAM,aAAa,IAAI,CAAC,iBAAiB,CAAC;YAC1C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;QACpB;IACF;IAEA,qBAAqB,YAAuC,EAAmB;QAC7E,MAAM,SAAE,MAAK,UAAE,OAAM,UAAE,OAAM,EAAE,GAAG;QAElC,OAAO,IAAI,CAAA,GAAA,wCAAe,AAAD,EACvB,QAAQ,IAAI,CAAA,GAAA,wCAAI,EAAE,OAAO,QAAQ,KAAK,MAAM,EAC5C;IAEJ;IAEA,SAAS,YAA2B,EAAO;QACzC,MAAM,QACJ,KAAI,SACJ,MAAK,EACL,UAAU,UAAE,SAAS,IAAI,SAAE,OAAO,IAAI,WAAE,SAAS,IAAI,GAAE,GAAG,CAAC,CAAC,CAAA,EAC7D,GAAG;QACJ,OAAO,IAAI,CAAA,GAAA,wCAAG,AAAD,EAAE,MAAM,OAAO;kBAAE;oBAAM;oBAAQ;QAAO;IACrD;IAEA,aAAa,YAA+B,EAAW;QACrD,MAAM,WAAE,QAAO,EAAE,GAAG;QACpB,OAAO,IAAI,CAAA,GAAA,wCAAM,EAAE;IACrB;IAEA,aAAa,YAA+B,EAAW;QACrD,MAAM,YACJ,SAAQ,aACR,UAAS,kBACT,eAAc,mBACd,gBAAe,EACf,UAAU,UAAE,SAAS,IAAI,SAAE,OAAO,IAAI,WAAE,SAAS,IAAI,GAAE,GAAG,CAAC,CAAC,CAAA,EAC7D,GAAG;QAEJ,OAAO,IAAI,CAAA,GAAA,wCAAM,EAAE;sBACjB;uBACA;YACA,gBAAgB,IAAI,CAAC,eAAe,CAAC;YACrC,iBAAiB,IAAI,CAAC,eAAe,CAAC;oBACtC;kBACA;oBACA;QACF;IACF;IAEA,gBAAgB,UAAwD,EAAyB;QAC/F,OAAO,AAAC,CAAA,cAAc,EAAE,AAAD,EACpB,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,iBAAiB,CAAC,OACrC,MAAM,CAAC,CAAC,OAAS,SAAS,IAAI;IACnC;AACF;IAEA,2CAAe;;;;ADrQf;;CAEC,GACD,MAAM;IACJ,OAAa,IAAI,CAAA,GAAA,wCAAG,IAAI;IAExB;;;;GAIC,GACD,IAAI,WAA4B;QAC9B,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ;IAC3B;IAEU,gBAAgB,UAAkB,EAAE,MAAqB,EAAQ;QACzE,MAAM,MAAM,OAAO,CAAA,GAAA,yCAAmB,EAAE;QACxC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA,GAAA,wCAAoB,AAAD,IAAI,WAAW,CAAC;QACnD,OAAO,IAAI,CAAC,IAAI;IAClB;AACF;IAEA,2CAAe;;ADpCf;AaCA,0DAA0D;AAC1D,EAAE;AACF,gEAAgE;AAEhE;AA4CA,SAAS,iCAAW,GAAW,EAAE,YAAoB,EAAE,SAAiB,EAAE;IACxE,YAAY,aAAa;IACzB,IAAI,IAAI,MAAM,GAAG,cACf,OAAO;IAET,gBAAgB,IAAI,MAAM;IAC1B,aAAa,UAAU,MAAM,CAAC;IAC9B,OAAO,MAAM,UAAU,KAAK,CAAC,GAAG;AAClC;AAEO,MAAM,kDAAyB;IACpC,OAAc,aAAa,QAAuB,EAAE,KAAoB,EAAE;QACxE,SAAS,IAAI,EAAU,EAAU;YAC/B,OAAO,GAAG,UAAU,CAAC,GAAG,QAAQ,CAAC,IAAI,WAAW;QAClD;QAEA,SAAS,cAAc,CAAS,EAAU;YACxC,OAAO,EACJ,OAAO,CAAC,OAAO,QACf,OAAO,CAAC,MAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,gBAA2B,CAAC,KAAO,SAAS,IAAI,KACxD,OAAO,CAAC,yBAAyB,CAAC,KAAO,QAAS,IAAI;QAC3D;QAEA,SAAS,YAAY,CAAS,EAAU;YACtC,OAAO,EACJ,OAAO,CAAC,OAAO,QACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,MAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,gBAA2B,CAAC,KAAO,SAAS,IAAI,KACxD,OAAO,CAAC,yBAAyB,CAAC,KAAO,QAAS,IAAI;QAC3D;QAEA,SAAS,oBAAoB,WAAwB,EAAE;YACrD,OAAQ,YAAY,IAAI;gBACtB,KAAK;oBACH,OAAO,MAAO,cAAc,YAAY,IAAI,IAAI;gBAClD,KAAK;oBACH,MAAM,eAAe,YAAY,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS;wBACnD,OAAO,MAAM,OAAO,CAAC,QACjB,YAAY,IAAI,CAAC,EAAE,IAAc,MAAM,YAAY,IAAI,CAAC,EAAE,IAC1D,YAAY,KAAK;oBACvB;oBAEA,OAAO,MAAO,CAAA,YAAY,QAAQ,GAAG,MAAM,EAAE,AAAD,IAAK,eAAe;gBAClE,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO,YAAY,WAAW;YAClC;QACF;QAEA,SAAS,iBAAiB,SAAwB,EAAE;YAClD,MAAM,eAAe,UAAU,GAAG,CAAC;YACnC,IAAI;YACJ,IAAI;YAEJ,aAAa,IAAI;YAEjB,IAAI,aAAa,MAAM,GAAG,GAAG;gBAC3B,IAAK,IAAI,GAAG,IAAI,CAAC,EAAE,IAAI,aAAa,MAAM,EAAE,IAC1C,IAAI,YAAY,CAAC,IAAI,EAAE,KAAK,YAAY,CAAC,EAAE,EAAE;oBAC3C,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE;oBACjC;gBACF,CAAC;gBAEH,aAAa,MAAM,GAAG;YACxB,CAAC;YAED,OAAQ,aAAa,MAAM;gBACzB,KAAK;oBACH,OAAO,YAAY,CAAC,EAAE;gBAExB,KAAK;oBACH,OAAO,YAAY,CAAC,EAAE,GAAG,SAAS,YAAY,CAAC,EAAE;gBAEnD;oBACE,OAAO,aAAa,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,QAClC,UACA,YAAY,CAAC,aAAa,MAAM,GAAG,EAAE;YAC7C;QACF;QAEA,SAAS,cAAc,MAAqB,EAAE;YAC5C,OAAO,SAAS,MAAO,cAAc,UAAU,MAAO,cAAc;QACtE;QAEA,OAAO,cAAc,iBAAiB,YAAY,UAAU,cAAc,SAAS;IACrF;IAQA,YAAY,OAAe,EAAE,QAAuB,EAAE,KAAoB,EAAE,QAAmB,CAAE;QAC/F,KAAK;QACL,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG;QAEZ,IAAI,OAAO,AAAC,OAAe,cAAc,KAAK,YAC5C,AAAC,OAAe,cAAc,CAAC,IAAI,EAAE,0CAAiB,SAAS;aAE/D,AAAC,IAAI,CAAS,SAAS,GAAG,0CAAiB,SAAS;QAEtD,IAAI,OAAO,AAAC,MAAc,iBAAiB,KAAK,YAC9C,AAAC,MAAc,iBAAiB,CAAC,IAAI,EAAE;IAE3C;IAEA,OAAO,OAAmD,EAAU;QAClE,IAAI,MAAM,YAAY,IAAI,CAAC,OAAO;QAClC,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,MAAuB,IAAI;YAC/B,IAAI;YACJ,IAAK,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAC9B,IAAI,OAAO,CAAC,EAAE,CAAC,aAAa,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;gBACrD,MAAM,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAM;YACR,CAAC;YAEH,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK;YAC3B,IAAI,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,EAAE,IAAI,GAAG,MAAM,EAAE,MAAM;YAC9D,IAAI,KAAK;gBACP,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG;gBACzB,IAAI,SAAS,iCAAW,IAAI,EAAE,IAAI,CAAC,QAAQ,GAAG,MAAM,EAAE;gBACtD,IAAI,OAAO,GAAG,CAAC,EAAE,IAAI,GAAG,EAAE;gBAC1B,IAAI,OAAO,EAAE,IAAI,KAAK,EAAE,IAAI,GAAG,EAAE,MAAM,GAAG,KAAK,MAAM,GAAG,CAAC;gBACzD,OAAO,YAAY,MAAM,OAAO,SAAS,SAAS,EAAE,IAAI,GAAG,QAAQ,OAAO,OAAO,SAAS,QACxF,iCAAW,IAAI,EAAE,MAAM,GAAG,GAAG,OAC7B,iCAAW,IAAI,OAAO,EAAE,MAAM,EAAE;YACpC,OACE,OAAO,WAAW;QAEtB,CAAC;QACD,OAAO;IACT;AACF;AAEA,SAAS,gCAAU,KAAa,EAAE,OAAsB,EAAE;IACxD,UAAU,YAAY,YAAY,UAAU,CAAC,CAAC;IAE9C,MAAM,aAA4B,CAAC;IACnC,MAAM,aAAa,QAAQ,aAAa;IAExC,MAAM,yBAA8C;QAAE,YAAY;IAAoB;IACtF,IAAI,wBAAmC;IAEvC,MAAM,SAAS,SAAS,KAAU,EAAE,IAAS,EAAO;QAC9C,OAAO;YACL,MAAM;YACN,OAAO;mBAAI;gBAAO;aAAK;QACzB;IACF;IACJ,MAAM,SAAS,SAAS,IAAS,EAAO;QAClC,OAAO;IACT;IACJ,MAAM,SAAS,SAAS,MAAW,EAAE,MAAW,EAAE,MAAW,EAAE,OAAY,EAAO;QAC5E,OAAO;YACL,MAAM;YACN,OAAO;gBACL,SAAS;oBAAE,MAAM;oBAAmB,QAAQ;4BAAI;gBAAO,IAAI,IAAI;mBAC5D;gBACH,SAAS;oBAAE,MAAM;4BAAmB;oBAAQ,QAAQ;gBAAG,IAAI,IAAI;gBAC/D,UAAU;oBAAE,MAAM;6BAAW;gBAAQ,IAAI,IAAI;aAC9C,CAAC,MAAM,CAAC,CAAA,IAAK;QAChB;IACF;IACJ,MAAM,SAAS,SAAS,MAAW,EAAO;QACpC,OAAO;YAAE,MAAM;YAAmB,QAAQ;oBAAI;QAAO;IACvD;IACJ,MAAM,SAAS;IACf,MAAM,SAAS,uBAAuB,KAAK,KAAK;IAChD,MAAM,SAAS;IACf,MAAM,SAAS,qBAAqB;QAAC;QAAM;KAAK,EAAE,IAAI,EAAE,KAAK;IAC7D,MAAM,SAAS,SAAS,OAAY,EAAO;QACrC,OAAO;IACT;IACJ,MAAM,SAAS,SAAS,MAAW,EAAE,MAAW,EAAE,KAAU,EAAO;QAC7D,OAAO;YACL,MAAM;YACN,QAAQ,UAAU;YAClB,QAAQ,SAAU,CAAA,SAAS,EAAC;QAC9B;IACF;IACJ,MAAM,UAAU,SAAS,MAAW,EAAO;QACrC,OAAO,OAAO,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,IAAI,GAAG,IAAI,CAAC;IAC3C;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,MAAW,EAAO;QACrC,OAAO,OAAO,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,IAAI,GAAG,IAAI,CAAC;IAC3C;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAK;QAAM;KAAK,EAAE,IAAI,EAAE,KAAK;IACnE,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAK;IAAG;IACvE,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAK;IAAG;IACvE,MAAM,UAAU,SAAS,QAAa,EAAO;QACvC,OAAO;IACT;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,YAAiB,EAAE,SAAc,EAAE,WAAgB,EAAO;QAC7E,OAAO;YACL,MAAM;YACN,UAAU,aAAa,MAAM,GAAG,IAAI,eAAe,IAAI;uBACvD;YACA,GAAG,WAAW;YACd,UAAU,WAAW,KAAK;QAC5B;IACF;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,SAAc,EAAO;QACxC,OAAO;IACT;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,cAAmB,EAAE,eAAoB,EAAO;QACnE,OAAO;YACL,MAAM;4BACN;6BACA;YACA,UAAU,WAAW,KAAK;QAC5B;IACF;IACJ,MAAM,UAAU,SAAS,eAAoB,EAAO;QAC9C,OAAO;IACT;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;QAAK;KAAI,EAAE,KAAK,EAAE,KAAK;IACjG,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAK;QAAK;QAAK;QAAM;QAAK;QAAK;QAAK;QAAK;QAAM;QAAM;QAAM;KAAI,EAAE,IAAI,EAAE,KAAK;IAClH,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU,WAAgB;QAAE,OAAO;YAAE,MAAM;YAAQ,MAAM;QAAO;IAAG;IACzE,MAAM,UAAU,SAAS,OAAY,EAAE,iBAAsB,EAAO;QAC9D,OAAO;YACL,MAAM;YACN,MAAM;YACN,OAAO;YACP,UAAU,WAAW,KAAK;QAC5B;IACF;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,QAAa,EAAO;QACvC,OAAO,SAAS,GAAG,CAAC,CAAA,IAAK,EAAE,IAAI,IAAI,GAAG,IAAI,CAAC;IAC7C;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;QAAK;KAAI,EAAE,KAAK,EAAE,KAAK;IACrF,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAK;QAAM;QAAM;KAAK,EAAE,IAAI,EAAE,KAAK;IACzE,MAAM,UAAU,qBAAqB;IACrC,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAK;QAAM;QAAM;KAAK,EAAE,KAAK,EAAE,KAAK;IAC1E,MAAM,UAAU,qBAAqB;IACrC,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAK;KAAK,EAAE,KAAK,EAAE,KAAK;IAC9D,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAElD,IAAI,cAAc;IAClB,IAAI,eAAe;IACnB,MAAM,sBAAsB;QAAC;YAAE,MAAM;YAAG,QAAQ;QAAE;KAAE;IACpD,IAAI,iBAAiB;IACrB,IAAI,sBAAqC,EAAE;IAC3C,IAAI,kBAAkB;IAEtB,IAAI;IAEJ,IAAI,QAAQ,SAAS,KAAK,WAAW;QACnC,IAAI,CAAE,CAAA,QAAQ,SAAS,IAAI,sBAAqB,GAC9C,MAAM,IAAI,MAAM,qCAAqC,QAAQ,SAAS,GAAG,MAAO;QAGlF,wBAAwB,sBAAsB,CAAC,QAAQ,SAAS,CAAC;IACnE,CAAC;IAED,SAAS,OAAe;QACtB,OAAO,MAAM,SAAS,CAAC,cAAc;IACvC;IAEA,SAAS,WAAsB;QAC7B,OAAO,oBAAoB,cAAc;IAC3C;IAEA,SAAS,SAAS,WAAmB,EAAE,SAAqB,EAAE;QAC5D,YAAY,cAAc,YACtB,YACA,oBAAoB,cAAc,YAAY;QAElD,MAAM,yBACJ;YAAC,qBAAqB;SAAa,EACnC,MAAM,SAAS,CAAC,cAAc,cAC9B,WACA;IACJ;IAEA,SAAS,MAAM,OAAe,EAAE,SAAqB,EAAE;QACrD,YAAY,cAAc,YACtB,YACA,oBAAoB,cAAc,YAAY;QAElD,MAAM,qBAAqB,SAAS,WAAW;IACjD;IAEA,SAAS,uBAAuB,KAAa,EAAE,UAAmB,EAAsB;QACtF,OAAO;YAAE,MAAM;YAAW,MAAM;YAAO,YAAY;QAAW;IAChE;IAEA,SAAS,qBAAqB,KAAiB,EAAE,QAAiB,EAAE,UAAmB,EAAoB;QACzG,OAAO;YAAE,MAAM;YAAS,OAAO;YAAO,UAAU;YAAU,YAAY;QAAW;IACnF;IAEA,SAAS,qBAAqC;QAC5C,OAAO;YAAE,MAAM;QAAM;IACvB;IAEA,SAAS,qBAAqC;QAC5C,OAAO;YAAE,MAAM;QAAM;IACvB;IAEA,SAAS,qBAAqB,WAAmB,EAAoB;QACnE,OAAO;YAAE,MAAM;YAAS,aAAa;QAAY;IACnD;IAEA,SAAS,sBAAsB,GAAW,EAAE;QAC1C,IAAI,UAAU,mBAAmB,CAAC,IAAI;QACtC,IAAI;QAEJ,IAAI,SACF,OAAO;aACF;YACL,IAAI,MAAM;YACV,MAAO,CAAC,mBAAmB,CAAC,EAAE,CAC5B;YAGF,UAAU,mBAAmB,CAAC,EAAE;YAChC,UAAU;gBACR,MAAM,QAAQ,IAAI;gBAClB,QAAQ,QAAQ,MAAM;YACxB;YAEA,MAAO,IAAI,IAAK;gBACd,IAAI,MAAM,UAAU,CAAC,OAAO,IAAI;oBAC9B,QAAQ,IAAI;oBACZ,QAAQ,MAAM,GAAG;gBACnB,OACE,QAAQ,MAAM;gBAGhB;YACF;YAEA,mBAAmB,CAAC,IAAI,GAAG;YAE3B,OAAO;QACT,CAAC;IACH;IAEA,SAAS,oBAAoB,QAAgB,EAAE,MAAc,EAAa;QACxE,MAAM,kBAAkB,sBAAsB;QAC9C,MAAM,gBAAgB,sBAAsB;QAE5C,OAAO;YACL,QAAQ;YACR,OAAO;gBACL,QAAQ;gBACR,MAAM,gBAAgB,IAAI;gBAC1B,QAAQ,gBAAgB,MAAM;YAChC;YACA,KAAK;gBACH,QAAQ;gBACR,MAAM,cAAc,IAAI;gBACxB,QAAQ,cAAc,MAAM;YAC9B;QACF;IACF;IAEA,SAAS,SAAS,SAAsB,EAAE;QACxC,IAAI,cAAc,gBAAkB;QAEpC,IAAI,cAAc,gBAAgB;YAChC,iBAAiB;YACjB,sBAAsB,EAAE;QAC1B,CAAC;QAED,oBAAoB,IAAI,CAAC;IAC3B;IAEA,SAAS,qBAAqB,OAAe,EAAE,SAAoB,EAAE;QACnE,OAAO,IAAI,0CAAiB,SAAS,EAAE,EAAE,IAAI;IAC/C;IAEA,SAAS,yBAAyB,SAAwB,EAAE,KAAoB,EAAE,SAAoB,EAAE;QACtG,OAAO,IAAI,0CACT,0CAAiB,YAAY,CAAC,WAAW,QACzC,WACA,OACA;IAEJ;IAEA,SAAS,sBAA2B;QAClC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;QACA,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK,IAAI;YAEX,IAAI,OAAc,YAAY;gBAC5B,eAAe;gBACf,KAAK,OAAO,IAAI;gBAChB,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,2BAAgC;QACvC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,eAAe;gBACf,KAAK,OAAO;gBACZ,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,gBAAqB;QAC5B,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAE5B,KAAK;QACL,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,IAAI;QAEX,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAEP,IAAI,OAAc,YAAY;YAC5B,KAAK,EAAE;YACP,KAAK;YACL,MAAO,OAAc,WAAY;gBAC/B,GAAG,IAAI,CAAC;gBACR,KAAK;YACP;YACA,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,IAAI;gBAEX,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAChB,KAAK,IAAI;oBAEX,IAAI,OAAc,YAAY;wBAC5B,KAAK,EAAE;wBACP,KAAK;wBACL,MAAO,OAAc,WAAY;4BAC/B,GAAG,IAAI,CAAC;4BACR,KAAK;wBACP;wBACA,IAAI,OAAc,YAAY;4BAC5B,eAAe;4BACf,KAAK,OAAO,IAAI,IAAI,IAAI;4BACxB,KAAK;wBACP,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,iBAAsB;QAC7B,IAAI,IAAI;QAER,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK,OAAO;oBACd,CAAC;oBACD,KAAK;gBACP,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAExB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,IAAI;QAEX,IAAI,OAAc,YAAY;YAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;gBACxC,KAAK;gBACL;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;YACD,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK,EAAE;gBACP,IAAI,OAAO,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;oBAC1C,KAAK,MAAM,MAAM,CAAC;oBAClB;gBACF,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,MAAO,OAAc,WAAY;oBAC/B,GAAG,IAAI,CAAC;oBACR,IAAI,OAAO,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;wBAC1C,KAAK,MAAM,MAAM,CAAC;wBAClB;oBACF,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;gBACH;gBACA,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,OAAO;oBACZ,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,2BAAgC;QACvC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAExB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,KAAK,EAAE;YACP,KAAK;YACL,MAAO,OAAc,WAAY;gBAC/B,GAAG,IAAI,CAAC;gBACR,KAAK;YACP;YACA,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;iBAEzB,KAAK;YAEP,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK,EAAE;gBACP,KAAK;gBACL,MAAO,OAAc,WAAY;oBAC/B,GAAG,IAAI,CAAC;oBACR,KAAK;gBACP;gBACA,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,OAAO,IAAI,IAAI;oBACpB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,kBAAuB;QAC9B,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;aAEA,KAAK;QAEP,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,QAAQ;QACf,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,6BAAkC;QACzC,IAAI;QAEJ,KAAK;QACL,IAAI,OAAc,YAChB,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,iBAAsB;QAC7B,IAAI,IAAI,IAAI,IAAI,IAAI;QAEpB,KAAK;QACL,KAAK;QACL;QACA,KAAK;QACL;QACA,IAAI,OAAc,YAChB,KAAK;aACA;YACL,cAAc;YACd,KAAK;QACP,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;gBACxC,KAAK;gBACL;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;YACD,IAAI,OAAc,YAAY;gBAC5B,KAAK,EAAE;gBACP,KAAK;gBACL,MAAO,OAAc,WAAY;oBAC/B,GAAG,IAAI,CAAC;oBACR,KAAK;gBACP;gBACA,IAAI,OAAc,YAAY;oBAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;wBACxC,KAAK;wBACL;oBACF,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK,QAAQ;wBACb,KAAK;oBACP,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,qBAA0B;QACjC,IAAI,IAAI,IAAI,IAAI;QAEhB,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;oBACxC,KAAK;oBACL;gBACF,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK;gBACP,CAAC;gBACD,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;wBACxC,KAAK;wBACL;oBACF,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK;oBACP,CAAC;oBACD,KAAK;gBACP,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAEpC,KAAK;QACL,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;YAC5C,KAAK;YACL,eAAe;QACjB,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,IAAI;gBAEX,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAChB,KAAK,IAAI;oBAEX,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,IAAI,OAAc,YAAY;4BAC5B,KAAK;4BACL,IAAI,OAAc,YAChB,KAAK,IAAI;4BAEX,IAAI,OAAc,YAAY;gCAC5B,KAAK;gCACL,IAAI,OAAc,YAAY;oCAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;wCACzC,KAAK;wCACL;oCACF,OAAO;wCACL,KAAK;wCACL,IAAI,oBAAoB,GAAK,SAAS;oCACxC,CAAC;oCACD,IAAI,OAAc,YAAY;wCAC5B,eAAe;wCACf,KAAK,QAAQ,IAAI,IAAI;wCACrB,KAAK;oCACP,OAAO;wCACL,cAAc;wCACd,KAAK;oCACP,CAAC;gCACH,OAAO;oCACL,cAAc;oCACd,KAAK;gCACP,CAAC;4BACH,OAAO;gCACL,cAAc;gCACd,KAAK;4BACP,CAAC;wBACH,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,yBAA8B;QACrC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,yBAA8B;QACrC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;aAEA,KAAK;QAEP,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,2CAAgD;QACvD,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAE5B,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;YACzC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,IAAI,OAAc,YAChB,KAAK,IAAI;wBAEX,IAAI,OAAc,YAAY;4BAC5B,KAAK;4BACL,IAAI,OAAc,YAAY;gCAC5B,eAAe;gCACf,KAAK,QAAQ,IAAI;gCACjB,KAAK;4BACP,OAAO;gCACL,cAAc;gCACd,KAAK;4BACP,CAAC;wBACH,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,sCAA2C;QAClD,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;YACzC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,4BAAiC;QACxC,IAAI,IAAI;QAER,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;aAEA,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,0BAA+B;QACtC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK,EAAE;QACP,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;aAEA,KAAK;QAEP,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAEP,IAAI,OAAc,YAChB,KAAK;QAEP,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;YACL,KAAK,EAAE;YACP,KAAK;YACL,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;gBAC/B,GAAG,IAAI,CAAC;gBACR,KAAK;YACP;iBAEA,KAAK;YAEP,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;iBAEzB,KAAK;YAEP,IAAI,OAAc,YAChB,KAAK;QAET;aAEA,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,sBAA2B;QAClC,IAAI,IAAI;QAER,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;gBACxC,KAAK;gBACL;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;YACD,IAAI,OAAc,YAAY;gBAC5B,eAAe;gBACf,KAAK;YACP,CAAC;YACD,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;oBACzC,KAAK;oBACL;gBACF,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK;gBACP,CAAC;gBACD,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;wBACzC,KAAK;wBACL;oBACF,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK;oBACP,CAAC;oBACD,KAAK;gBACP,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,gBAAqB;QAC5B,IAAI;QAEJ,KAAK;QACL,IAAI,OAAc,YAChB,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,oBAAyB;QAChC,IAAI,IAAI,IAAI,IAAI;QAEhB,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;oBACxC,KAAK;oBACL;gBACF,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK;gBACP,CAAC;gBACD,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;wBACzC,KAAK;wBACL;oBACF,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK;oBACP,CAAC;oBACD,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;4BACxC,KAAK;4BACL;wBACF,OAAO;4BACL,KAAK;4BACL,IAAI,oBAAoB,GAAK,SAAS;wBACxC,CAAC;wBACD,IAAI,OAAc,YAAY;4BAC5B,eAAe;4BACf,KAAK;wBACP,CAAC;wBACD,KAAK;wBACL,IAAI,OAAc,YAAY;4BAC5B,KAAK;4BACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;gCACxC,KAAK;gCACL;4BACF,OAAO;gCACL,KAAK;gCACL,IAAI,oBAAoB,GAAK,SAAS;4BACxC,CAAC;4BACD,IAAI,OAAc,YAAY;gCAC5B,eAAe;gCACf,KAAK;4BACP,CAAC;4BACD,KAAK;4BACL,IAAI,OAAc,YAAY;gCAC5B,KAAK;gCACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;oCACzC,KAAK;oCACL;gCACF,OAAO;oCACL,KAAK;oCACL,IAAI,oBAAoB,GAAK,SAAS;gCACxC,CAAC;gCACD,IAAI,OAAc,YAAY;oCAC5B,eAAe;oCACf,KAAK;gCACP,CAAC;gCACD,KAAK;gCACL,IAAI,OAAc,YAAY;oCAC5B,KAAK;oCACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;wCACzC,KAAK;wCACL;oCACF,OAAO;wCACL,KAAK;wCACL,IAAI,oBAAoB,GAAK,SAAS;oCACxC,CAAC;oCACD,IAAI,OAAc,YAAY;wCAC5B,eAAe;wCACf,KAAK;oCACP,CAAC;oCACD,KAAK;oCACL,IAAI,OAAc,YAAY;wCAC5B,KAAK;wCACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;4CACxC,KAAK;4CACL;wCACF,OAAO;4CACL,KAAK;4CACL,IAAI,oBAAoB,GAAK,SAAS;wCACxC,CAAC;wCACD,IAAI,OAAc,YAAY;4CAC5B,eAAe;4CACf,KAAK;wCACP,CAAC;wCACD,KAAK;wCACL,IAAI,OAAc,YAAY;4CAC5B,KAAK;4CACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;gDACxC,KAAK;gDACL;4CACF,OAAO;gDACL,KAAK;gDACL,IAAI,oBAAoB,GAAK,SAAS;4CACxC,CAAC;4CACD,IAAI,OAAc,YAAY;gDAC5B,eAAe;gDACf,KAAK;4CACP,CAAC;4CACD,KAAK;wCACP,CAAC;oCACH,CAAC;gCACH,CAAC;4BACH,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,eAAoB;QAC3B,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAEhC,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;YACzC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,IAAI,OAAc,YAChB,KAAK,IAAI;wBAEX,IAAI,OAAc,YAAY;4BAC5B,KAAK;4BACL,IAAI,OAAc,YAAY;gCAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;oCACzC,KAAK;oCACL;gCACF,OAAO;oCACL,KAAK;oCACL,IAAI,oBAAoB,GAAK,SAAS;gCACxC,CAAC;gCACD,IAAI,OAAc,YAAY;oCAC5B,eAAe;oCACf,KAAK,QAAQ,IAAI;oCACjB,KAAK;gCACP,OAAO;oCACL,cAAc;oCACd,KAAK;gCACP,CAAC;4BACH,OAAO;gCACL,cAAc;gCACd,KAAK;4BACP,CAAC;wBACH,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,6BAAkC;QACzC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI,IAAI;QAER,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;aAEA,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,oBAAyB;QAChC,IAAI,IAAI;QAER,KAAK,EAAE;QACP,KAAK;QACL,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;QAEA,OAAO;IACT;IAEA,SAAS,wBAA6B;QACpC,IAAI,IAAI,IAAI,IAAI;QAEhB,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;oBACxC,KAAK;oBACL;gBACF,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK;gBACP,CAAC;gBACD,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;wBACzC,KAAK;wBACL;oBACF,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK;oBACP,CAAC;oBACD,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;4BACzC,KAAK;4BACL;wBACF,OAAO;4BACL,KAAK;4BACL,IAAI,oBAAoB,GAAK,SAAS;wBACxC,CAAC;wBACD,IAAI,OAAc,YAAY;4BAC5B,eAAe;4BACf,KAAK;wBACP,CAAC;wBACD,KAAK;oBACP,CAAC;gBACH,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,aAAkB;QACzB,IAAI,IAAI;QAER;QACA,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;QACA;QACA,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,iBAAsB;QAC7B,IAAI,IAAI;QAER;QACA,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;aAEA,KAAK;QAEP;QACA,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI;QAEJ,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK;QAET,CAAC;QAED,OAAO;IACT;IAEA,SAAS,kCAAuC;QAC9C,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;oBAAC;oBAAI;iBAAG;gBACb,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,oBAAyB;QAChC,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,0BAA+B;QACtC,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,kBAAuB;QAC9B,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,iBAAsB;QAC7B,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,aAAa;IAEb,IAAI,eAAe,cAAc,gBAAgB,MAAM,MAAM,EAC3D,OAAO;SACF;QACL,IAAI,eAAe,cAAc,cAAc,MAAM,MAAM,EACzD,SAAS;QAGX,MAAM,yBACJ,qBACA,iBAAiB,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,kBAAkB,IAAI,EACnE,iBAAiB,MAAM,MAAM,GACzB,oBAAoB,gBAAgB,iBAAiB,KACrD,oBAAoB,gBAAgB,eAAe,EACvD;IACJ,CAAC;AACH;AASO,MAAM,4CAAuB;;;AbpzDpC;;CAEC,GACD,MAAM,6CAAuB,CAAA,GAAA,wCAAc,AAAD;IACxC;;;;GAIC,GACD,MAAM,kBAA0B,EAAQ;QACtC,OAAO,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAA,GAAA,yCAAI;IACtD;AACF;IAEA,2CAAe;;;AclBf;;AAKA,MAAM,oCAAc;AACpB,MAAM,yCAAmB;AAEzB;;;;;;;;CAQC,GACD,MAAM;IACJ,iBAAiB,IAAI,CAAC;IAEtB,qBAAqB,IAAI,CAAC;IAE1B,OAAa,IAAI,CAAA,GAAA,wCAAG,IAAI;IAExB,WAAwB,IAAI,CAAC;IAE7B,kBAA0C,IAAI,CAAC;IAE/C,QAAkB,EAAE,CAAC;IAErB,cAAc,EAAE;IAEhB,YAAY,EAAE;IAEd;;;;;;GAMC,GACD,YAAY,sBAAE,qBAAqB,IAAI,GAAoC,GAAG,CAAC,CAAC,CAAE;QAChF,CAAA,GAAA,yCAAS,AAAD,EACN,CAAC;;;;oEAI6D,CAAC;QAEjE,IAAI,CAAC,kBAAkB,GAAG;IAC5B;IAEA;;;;;;GAMC,GACD,MAAM,UAAkB,EAAE,QAAE,KAAI,EAAmB,GAAG,CAAC,CAAC,EAAQ;QAC9D,IAAI,CAAC,UAAU,CAAC,YAAY;QAE5B,MAAO,IAAI,CAAC,WAAW,GAAI;YACzB,MAAM,OAAO,IAAI,CAAC,QAAQ;YAC1B,IAAI,CAAC,SAAS,CAAC;QACjB;QAEA,IAAI,CAAC,SAAS;QACd,OAAO,IAAI,CAAC,IAAI;IAClB;IAEA,YAAY,CAAE;IAEd,UAAU,IAAI,EAAE;QACd,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO;QAEjC,IAAI,KAAK,IAAI,GAAG,MAAM,KAAK,GACzB,IAAI,CAAC,eAAe,GAAG,IAAI;aAE3B,IAAI,CAAC,iBAAiB,CAAC;IAE3B;IAEA,kBAAkB,IAAI,EAAE;QACtB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,IAAI,MAAM,wCAAwC;QAE5E,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,kBAAkB;QAEvD,IAAI,uCAAiB,IAAI,CAAC,SAAS,IAAI,CAAC,WAAW,IAAI;YACrD,MAAM,WAAW,IAAI,CAAC,QAAQ;YAC9B,IAAI,CAAC,qBAAqB,CAAC,MAAM;QACnC,OACE,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE,KAAK,CAAC;IAE3C;IAEA,WAAW,QAAQ,EAAE,OAAoB,IAAI,EAAE;QAC7C,IAAI,MACF,IAAI,CAAC,IAAI,GAAG;QAGd,IAAI,CAAC,KAAK,GAAG,CAAA,GAAA,yCAAmB,EAAE,UAAU,KAAK,CAAC;QAClD,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM;QAClC,IAAI,CAAC,cAAc,GAAG,IAAI;IAC5B;IAEA,WAAW;QACT,MAAM,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC;QACzC,IAAI,CAAC,WAAW,IAAI;QACpB,OAAO;IACT;IAEA,cAAc;QACZ,OAAO,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,SAAS;IAC1C;IAEA,sBAAsB,UAAU,EAAE,UAAU,EAAE;QAC5C,IAAI,CAAC,iBAAiB,CAAC,YAAY;QAEnC,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,IAAI,MAAM,+CAA+C;QAE1F,IAAI,CAAC,eAAe,CAAC,MAAM,IAAI,WAAW,SAAS,CAAC,WAAW,MAAM;QACrE,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI;QAE9D,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,EAC7B,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI;QAGhE,IAAI,CAAC,WAAW,IAAI,GAAG,MAAM,EAC3B,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO;IAErC;IAEA,kBAAkB,UAAU,EAAE,UAAU,EAAE;QACxC,IAAK,IAAI,IAAI,GAAG,YAAY,WAAW,MAAM,EAAE,IAAI,WAAW,KAAK,EAAG;YACpE,MAAM,MAAM,UAAU,CAAC,EAAE;YACzB,MAAM,WAAW,UAAU,CAAC,IAAI,EAAE;YAClC,MAAM,eAAe,kCAAY,IAAI,CAAC;YACtC,IAAI,CAAC,YAAY,CAAC,KAAK;YAEvB,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,IAAI,MAAM,+CAA+C;YAE1F,IAAI,CAAC,eAAe,CAAC,MAAM,IAAI,UAAU,CAAC,EAAE,IAAI;YAChD,IAAI,CAAC,cAAc,GAAG,CAAC;QACzB;IACF;IAEA,aAAa,GAAG,EAAE,QAAQ,EAAE;QAC1B,MAAM,eAAe,kCAAY,IAAI,CAAC;QAEtC,IAAI,CAAC,cACH,IAAI,CAAC,gCAAgC;QAGvC,IAAI,CAAC,gBAAgB,IAAI,CAAC,0BAA0B,CAAC,WAAW;YAC9D,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,MAAM,IAAI,MAAM,+CAA+C;YAC1F,IAAI,CAAC,eAAe,CAAC,MAAM,IAAI;QACjC,CAAC;IACH;IAEA,2BAA2B,QAAQ,EAAE;QACnC,OAAQ,YAAY,kCAAY,IAAI,CAAC,aAAa,IAAI,CAAC,kBAAkB;IAC3E;IAEA,mCAAmC;QACjC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACxB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,IAAI,MAAM,wCAAwC;YAC5E,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,kBAAkB;YACvD,IAAI,CAAC,cAAc,GAAG,IAAI;QAC5B,CAAC;IACH;AACF;IAEA,2CAAe;;;;AC9Kf;ACCA,0DAA0D;AAC1D,EAAE;AACF,gEAAgE;AAEhE;AA4CA,SAAS,iCAAW,GAAW,EAAE,YAAoB,EAAE,SAAiB,EAAE;IACxE,YAAY,aAAa;IACzB,IAAI,IAAI,MAAM,GAAG,cACf,OAAO;IAET,gBAAgB,IAAI,MAAM;IAC1B,aAAa,UAAU,MAAM,CAAC;IAC9B,OAAO,MAAM,UAAU,KAAK,CAAC,GAAG;AAClC;AAEO,MAAM,kDAAyB;IACpC,OAAc,aAAa,QAAuB,EAAE,KAAoB,EAAE;QACxE,SAAS,IAAI,EAAU,EAAU;YAC/B,OAAO,GAAG,UAAU,CAAC,GAAG,QAAQ,CAAC,IAAI,WAAW;QAClD;QAEA,SAAS,cAAc,CAAS,EAAU;YACxC,OAAO,EACJ,OAAO,CAAC,OAAO,QACf,OAAO,CAAC,MAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,gBAA2B,CAAC,KAAO,SAAS,IAAI,KACxD,OAAO,CAAC,yBAAyB,CAAC,KAAO,QAAS,IAAI;QAC3D;QAEA,SAAS,YAAY,CAAS,EAAU;YACtC,OAAO,EACJ,OAAO,CAAC,OAAO,QACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,MAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,OAAO,OACf,OAAO,CAAC,gBAA2B,CAAC,KAAO,SAAS,IAAI,KACxD,OAAO,CAAC,yBAAyB,CAAC,KAAO,QAAS,IAAI;QAC3D;QAEA,SAAS,oBAAoB,WAAwB,EAAE;YACrD,OAAQ,YAAY,IAAI;gBACtB,KAAK;oBACH,OAAO,MAAO,cAAc,YAAY,IAAI,IAAI;gBAClD,KAAK;oBACH,MAAM,eAAe,YAAY,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS;wBACnD,OAAO,MAAM,OAAO,CAAC,QACjB,YAAY,IAAI,CAAC,EAAE,IAAc,MAAM,YAAY,IAAI,CAAC,EAAE,IAC1D,YAAY,KAAK;oBACvB;oBAEA,OAAO,MAAO,CAAA,YAAY,QAAQ,GAAG,MAAM,EAAE,AAAD,IAAK,eAAe;gBAClE,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO;gBACT,KAAK;oBACH,OAAO,YAAY,WAAW;YAClC;QACF;QAEA,SAAS,iBAAiB,SAAwB,EAAE;YAClD,MAAM,eAAe,UAAU,GAAG,CAAC;YACnC,IAAI;YACJ,IAAI;YAEJ,aAAa,IAAI;YAEjB,IAAI,aAAa,MAAM,GAAG,GAAG;gBAC3B,IAAK,IAAI,GAAG,IAAI,CAAC,EAAE,IAAI,aAAa,MAAM,EAAE,IAC1C,IAAI,YAAY,CAAC,IAAI,EAAE,KAAK,YAAY,CAAC,EAAE,EAAE;oBAC3C,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE;oBACjC;gBACF,CAAC;gBAEH,aAAa,MAAM,GAAG;YACxB,CAAC;YAED,OAAQ,aAAa,MAAM;gBACzB,KAAK;oBACH,OAAO,YAAY,CAAC,EAAE;gBAExB,KAAK;oBACH,OAAO,YAAY,CAAC,EAAE,GAAG,SAAS,YAAY,CAAC,EAAE;gBAEnD;oBACE,OAAO,aAAa,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,QAClC,UACA,YAAY,CAAC,aAAa,MAAM,GAAG,EAAE;YAC7C;QACF;QAEA,SAAS,cAAc,MAAqB,EAAE;YAC5C,OAAO,SAAS,MAAO,cAAc,UAAU,MAAO,cAAc;QACtE;QAEA,OAAO,cAAc,iBAAiB,YAAY,UAAU,cAAc,SAAS;IACrF;IAQA,YAAY,OAAe,EAAE,QAAuB,EAAE,KAAoB,EAAE,QAAmB,CAAE;QAC/F,KAAK;QACL,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG;QAEZ,IAAI,OAAO,AAAC,OAAe,cAAc,KAAK,YAC5C,AAAC,OAAe,cAAc,CAAC,IAAI,EAAE,0CAAiB,SAAS;aAE/D,AAAC,IAAI,CAAS,SAAS,GAAG,0CAAiB,SAAS;QAEtD,IAAI,OAAO,AAAC,MAAc,iBAAiB,KAAK,YAC9C,AAAC,MAAc,iBAAiB,CAAC,IAAI,EAAE;IAE3C;IAEA,OAAO,OAAmD,EAAU;QAClE,IAAI,MAAM,YAAY,IAAI,CAAC,OAAO;QAClC,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI,MAAuB,IAAI;YAC/B,IAAI;YACJ,IAAK,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAC9B,IAAI,OAAO,CAAC,EAAE,CAAC,aAAa,KAAK,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;gBACrD,MAAM,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAM;YACR,CAAC;YAEH,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK;YAC3B,IAAI,MAAM,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,EAAE,IAAI,GAAG,MAAM,EAAE,MAAM;YAC9D,IAAI,KAAK;gBACP,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,GAAG;gBACzB,IAAI,SAAS,iCAAW,IAAI,EAAE,IAAI,CAAC,QAAQ,GAAG,MAAM,EAAE;gBACtD,IAAI,OAAO,GAAG,CAAC,EAAE,IAAI,GAAG,EAAE;gBAC1B,IAAI,OAAO,EAAE,IAAI,KAAK,EAAE,IAAI,GAAG,EAAE,MAAM,GAAG,KAAK,MAAM,GAAG,CAAC;gBACzD,OAAO,YAAY,MAAM,OAAO,SAAS,SAAS,EAAE,IAAI,GAAG,QAAQ,OAAO,OAAO,SAAS,QACxF,iCAAW,IAAI,EAAE,MAAM,GAAG,GAAG,OAC7B,iCAAW,IAAI,OAAO,EAAE,MAAM,EAAE;YACpC,OACE,OAAO,WAAW;QAEtB,CAAC;QACD,OAAO;IACT;AACF;AAEA,SAAS,gCAAU,KAAa,EAAE,OAAsB,EAAE;IACxD,UAAU,YAAY,YAAY,UAAU,CAAC,CAAC;IAE9C,MAAM,aAA4B,CAAC;IACnC,MAAM,aAAa,QAAQ,aAAa;IAExC,MAAM,yBAA8C;QAAE,YAAY;IAAoB;IACtF,IAAI,wBAAmC;IAEvC,MAAM,SAAS,SAAS,aAAkB,EAAE,KAAU,EAAO;QACvD,OAAO;YACL,MAAM;YACN,OAAO;mBACF;mBACA;aACJ;QACH;IACF;IACJ,MAAM,SAAS,SAAS,OAAY,EAAE,KAAU,EAAE,YAAiB,EAAO;QACtE,MAAM,eAAe,SAAS,SAAS;QACvC,MAAM,aAAa,eAAe;YAAC;gBAAE,MAAM;gBAAQ,OAAO,EAAE;YAAC;SAAE,GAAG,EAAE;QACpE,OAAO;eAAI;eAAe;YAAO;SAAa;IAChD;IACF,MAAM,SAAS,SAAS,IAAS,EAAO;QACpC,OAAO;IACT;IACF,MAAM,SAAS,SAAS,IAAS,EAAO;QACpC,IAAI,KAAK,IAAI,KAAK,cAChB,OAAO;YACL,MAAM;YACN,OAAO,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC,OAAS;gBAC9B,MAAM,kBAAkB;oBACtB,MAAM;gBACR;gBAEA,IAAI,KAAK,IAAI,KAAK,SAChB,OAAO;oBACL,GAAG,eAAe;oBAClB,OAAO;gBACT;gBAGF,OAAO;oBACL,GAAG,eAAe;oBAClB,QAAQ,KAAK,KAAK;gBACpB;YACF;QACF;QAGF,OAAO;IACT;IACF,MAAM,SAAS,SAAS,UAAe,EAAE,MAAW,EAAO;QACrD,MAAM,SAAS,WAAW,KAAK;QAE/B,MAAM,mBAAmB,OAAO,GAAG,CAAC,CAAC,OAAO,IAAM;YAChD,MAAM,YAAY,MAAM,CAAC,IAAI,EAAE;YAC/B,MAAM,QAAQ,MAAM,MAAM,GAAG;YAC7B,MAAM,MAAM,YAAY,UAAU,MAAM,GAAG,IAAI,OAAO,MAAM;YAC5D,MAAM,aAAa,OAAO,SAAS,CAAC,OAAO;YAC3C,MAAM,SAAS,aAAa,IAAI,CAAC;YACjC,MAAM,qBAAqB,SAAU,OAAO,KAAK,GAAG,MAAM,CAAC,EAAE,CAAC,MAAM,GAAI,IAAI;YAE5E,MAAM,YAAY,AAAC,MAAM,IAAI,KAAK,UAAW;uBAAE;YAAM,IAAI;gBAAE,QAAQ,MAAM,KAAK;YAAC,CAAC;YAEhF,IAAI,sBAAsB,qBAAqB,KAC7C,OAAO;gBACL;oBAAE,MAAM;oBAAmB,GAAG,SAAS;oBAAE,QAAQ,WAAW,SAAS,CAAC,GAAG;gBAAoB;gBAC7F;oBAAE,MAAM;oBAAmB,QAAQ;oBAAI,QAAQ,WAAW,SAAS,CAAC;gBAAoB;aACzF;YAGH,OAAO;gBAAE,MAAM;gBAAmB,GAAG,SAAS;gBAAE,QAAQ;YAAW;QACrE,GAAG,IAAI;QAEP,MAAM,aAAa,MAAM,CAAC,EAAE;QAE5B,IAAI,cAAc,WAAW,MAAM,GAAG,GAAG;YACxC,MAAM,qBAAqB,WAAW,MAAM;YAE3C,IAAI,qBAAqB,GACvB,iBAAiB,OAAO,CAAC;gBACvB,MAAM;gBACN,QAAQ;gBACR,QAAQ,OAAO,SAAS,CAAC,GAAG,qBAAqB;YACnD;QAEJ,CAAC;QAED,OAAO;YAAE,MAAM;YAAQ,OAAO;QAAiB;IACjD;IACJ,MAAM,SAAS,SAAS,KAAU,EAAO;QACnC,OAAO;YACL,MAAM;mBACN;QACF;IACF;IACJ,MAAM,SAAS,SAAS,MAAW,EAAO;QACpC,OAAO;IACT;IACJ,MAAM,SAAS;IACf,MAAM,SAAS,uBAAuB,KAAK,KAAK;IAChD,MAAM,SAAS;IACf,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,MAAW,EAAO;QACrC,OAAO;YACL,MAAM;YACN,OAAO;YACP,QAAQ,WAAW,KAAK,CAAC,MAAM;QACjC;IACF;IACJ,MAAM,UAAU,SAAS,MAAW,EAAO;QACxC,IAAI,OAAO,MAAM,KAAK,GACnB,OAAO;YAAE,MAAM;YAAQ,OAAO,EAAE;QAAC;QAGnC,OAAO;YACL,MAAM;YACN,OAAO;gBACL;oBAAE,MAAM;oBAAmB,QAAQ;4BAAI;gBAAO;aAC/C;QACH;IACF;IACF,MAAM,UAAU,SAAS,KAAU,EAAO;QACpC,OAAO;IACT;IACJ,MAAM,UAAU,SAAS,IAAS,EAAO;QACnC,OAAO;YACL,MAAM;YACN,OAAO;gBACL;oBAAE,MAAM;oBAAO,MAAM;oBAAW,OAAO;gBAAK;aAC7C;QACH;IACF;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,SAAS,IAAI;IACpD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,UAAU,IAAI;IACrD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,UAAU,IAAI;IACrD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,OAAO,IAAI;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,aAAa,IAAI;IACxD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,gBAAgB,IAAI;IAC3D,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,SAAS,IAAI;IACpD,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAM;KAAK,EAAE,IAAI,EAAE,KAAK;IAC9D,MAAM,UAAU,SAAS,KAAU,EAAE,YAAiB,EAAO;QACvD,OAAO;eAAI;YAAO;SAAa,CAC5B,MAAM,CAAC,CAAA,IAAK,GACZ,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM,GAAM,CAAA;gBACtB,MAAM;gBACN,OAAO;oBACL;wBAAE,MAAM;wBAAO,MAAM;+BAAK;oBAAM;iBACjC;YACH,CAAA;IACJ;IACJ,MAAM,UAAU,SAAS,GAAQ,EAAE,KAAU,EAAO;QAC9C,OAAO;YACL,MAAM;YACN,OAAO;gBACL;oBAAE,MAAM;oBAAO,MAAM;2BAAK;gBAAM;aACjC;QACH;IACF;IACJ,MAAM,UAAU,SAAS,IAAS,EAAO;QACnC,OAAO;IACT;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,IAAS,EAAO;QACrC,OAAO;IACT;IACF,MAAM,UAAU,SAAS,GAAQ,EAAE,KAAU,EAAO;QAChD,OAAO;YAAC;YAAK;SAAM;IACrB;IACF,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;QAAK;KAAI,EAAE,KAAK,EAAE,KAAK;IACjG,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAM;QAAM;KAAI,EAAE,IAAI,EAAE,KAAK;IACnE,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,OAAO,KAAK;IACnD,MAAM,UAAU,qBAAqB;IACrC,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;QAAK;KAAK,EAAE,KAAK,EAAE,KAAK;IAC9D,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU,SAAS,KAAU,EAAO;QACpC,OAAO;YAAE,MAAM;YAAS,GAAG,KAAK;YAAE,QAAQ,WAAW,KAAK,CAAC,MAAM;QAAC;IACpE;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;QAAE;QAAK;QAAK;QAAK;KAAI,EAAE,KAAK,EAAE,KAAK;IAC3G,MAAM,UAAU,SAAS,IAAS,EAAE,QAAa,EAAE,MAAW,EAAE,IAAS,EAAO;QAC3E,OAAO;YAAE,MAAM;sBAAM;oBAAU;YAAQ,GAAG,IAAI;YAAE,WAAW;QAAS;IACrE;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,qBAAqB;QAAC;YAAC;YAAK;SAAI;QAAE;YAAC;YAAK;SAAI;KAAC,EAAE,KAAK,EAAE,KAAK;IAC3E,MAAM,UAAU,SAAS,IAAS,EAAE,QAAa,EAAO;QAClD,OAAO;YAAE,UAAU;YAAM,cAAc;QAAS;IAClD;IACJ,MAAM,UAAU,SAAS,QAAa,EAAE,IAAS,EAAE,MAAW,EAAE,IAAS,EAAO;QAC1E,OAAO;YAAE,MAAM;sBAAM;oBAAU;YAAQ,GAAG,IAAI;YAAE,WAAW;QAAU;IACvE;IACJ,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,OAAO,KAAK;IACnD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,OAAO,KAAK;IACnD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,OAAO,KAAK;IACnD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,OAAO,KAAK;IACnD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,MAAM,KAAK;IAClD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU;IAChB,MAAM,UAAU,uBAAuB,KAAK,KAAK;IACjD,MAAM,UAAU,SAAS,QAAa,EAAE,IAAS,EAAO;QAClD,OAAO;YAAE,UAAU;YAAM,cAAc;QAAS;IAClD;IACJ,MAAM,UAAU,SAAS,QAAa,EAAE,IAAS,EAAE,MAAW,EAAE,IAAS,EAAO;QAC1E,OAAO;YAAE,MAAM;sBAAM;oBAAU;YAAQ,GAAG,IAAI;YAAE,WAAW;QAAU;IACvE;IACJ,MAAM,UAAU;IAChB,MAAM,WAAW,qBAAqB;QAAC;YAAC;YAAK;SAAI;KAAC,EAAE,KAAK,EAAE,KAAK;IAEhE,IAAI,cAAc;IAClB,IAAI,eAAe;IACnB,MAAM,sBAAsB;QAAC;YAAE,MAAM;YAAG,QAAQ;QAAE;KAAE;IACpD,IAAI,iBAAiB;IACrB,IAAI,sBAAqC,EAAE;IAC3C,IAAI,kBAAkB;IAEtB,IAAI;IAEJ,IAAI,QAAQ,SAAS,KAAK,WAAW;QACnC,IAAI,CAAE,CAAA,QAAQ,SAAS,IAAI,sBAAqB,GAC9C,MAAM,IAAI,MAAM,qCAAqC,QAAQ,SAAS,GAAG,MAAO;QAGlF,wBAAwB,sBAAsB,CAAC,QAAQ,SAAS,CAAC;IACnE,CAAC;IAED,SAAS,OAAe;QACtB,OAAO,MAAM,SAAS,CAAC,cAAc;IACvC;IAEA,SAAS,WAAsB;QAC7B,OAAO,oBAAoB,cAAc;IAC3C;IAEA,SAAS,SAAS,WAAmB,EAAE,SAAqB,EAAE;QAC5D,YAAY,cAAc,YACtB,YACA,oBAAoB,cAAc,YAAY;QAElD,MAAM,yBACJ;YAAC,qBAAqB;SAAa,EACnC,MAAM,SAAS,CAAC,cAAc,cAC9B,WACA;IACJ;IAEA,SAAS,MAAM,OAAe,EAAE,SAAqB,EAAE;QACrD,YAAY,cAAc,YACtB,YACA,oBAAoB,cAAc,YAAY;QAElD,MAAM,qBAAqB,SAAS,WAAW;IACjD;IAEA,SAAS,uBAAuB,KAAa,EAAE,UAAmB,EAAsB;QACtF,OAAO;YAAE,MAAM;YAAW,MAAM;YAAO,YAAY;QAAW;IAChE;IAEA,SAAS,qBAAqB,KAAiB,EAAE,QAAiB,EAAE,UAAmB,EAAoB;QACzG,OAAO;YAAE,MAAM;YAAS,OAAO;YAAO,UAAU;YAAU,YAAY;QAAW;IACnF;IAEA,SAAS,qBAAqC;QAC5C,OAAO;YAAE,MAAM;QAAM;IACvB;IAEA,SAAS,qBAAqC;QAC5C,OAAO;YAAE,MAAM;QAAM;IACvB;IAEA,SAAS,qBAAqB,WAAmB,EAAoB;QACnE,OAAO;YAAE,MAAM;YAAS,aAAa;QAAY;IACnD;IAEA,SAAS,sBAAsB,GAAW,EAAE;QAC1C,IAAI,UAAU,mBAAmB,CAAC,IAAI;QACtC,IAAI;QAEJ,IAAI,SACF,OAAO;aACF;YACL,IAAI,MAAM;YACV,MAAO,CAAC,mBAAmB,CAAC,EAAE,CAC5B;YAGF,UAAU,mBAAmB,CAAC,EAAE;YAChC,UAAU;gBACR,MAAM,QAAQ,IAAI;gBAClB,QAAQ,QAAQ,MAAM;YACxB;YAEA,MAAO,IAAI,IAAK;gBACd,IAAI,MAAM,UAAU,CAAC,OAAO,IAAI;oBAC9B,QAAQ,IAAI;oBACZ,QAAQ,MAAM,GAAG;gBACnB,OACE,QAAQ,MAAM;gBAGhB;YACF;YAEA,mBAAmB,CAAC,IAAI,GAAG;YAE3B,OAAO;QACT,CAAC;IACH;IAEA,SAAS,oBAAoB,QAAgB,EAAE,MAAc,EAAa;QACxE,MAAM,kBAAkB,sBAAsB;QAC9C,MAAM,gBAAgB,sBAAsB;QAE5C,OAAO;YACL,QAAQ;YACR,OAAO;gBACL,QAAQ;gBACR,MAAM,gBAAgB,IAAI;gBAC1B,QAAQ,gBAAgB,MAAM;YAChC;YACA,KAAK;gBACH,QAAQ;gBACR,MAAM,cAAc,IAAI;gBACxB,QAAQ,cAAc,MAAM;YAC9B;QACF;IACF;IAEA,SAAS,SAAS,SAAsB,EAAE;QACxC,IAAI,cAAc,gBAAkB;QAEpC,IAAI,cAAc,gBAAgB;YAChC,iBAAiB;YACjB,sBAAsB,EAAE;QAC1B,CAAC;QAED,oBAAoB,IAAI,CAAC;IAC3B;IAEA,SAAS,qBAAqB,OAAe,EAAE,SAAoB,EAAE;QACnE,OAAO,IAAI,0CAAiB,SAAS,EAAE,EAAE,IAAI;IAC/C;IAEA,SAAS,yBAAyB,SAAwB,EAAE,KAAoB,EAAE,SAAoB,EAAE;QACtG,OAAO,IAAI,0CACT,0CAAiB,YAAY,CAAC,WAAW,QACzC,WACA,OACA;IAEJ;IAEA,SAAS,sBAA2B;QAClC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,IAAI;QAEX,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK,IAAI;YAEX,IAAI,OAAc,YAAY;gBAC5B,eAAe;gBACf,KAAK,OAAO,IAAI;gBAChB,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,8BAAmC;QAC1C,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,IAAI;QAEX,IAAI,OAAc,YAAY;YAC5B,KAAK,EAAE;YACP,KAAK;YACL,MAAO,OAAc,WAAY;gBAC/B,GAAG,IAAI,CAAC;gBACR,KAAK;YACP;YACA,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,IAAI;gBAEX,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,OAAO,IAAI,IAAI;oBACpB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,qCAA0C;QACjD,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,eAAe;gBACf,KAAK,OAAO;gBACZ,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,0BAA+B;QACtC,IAAI,IAAI;QAER,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAChB,KAAK;gBAET,CAAC;YACH,CAAC;QACH,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,OAAO;QACd,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,4BAAiC;QACxC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,OAAO,IAAI;oBAChB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,sBAA2B;QAClC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,IAAI,OAAc,YAChB,KAAK;QAEP,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;YACL,IAAI,OAAc,YAChB,KAAK;QAET;aAEA,KAAK;QAEP,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,OAAO;QACd,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,mCAAwC;QAC/C,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,OAAO;oBACZ,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,wBAA6B;QACpC,IAAI,IAAI;QAER,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;gBACzC,KAAK;gBACL;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;YACD,IAAI,OAAc;gBAChB,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;oBACxC,KAAK;oBACL;gBACF,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;aACF;QACH,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,QAAQ;QACf,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,sBAA2B;QAClC,IAAI,IAAI;QAER,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,QAAQ;QACf,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,kBAAuB;QAC9B,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;QACA,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,0BAA+B;QACtC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;aAEA,KAAK;QAEP,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,4BAAiC;QACxC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ;oBACb,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,yBAA8B;QACrC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAEhC,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK,EAAE;oBACP,KAAK;oBACL,MAAO,OAAc,WAAY;wBAC/B,GAAG,IAAI,CAAC;wBACR,KAAK;oBACP;oBACA,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,IAAI,OAAc,YAAY;4BAC5B,KAAK;gCAAC;gCAAI;gCAAI;gCAAI;gCAAI;6BAAG;4BACzB,KAAK;wBACP,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QACD,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAEP,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,QAAQ;QACf,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI;QAEJ,IAAI,MAAM,MAAM,CAAC,aAAa,GAAG,WAAW,OAAO,SAAS;YAC1D,KAAK,MAAM,MAAM,CAAC,aAAa;YAC/B,eAAe;QACjB,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,GAAG,WAAW,OAAO,SAAS;gBAC1D,KAAK,MAAM,MAAM,CAAC,aAAa;gBAC/B,eAAe;YACjB,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;YACD,IAAI,OAAc,YAAY;gBAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,GAAG,WAAW,OAAO,SAAS;oBAC1D,KAAK,MAAM,MAAM,CAAC,aAAa;oBAC/B,eAAe;gBACjB,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,GAAG,WAAW,OAAO,SAAS;wBAC1D,KAAK,MAAM,MAAM,CAAC,aAAa;wBAC/B,eAAe;oBACjB,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,GAAG,WAAW,OAAO,SAAS;4BAC1D,KAAK,MAAM,MAAM,CAAC,aAAa;4BAC/B,eAAe;wBACjB,OAAO;4BACL,KAAK;4BACL,IAAI,oBAAoB,GAAK,SAAS;wBACxC,CAAC;wBACD,IAAI,OAAc,YAAY;4BAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,IAAI,WAAW,OAAO,SAAS;gCAC3D,KAAK,MAAM,MAAM,CAAC,aAAa;gCAC/B,eAAe;4BACjB,OAAO;gCACL,KAAK;gCACL,IAAI,oBAAoB,GAAK,SAAS;4BACxC,CAAC;4BACD,IAAI,OAAc;gCAChB,IAAI,MAAM,MAAM,CAAC,aAAa,GAAG,WAAW,OAAO,SAAS;oCAC1D,KAAK,MAAM,MAAM,CAAC,aAAa;oCAC/B,eAAe;gCACjB,OAAO;oCACL,KAAK;oCACL,IAAI,oBAAoB,GAAK,SAAS;gCACxC,CAAC;6BACF;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,oBAAyB;QAChC,IAAI;QAEJ,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,oBAAyB;QAChC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,KAAK,EAAE;QACP,KAAK;QACL,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,KAAK;QACP;QACA,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK,IAAI;YAEX,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,IAAI;gBAEX,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ,IAAI;oBACjB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,0BAA+B;QACtC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAE5B,KAAK;QACL,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAEP,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,KAAK;wBACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;6BAEzB,KAAK;wBAEP,IAAI,OAAc,YAAY;4BAC5B,eAAe;4BACf,KAAK,QAAQ,IAAI;4BACjB,KAAK;wBACP,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mCAAwC;QAC/C,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,eAAe;gBACf,KAAK,QAAQ;gBACb,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,wBAA6B;QACpC,IAAI;QAEJ,KAAK;QACL,IAAI,OAAc,YAChB,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,oCAAyC;QAChD,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAExB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;YACzC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;4BACzC,KAAK;4BACL;wBACF,OAAO;4BACL,KAAK;4BACL,IAAI,oBAAoB,GAAK,SAAS;wBACxC,CAAC;wBACD,IAAI,OAAc,YAAY;4BAC5B,eAAe;4BACf,KAAK,QAAQ;4BACb,KAAK;wBACP,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uCAA4C;QACnD,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;QAE5B,KAAK;QACL,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;aAEzB,KAAK;QAEP,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAAY;wBAC5B,KAAK;wBACL,KAAK;wBACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;6BAEzB,KAAK;wBAEP,IAAI,OAAc,YAAY;4BAC5B,eAAe;4BACf,KAAK,QAAQ,IAAI;4BACjB,KAAK;wBACP,OAAO;4BACL,cAAc;4BACd,KAAK;wBACP,CAAC;oBACH,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,iBAAsB;QAC7B,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI,IAAI;QAER,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;aAEA,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,yBAA8B;QACrC,IAAI,IAAI;QAER,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAChB,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;aAEA,KAAK;QAGP,OAAO;IACT;IAEA,SAAS,6BAAkC;QACzC,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;YAC5C,KAAK;YACL,eAAe;QACjB,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;oBAAC;oBAAI;iBAAG;gBACb,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,aAAkB;QACzB,IAAI,IAAI;QAER;QACA,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;QACA;QACA,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI;QAEJ,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK;QAET,CAAC;QAED,OAAO;IACT;IAEA,SAAS,kCAAuC;QAC9C,IAAI,IAAI,IAAI;QAEZ,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;oBAAC;oBAAI;iBAAG;gBACb,KAAK;YACP,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,oBAAyB;QAChC,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,0BAA+B;QACtC,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,iBAAsB;QAC7B,IAAI,IAAI;QAER,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK;QAET,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,eAAe;YACf,KAAK,QAAQ;QACf,CAAC;QACD,KAAK;QAEL,OAAO;IACT;IAEA,SAAS,yBAA8B;QACrC,IAAI;QAEJ,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc;YAChB,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;gBACxC,KAAK;gBACL;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;SACF;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI,IAAI;QAER,KAAK,EAAE;QACP,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,MAAO,OAAc,WAAY;YAC/B,GAAG,IAAI,CAAC;YACR,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;gBAC3C,KAAK,MAAM,MAAM,CAAC;gBAClB;YACF,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;QACH;QAEA,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI,IAAI,IAAI,IAAI,IAAI;QAEpB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK,IAAI;YAEX,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAChB,KAAK,IAAI;oBAEX,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK,QAAQ,IAAI,IAAI,IAAI;wBACzB,KAAK;oBACP,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,2BAAgC;QACvC,IAAI;QAEJ,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,2BAAgC;QACvC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,IAAI;gBAEX,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ,IAAI;oBACjB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI,IAAI,IAAI,IAAI,IAAI;QAEpB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,IAAI;QAEX,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAChB,KAAK,IAAI;oBAEX,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK,QAAQ,IAAI,IAAI,IAAI;wBACzB,KAAK;oBACP,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI;QAEJ,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;YAC5C,KAAK;YACL,eAAe;QACjB,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;gBAC5C,KAAK;gBACL,eAAe;YACjB,OAAO;gBACL,KAAK;gBACL,IAAI,oBAAoB,GAAK,SAAS;YACxC,CAAC;YACD,IAAI,OAAc,YAAY;gBAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;oBAC5C,KAAK;oBACL,eAAe;gBACjB,OAAO;oBACL,KAAK;oBACL,IAAI,oBAAoB,GAAK,SAAS;gBACxC,CAAC;gBACD,IAAI,OAAc,YAAY;oBAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;wBAC5C,KAAK;wBACL,eAAe;oBACjB,OAAO;wBACL,KAAK;wBACL,IAAI,oBAAoB,GAAK,SAAS;oBACxC,CAAC;oBACD,IAAI,OAAc,YAAY;wBAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;4BAC5C,KAAK;4BACL,eAAe;wBACjB,OAAO;4BACL,KAAK;4BACL,IAAI,oBAAoB,GAAK,SAAS;wBACxC,CAAC;wBACD,IAAI,OAAc,YAAY;4BAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;gCAC5C,KAAK;gCACL,eAAe;4BACjB,OAAO;gCACL,KAAK;gCACL,IAAI,oBAAoB,GAAK,SAAS;4BACxC,CAAC;4BACD,IAAI,OAAc,YAAY;gCAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;oCAC5C,KAAK;oCACL,eAAe;gCACjB,OAAO;oCACL,KAAK;oCACL,IAAI,oBAAoB,GAAK,SAAS;gCACxC,CAAC;gCACD,IAAI,OAAc,YAAY;oCAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;wCAC5C,KAAK;wCACL,eAAe;oCACjB,OAAO;wCACL,KAAK;wCACL,IAAI,oBAAoB,GAAK,SAAS;oCACxC,CAAC;oCACD,IAAI,OAAc,YAAY;wCAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;4CAC5C,KAAK;4CACL,eAAe;wCACjB,OAAO;4CACL,KAAK;4CACL,IAAI,oBAAoB,GAAK,SAAS;wCACxC,CAAC;wCACD,IAAI,OAAc,YAAY;4CAC5B,IAAI,MAAM,MAAM,CAAC,aAAa,OAAO,SAAS;gDAC5C,KAAK;gDACL,eAAe;4CACjB,OAAO;gDACL,KAAK;gDACL,IAAI,oBAAoB,GAAK,SAAS;4CACxC,CAAC;4CACD,IAAI,OAAc,YAAY;gDAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;oDACxC,KAAK;oDACL;gDACF,OAAO;oDACL,KAAK;oDACL,IAAI,oBAAoB,GAAK,SAAS;gDACxC,CAAC;gDACD,IAAI,OAAc,YAAY;oDAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;wDACzC,KAAK;wDACL;oDACF,OAAO;wDACL,KAAK;wDACL,IAAI,oBAAoB,GAAK,SAAS;oDACxC,CAAC;oDACD,IAAI,OAAc,YAAY;wDAC5B,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;4DACxC,KAAK;4DACL;wDACF,OAAO;4DACL,KAAK;4DACL,IAAI,oBAAoB,GAAK,SAAS;wDACxC,CAAC;wDACD,IAAI,OAAc;4DAChB,IAAI,MAAM,UAAU,CAAC,iBAAiB,KAAK;gEACzC,KAAK;gEACL;4DACF,OAAO;gEACL,KAAK;gEACL,IAAI,oBAAoB,GAAK,SAAS;4DACxC,CAAC;yDACF;oDACH,CAAC;gDACH,CAAC;4CACH,CAAC;wCACH,CAAC;oCACH,CAAC;gCACH,CAAC;4BACH,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK,IAAI;YAEX,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ,IAAI;oBACjB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,mBAAwB;QAC/B,IAAI,IAAI,IAAI,IAAI,IAAI;QAEpB,KAAK;QACL,KAAK;QACL,IAAI,OAAc,YAChB,KAAK,IAAI;QAEX,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,KAAK;gBACL,IAAI,OAAc,YAChB,KAAK,MAAM,SAAS,CAAC,IAAI;qBAEzB,KAAK;gBAEP,IAAI,OAAc,YAAY;oBAC5B,KAAK;oBACL,IAAI,OAAc,YAChB,KAAK,IAAI;oBAEX,IAAI,OAAc,YAAY;wBAC5B,eAAe;wBACf,KAAK,QAAQ,IAAI,IAAI,IAAI;wBACzB,KAAK;oBACP,OAAO;wBACL,cAAc;wBACd,KAAK;oBACP,CAAC;gBACH,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI;QAEJ,IAAI,QAAQ,IAAI,CAAC,MAAM,MAAM,CAAC,eAAe;YAC3C,KAAK,MAAM,MAAM,CAAC;YAClB;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QAED,OAAO;IACT;IAEA,SAAS,uBAA4B;QACnC,IAAI,IAAI,IAAI,IAAI;QAEhB,KAAK;QACL,IAAI,MAAM,UAAU,CAAC,iBAAiB,IAAI;YACxC,KAAK;YACL;QACF,OAAO;YACL,KAAK;YACL,IAAI,oBAAoB,GAAK,SAAS;QACxC,CAAC;QACD,IAAI,OAAc,YAAY;YAC5B,KAAK;YACL,IAAI,OAAc,YAChB,KAAK,IAAI;YAEX,IAAI,OAAc,YAAY;gBAC5B,KAAK;gBACL,IAAI,OAAc,YAAY;oBAC5B,eAAe;oBACf,KAAK,QAAQ,IAAI;oBACjB,KAAK;gBACP,OAAO;oBACL,cAAc;oBACd,KAAK;gBACP,CAAC;YACH,OAAO;gBACL,cAAc;gBACd,KAAK;YACP,CAAC;QACH,OAAO;YACL,cAAc;YACd,KAAK;QACP,CAAC;QAED,OAAO;IACT;IAEA,aAAa;IAEb,IAAI,eAAe,cAAc,gBAAgB,MAAM,MAAM,EAC3D,OAAO;SACF;QACL,IAAI,eAAe,cAAc,cAAc,MAAM,MAAM,EACzD,SAAS;QAGX,MAAM,yBACJ,qBACA,iBAAiB,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,kBAAkB,IAAI,EACnE,iBAAiB,MAAM,MAAM,GACzB,oBAAoB,gBAAgB,iBAAiB,KACrD,oBAAoB,gBAAgB,eAAe,EACvD;IACJ,CAAC;AACH;AASO,MAAM,4CAAuB;;;ADh9DpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCC,GACD,MAAM,oDAA8B,CAAA,GAAA,wCAAc,AAAD;IAC/C;;;;GAIC,GACD,MAAM,oBAA4B,EAAQ;QACxC,OAAO,IAAI,CAAC,eAAe,CAAC,sBAAsB,CAAA,GAAA,yCAAI;IACxD;AACF;IAEA,2CAAe;;;;;AGrDf;;AAgBA;;CAEC,GACD,MAAe,4CAAsB,CAAA,GAAA,wCAAS,AAAD;IAC3C;;;;GAIC,GACD,OAAO,IAAU,EAAU;QACzB,MAAM,kBAAE,eAAc,0BAAE,uBAAsB,EAAE,GAAG;QAEnD,OAAO,IAAI,CAAC,QAAQ,CAClB;kBACE;YACA,eAAe,IAAI,CAAC,aAAa;YACjC,gBAAgB,IAAI,CAAC,aAAa,CAAC,qBAAqB,GAAG,yBAAyB,cAAc;QACpG;IAEJ;IAEA;;;GAGC,GACD,OAAO,UAAU,SAAS,EAAE,EAAQ;QAClC,CAAA,GAAA,yCAAc,AAAD,EACX;IAGJ;IAEA;;;;;;;;;;;GAWC,GACD,UAAU,QAAQ,EAAE,EAAU;QAC5B,OAAO,CAAA,GAAA,yCAAO,EAAE,IAAI,CAAC,UAAU,EAAE;IACnC;IAEA;;;GAGC,GACD,OAAO,YAAkB;QACvB,CAAA,GAAA,yCAAc,AAAD,EACX;IAGJ;IAEA;;;;;;;;;;;GAWC,GACD,IAAI,YAAiB;QACnB,OAAO,IAAI,CAAC,UAAU;IACxB;AAKF;IAEA,2CAAe;;ADhGf;AGAA;;ACAO,MAAM,2CAAsB;IACjC;IAAK;IAAM;IAAK;IAAK;IAAM;IAAM;IAAK;IAAM;IAAK;IAAK;IAAM;IAAM;IAAK;IAAM;CAC9E;AAEM,MAAM,4CAAsB;IACjC;IAAO;IAAM;IAAO;IAAM;IAAO;IAAM;IAAM;IAAO;IAAM;IAAO;IAAO;IAAM;CAC/E;AAEM,MAAM,4CAAgD;IAC3D,IAAI;QACF,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,IAAI;IACtC;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,IAAI;IAC9B;IACA,IAAI;QACF,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,IAAI;QACF,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,MAAM;QACJ,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,IAAI;IAC9C;IACA,MAAM;QACJ,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IACrC;IACA,IAAI;QACF,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IACrC;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,IAAI;IACtC;IACA,MAAM;QACJ,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,IAAI;QACF,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,GAAG;IAC7B;IACA,GAAG;QACD,GAAG;QAAK,GAAG;QAAK,GAAG;QAAK,IAAI;IAC9B;IACA,IAAI;QAAE,GAAG;QAAO,GAAG;QAAM,GAAG;IAAK;IACjC,KAAK;QACH,GAAG;QAAM,GAAG;QAAO,GAAG;QAAM,GAAG;IACjC;IACA,IAAI;QAAE,GAAG;QAAM,GAAG;QAAO,GAAG;IAAK;IACjC,IAAI;QACF,GAAG;QAAM,GAAG;QAAM,GAAG;QAAO,GAAG;IACjC;IACA,OAAO;QACL,GAAG;QAAM,GAAG;QAAM,GAAG;QAAO,GAAG;IACjC;IACA,IAAI;QAAE,GAAG;QAAM,GAAG;QAAM,GAAG;IAAM;IACjC,KAAK;QAAE,GAAG;QAAM,GAAG;QAAM,GAAG;IAAK;IACjC,OAAO;QAAE,GAAG;QAAM,GAAG;QAAM,GAAG;IAAK;AACrC;;;;AD7DO,SAAS,0CAAkB,YAAoB,EAAE,OAAe,EAAU;IAC/E,IAAI,QAAQ,IAAI,CAAC,eACf,OAAO,SAAS,cAAc;IAGhC,OAAO,CAAA,GAAA,wCAAE,EAAE,QAAQ,CAAC,SAAS;AAC/B;AAEA,SAAS,6CAAuB,IAAY,EAAE,YAA2B,EAAE,OAAe,EAAE,SAAqB,EAAE;IACjH,IAAI,YAAY,KAAM,CAAA,QAAQ,CAAA;IAE9B,IAAI,SAAS;QACX,IAAI,cACF,aAAa,0CAAkB,cAAc;QAG/C,IAAI,WACF,aAAa,CAAA,GAAA,wCAAG,AAAD,EAAE,QAAQ,CAAC,SAAS;IAEvC,CAAC;IAED,OAAO;AACT;AAQO,SAAS,0CACd,WAAmB,EACnB,IAAU,EACV,IAAU,EACV,aACE,YAAY,IAAI,uBAChB,qBAAqB,KAAK,oBAC1B,kBAAkB,IAAI,GACH,GAAG,CAAC,CAAC,EAClB;IACR,MAAM,QAAQ,CAAA,GAAA,wCAAK,AAAD,EAAE,KAAK,CAAC;IAC1B,MAAM,UAAU,KAAK,GAAG;IACxB,MAAM,OAAO,SAAS,KAAK,QAAQ,CAAC,SAAS,CAAC,CAAA,GAAA,yCAAI,AAAD,IAAI;IAErD,IAAI,CAAC,OACH,OAAO;IAGT,MAAM,6BAA6B,6CAAuB,MAAM,KAAK,YAAY,EAAE,SAAS;IAC5F,MAAM,eAAe,aAAa,CAAA,GAAA,wCAAE,EAAE,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG,UAAU,+BAA+B,IAAI;IAC/G,MAAM,kBAAkB,MAAM,SAAS,CAAC;IACxC,MAAM,kBAAmB,kBAAkB,gBAAgB,SAAS,CAAC,gBAAgB,eAAe;IAEpG,OAAO,gBAAgB,QAAQ,CAAC;4BAAE;IAAmB;AACvD;AAQO,SAAS,yCAAS,GAAiB,EAA0B;IAClE,OAAO,CAAA,GAAA,yCAAK,AAAD,CAAC,CAAC,CAAA,GAAA,wCAAG,AAAD,EAAE,QAAQ,CAAC,KAAK;AACjC;AAOO,SAAS,0CAAQ,GAAiB,EAAY;IACnD,MAAM,SAAS,CAAA,GAAA,wCAAG,AAAD,EAAE,UAAU,CAAC;IAC9B,OAAO,OAAO,OAAO,KAAK,CAAA,GAAA,yCAAS,AAAD,IAAI,CAAA,GAAA,wCAAQ,CAAC;AACjD;;ADjFA;AGAA;;;;;AA0BO,MAAM,4CAAoB,CAAC,OAAwB,gBAAgB,CAAA,GAAA,wCAAe,AAAD;AAEjF,MAAM,4CAAkB,CAAC,OAAwB,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,OAAe,KAAK,YAAY;AAElG,MAAM,4CAAQ,CAAC,OAAwB,gBAAgB,CAAA,GAAA,wCAAG,AAAD;AAEzD,MAAM,4CAAY,CAAC,OAAuB,KAAK,IAAI,KAAK;AAExD,SAAS,yCAAU,MAAc,EAAU;IAChD,OAAO,OAAO,IAAI,GAAG,OAAO,CAAC,uBAAuB,QAAQ,OAAO,CAAC,YAAY;AAClF;AAEO,SAAS,0CAAK,UAAiB,EAAE,QAAsB,EAAU;IACtE,OAAO,WAAW,GAAG,CAAC,UAAU,IAAI,CAAC;AACvC;AAEO,SAAS,0CAAK,SAAc,EAAE,QAAsB,EAAU;IACnE,OAAO,YAAY,aAAa,EAAE;AACpC;AAEO,SAAS,0CAAK,SAAgB,EAAE,QAAsB,EAAU;IACrE,OAAO,SAAS,IAAI,CAAC,IAAI,EAAE;AAC7B;AAEO,MAAM,4CAAkB,CAAC,OAC9B,KAAK,KAAK,CAAC,IAAI,CAAC,CAAC,OACf,AAAC,gBAAgB,CAAA,GAAA,wCAAe,AAAD,KAAK,CAAC,CAAA,GAAA,yCAAY,EAAE,KAAK,MAAM,KAC1D,gBAAgB,CAAA,GAAA,wCAAE,KAAK,KAAK,YAAY,MACzC,CAAA,GAAA,yCAAY,EAAE;AAId,MAAM,0CAAc,CAAC,OAAuB;IACjD,MAAM,UAAU;QAAC;KAAM;IAEvB,IAAI,CAAC,0CAAgB,OACnB,QAAQ,IAAI,CAAC;IAGf,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEO,MAAM,4CAAmB,CAAC,YAAiC;IAChE,MAAM,UAAU;QAAC;KAAY;IAE7B,IAAI,UAAU,IAAI,KAAK,CAAA,GAAA,yCAAY,KAAK,UAAU,IAAI,KAAK,CAAA,GAAA,yCAAI,AAAD,GAC5D,QAAQ,IAAI,CAAC,UAAU,IAAI;IAG7B,OAAO,QAAQ,IAAI,CAAC;AACtB;AAEO,MAAM,4CAAW,CAAC,MAAmB,UAAoB,gBAAyC;IACvG,IAAI,CAAC,UACH,MAAM,IAAI,MAAM,qCAAqC;IAGvD,OAAO,KAAK,QAAQ,CAAC,UAAU,cAAc,GAAG,CAAC;AACnD;AAEO,SAAS,0CAAa,IAAU,EAAE;IACvC,MAAM,YAAY,KAAK,WAAW;IAElC,IAAI,WACF,OAAO,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;IAGhC,OAAO;AACT;;;IH7EA,2CAAe,CACb,iBACE,cAAa,EACb,eAAe,OACb,IAAG,EACJ,CAAA,QACD,KAAI,oBACJ,mBAAmB,KAAK,GACxB,MAAM,SACJ,MAAK,YACL,SAAQ,YACR,SAAQ,EACT,CAAA,kBACD,eAAc,EACG,GACR,CAAA,GAAA,wCAAS,AAAD,EAAE,CAAC;EACtB,EAAG,CAAA,GAAA,yCAAI,AAAD,EAAE,OAAO,IAAM,CAAC,IAAI,EAAG,MAAO,KAAK,CAAC,EAAG;EAC7C,EAAG,CAAA,GAAA,yCAAI,AAAD,EAAE,UAAU,IAAM,CAAC,IAAI,EAAG,SAAU,KAAK,CAAC,EAAG;;;IAGjD,EAAG,CAAA,GAAA,yCAAG,EAAE,gBAAgB,CAAC,YAAc,CAAC;kBAC1B,EAAG,CAAA,GAAA,yCAAgB,AAAD,EAAE,WAAY;QAC1C,EAAG,CAAA,GAAA,yCAAG,EAAE,UAAU,KAAK,EAAE,CAAC,OAAS,CAAC;UAClC,EAAG,CAAA,GAAA,yCAAI,AAAD,EAAE,oBAAoB,CAAA,GAAA,yCAAe,AAAD,EAAE,OAAO,IAAM,CAAC;wBAC5C,EAAG,CAAA,GAAA,uCAAW,AAAD,EAAE,MAAO;cAChC,EAAG,CAAA,GAAA,yCAAG,EAAE,KAAK,KAAK,EAAE,CAAC,OAAS,CAAC;gBAC7B,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAgB,EAAE,OAAO,IAAM,CAAC;;sCAElB,EAAG,CAAA,GAAA,yCAAW,EAAE,KAAK,SAAS,EAAG,CAAC,EAClD,CAAA,GAAA,yCAAW,AAAD,EACR,KAAK,MAAM,EACX,MACA,MACA;4BACE,WAAW;4BACX,oBAAoB,cAAc,mBAAmB;4BACrD,iBAAiB,cAAc,eAAe;wBAChD,GAEH;uCACkB,EAAG,CAAA,GAAA,yCAAW,EAAE,KAAK,QAAQ,EAAG,CAAC,EAAG,KAAK,MAAM,CAAE;;gBAExE,CAAC,EAAG;;gBAEJ,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAI,EAAE,OAAO,IAAM,CAAC;kBAC1B,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAQ,EAAE,OAAO,IAAM,CAAC;yCACT,EAAG,KAAK,KAAK,CAAE;kBACtC,CAAC,EAAG;;kBAEJ,EAAG,CAAA,GAAA,yCAAG,EAAE,KAAK,kBAAkB,IAAI,IAAM,CAAC;sCACtB,EAAG,KAAK,KAAK,CAAE;kBACnC,CAAC,EAAG;gBACN,CAAC,EAAG;;gBAEJ,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAY,EAAE,OAAO,IAAM,CAAC;;;uCAGb,EAAG,CAAA,GAAA,yCAAW,EAAE,KAAK,QAAQ,EAAG,CAAC,EAAG,CAAA,GAAA,yCAAO,EAAE,MAAM,UAAU,eAAgB;;gBAEpG,CAAC,EAAG;cACN,CAAC,EAAG;;UAER,CAAC,EAAG;QACN,CAAC,EAAG;;IAER,CAAC,EAAG;;AAER,CAAC;;;;AFhFM,MAAM,4CAAkB;IAC7B,2BAA2B;QACzB,cAAc;IAChB;IAEA,cAAc;QACZ,cAAc;IAChB;IAEA,QAAQ;QACN,SAAS;IACX;IAEA,gBAAgB;QACd,SAAS;IACX;IAEA,iBAAiB;QACf,SAAS;IACX;AACF;AAOO,SAAS,0CAAU,KAAa,EAAU;IAC/C,OAAO,CAAA,GAAA,yCAAQ,AAAD,EAAE,2CAAY;AAC9B;AAEA;;CAEC,GACD,MAAM,+CAAyB,CAAA,GAAA,wCAAa,AAAD;IACzC,IAAI,WAAqB;QACvB,OAAO,GAAA,wCAAQ;IACjB;IAEA,IAAI,aAAkB;QACpB,OAAO;IACT;AACF;IAEA,2CAAe;;;AMhDf;ACAA;;;IAmBA,2CAAe,CACb,iBACE,cAAa,EACb,eAAe,OACb,IAAG,EACJ,CAAA,QACD,KAAI,oBACJ,mBAAmB,KAAK,GACxB,MAAM,SACJ,MAAK,YACL,SAAQ,aACR,UAAS,YACT,SAAQ,EACT,CAAA,kBACD,eAAc,EACG,GACR,CAAA,GAAA,wCAAS,AAAD,EAAE,CAAC;EACtB,EAAG,CAAA,GAAA,yCAAI,AAAD,EAAE,OAAO,IAAM,CAAC,IAAI,EAAG,MAAM,KAAK,CAAC,EAAG;EAC5C,EAAG,CAAA,GAAA,yCAAI,AAAD,EAAE,UAAU,IAAM,CAAC,IAAI,EAAG,SAAS,KAAK,CAAC,EAAG;;EAElD,EAAG,CAAA,GAAA,yCAAG,EAAE,UAAU,MAAM,GAAG,GAAG,IAAM,CAAC;;MAEjC,EAAG,CAAA,GAAA,yCAAG,EAAE,gBAAgB,CAAC,YAAc,CAAC;oBAC1B,EAAG,CAAA,GAAA,yCAAgB,AAAD,EAAE,WAAW;UACzC,EAAG,CAAA,GAAA,yCAAG,EAAE,UAAU,KAAK,EAAE,CAAC,OAAS,CAAC;YAClC,EAAG,CAAA,GAAA,yCAAI,AAAD,EAAE,oBAAoB,CAAA,GAAA,yCAAe,AAAD,EAAE,OAAO,IAAM,CAAC;4BAC1C,EAAG,CAAA,GAAA,uCAAW,AAAD,EAAE,MAAM;gBACjC,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAe,EAAE,OAAO,IAAM,CAAC;;oBAEnC,EAAG,CAAA,GAAA,yCAAG,EAAE,KAAK,KAAK,EAAE,CAAC,OAAS,CAAC;sBAC7B,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAgB,EAAE,OAAO,IAAM,CAAC;yCACrB,EAAE,CAAA,GAAA,yCAAW,EAAE,KAAK,SAAS,EAAE,CAAC,EAC/C,CAAA,GAAA,yCAAW,AAAD,EACR,KAAK,MAAM,EACX,MACA,MACA;oCACE,WAAW;oCACX,oBAAoB,cAAc,mBAAmB;oCACrD,iBAAiB,cAAc,eAAe;gCAChD,GAEH;sBACH,CAAC,EAAE;oBACL,CAAC,EAAE;;gBAEP,CAAC,EAAE;;gBAEH,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAc,EAAE,OAAO,IAAM,CAAC;;oBAElC,EAAG,CAAA,GAAA,yCAAG,EAAE,KAAK,KAAK,EAAE,CAAC,OAAS,CAAC;sBAC7B,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAgB,EAAE,OAAO,IAAM,CAAC;0CACpB,EAAE,CAAA,GAAA,yCAAW,EAAE,KAAK,QAAQ,EAAE,CAAC,EAAG,KAAK,MAAM,CAAC;sBAClE,CAAC,EAAE;;sBAEH,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAI,EAAE,OAAO,IAAM,CAAC;wBAC1B,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAQ,EAAE,OAAO,IAAM,CAAC;6CACX,EAAE,CAAA,GAAA,yCAAW,EAAE,KAAK,QAAQ,EAAE,CAAC,EAAG,KAAK,KAAK,CAAE;wBACnE,CAAC,EAAG;;wBAEJ,EAAG,CAAA,GAAA,yCAAG,EAAE,KAAK,kBAAkB,IAAI,IAAM,CAAC;+CACnB,EAAE,CAAA,GAAA,yCAAW,EAAE,KAAK,QAAQ,EAAE,CAAC,EAAG,KAAK,KAAK,CAAE;wBACrE,CAAC,EAAG;sBACN,CAAC,EAAG;;sBAEJ,EAAG,CAAA,GAAA,yCAAG,EAAE,CAAA,GAAA,yCAAY,EAAE,OAAO,IAAM,CAAC;0CAChB,EAAE,CAAA,GAAA,yCAAW,EAAE,KAAK,QAAQ,EAAE,CAAC,EAAG,CAAA,GAAA,yCAAO,EAAE,MAAM,UAAU,eAAgB;sBAC/F,CAAC,EAAG;oBACN,CAAC,EAAE;;gBAEP,CAAC,EAAE;;YAEP,CAAC,EAAE;UACL,CAAC,EAAE;;MAEP,CAAC,EAAE;;EAEP,CAAC,EAAE;AACL,CAAC;;;;ADxFM,MAAM,4CAAkB;IAC7B,IAAI;QACF,UAAU;IACZ;IACA,IAAI;QACF,UAAU;IACZ;IACA,OAAO;QACL,eAAe;QACf,OAAO;IACT;IACA,IAAI;QACF,SAAS;IACX;IACA,2BAA2B;QACzB,cAAc;IAChB;IACA,cAAc;QACZ,cAAc;IAChB;AACF;AAOO,SAAS,0CAAU,KAAa,EAAU;IAC/C,OAAO,CAAA,GAAA,yCAAQ,AAAD,EAAE,2CAAY;AAC9B;AAEA;;;CAGC,GACD,MAAM,iDAA2B,CAAA,GAAA,wCAAa,AAAD;IAC3C,IAAI,WAAqB;QACvB,OAAO,GAAA,wCAAQ;IACjB;IAEA,IAAI,aAAkB;QACpB,OAAO;IACT;AACF;IAEA,2CAAe;;;;;;;;;;AEtDf;;;;;;;AAYA;;CAEC,GACD,MAAM,4CAAsB,CAAA,GAAA,wCAAS,AAAD;IAClC,OAAa,IAAI,CAAA,GAAA,wCAAG,IAAI;IAExB;;;;GAIC,GACD,OAAO,IAAU,EAAU;QACzB,IAAI,CAAC,IAAI,GAAG;QAEZ,OAAO;YACL,IAAI,CAAC,YAAY;YACjB,IAAI,CAAC,gBAAgB;SACtB,CAAC,IAAI,CAAC;IACT;IAEA,eAAuB;QACrB,MAAM,SAAE,MAAK,YAAE,SAAQ,EAAE,GAAG,IAAI,CAAC,IAAI;QACrC,MAAM,YAAY,AAAC,SAAS,WAAY,OAAO,EAAE;QAEjD,OAAO;YACL,IAAI,CAAC,WAAW,CAAC;YACjB,IAAI,CAAC,cAAc,CAAC;YACpB;SACD,CAAC,IAAI,CAAC;IACT;IAEA,mBAA2B;QACzB,MAAM,kBAAE,eAAc,0BAAE,uBAAsB,YAAE,SAAQ,EAAE,GAAG,IAAI,CAAC,IAAI;QACtE,MAAM,yBAAE,sBAAqB,EAAE,GAAG,IAAI,CAAC,aAAa;QAEpD,OAAO,AAAC,CAAA,wBAAwB,yBAAyB,cAAc,AAAD,EACnE,GAAG,CAAC,CAAC,YAAyB,IAAI,CAAC,eAAe,CAAC,WAAW,WAC9D,IAAI,CAAC;IACV;IAEA,gBAAgB,SAAoB,EAAE,QAAkB,EAAU;QAChE,OAAO,UAAU,KAAK,CACnB,MAAM,CAAC,CAAC,OAAS,KAAK,kBAAkB,IACxC,GAAG,CAAC,CAAC,OAAS,IAAI,CAAC,UAAU,CAAC,MAAM,WACpC,IAAI,CAAC;IACV;IAEA,WAAW,IAAU,EAAE,QAAkB,EAAU;QACjD,MAAM,QAAQ;YACZ,IAAI,CAAC,aAAa,CAAC,MAAM;YACzB,IAAI,CAAC,gBAAgB,CAAC,MAAM;SAC7B;QAED,OAAO,MACJ,MAAM,CAAC,CAAC,IAAM,CAAC,CAAA,GAAA,yCAAa,AAAD,EAAE,IAC7B,GAAG,CAAC,CAAC,OAAS,AAAC,CAAA,QAAQ,EAAC,EAAG,SAAS,IACpC,IAAI,CAAC;IACV;IAEA,YAAY,KAAa,EAAU;QACjC,IAAI,OACF,OAAO,CAAC,EAAE,MAAM,WAAW,GAAG,EAAE,CAAC;QAGnC,OAAO;IACT;IAEA,eAAe,QAAgB,EAAU;QACvC,IAAI,UACF,OAAO,CAAC,EAAE,SAAS,EAAE,CAAC;QAGxB,OAAO;IACT;IAEA,cAAc,IAAU,EAAE,QAAkB,EAAiB;QAC3D,IAAI,CAAA,GAAA,yCAAgB,AAAD,EAAE,OACnB,OAAO,IAAI,CAAC,uBAAuB,CAAC,MAAM,IAAI,CAAC,aAAa,EAAE;QAGhE,OAAO,IAAI;IACb;IAEA,sBAAsB,eAAgC,EAAE,IAAU,EAAU;QAC1E,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC,iBAAiB;QAClD,MAAM,UAAE,OAAM,EAAE,GAAG;QACnB,MAAM,eAAe,AAAC,CAAA,UAAU,EAAC,EAAG,MAAM;QAC1C,MAAM,eAAe,AAAC,CAAA,UAAU,EAAC,EAAG,MAAM;QAE1C,IAAI,gBAAgB,cAClB,OAAO,eAAe;QAGxB,OAAO,KAAK,GAAG,CAAC,cAAc;IAChC;IAEQ,aAAa,eAAgC,EAAE,IAAU,EAAE;QACjE,MAAM,SAAS,CAAA,GAAA,yCAAU,EACvB,gBAAgB,MAAM,EACtB,MACA,IAAI,CAAC,IAAI,EACT;YACE,WAAW,IAAI,CAAC,aAAa,CAAC,GAAG;YACjC,oBAAoB,IAAI,CAAC,aAAa,CAAC,mBAAmB;YAC1D,iBAAiB,IAAI,CAAC,aAAa,CAAC,eAAe;QACrD;QAEF,OAAO;IACT;IAEA,cAAc,IAAU,EAAE,SAAmB,EAAE,IAAU,EAAU;QACjE,IAAI,gBAAgB,CAAA,GAAA,wCAAG,AAAD,KAAK,KAAK,YAAY,IAC1C,OAAO,KAAK,KAAK,IAAI;QAGvB,IAAI,gBAAgB,CAAA,GAAA,wCAAc,GAAG;YACnC,MAAM,SAAS,IAAI,CAAC,YAAY,CAAC,MAAM;YACvC,OAAO,CAAA,GAAA,yCAAM,EAAE,QAAQ,IAAI,CAAC,qBAAqB,CAAC,MAAM;QAC1D,CAAC;QAED,OAAO;IACT;IAEA,iBAAiB,IAAU,EAAE,QAAkB,EAAU;QACvD,IAAI,CAAA,GAAA,yCAAe,AAAD,EAAE,OAClB,OAAO,IAAI,CAAC,uBAAuB,CAAC,MAAM,IAAI,CAAC,gBAAgB,EAAE;QAGnE,OAAO;IACT;IAEA,wBACE,IAAU,EACV,SAAoE,EACpE,QAAkB,EACV;QACR,OAAO,KACJ,KAAK,CACL,GAAG,CAAC,CAAC,OAAS,UAAU,IAAI,CAAC,IAAI,EAAE,MAAM,UAAU,OACnD,IAAI,CAAC;IACV;IAEA,iBAAiB,IAAU,EAAE,QAAkB,EAAE,IAAU,EAAU;QACnE,IAAI,gBAAgB,CAAA,GAAA,wCAAG,AAAD,KAAK,KAAK,YAAY,IAC1C,OAAO,KAAK,KAAK,IAAI;QAGvB,IAAI,gBAAgB,CAAA,GAAA,wCAAe,AAAD,GAChC,OAAO,CAAA,GAAA,yCAAO,AAAD,EAAE,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,qBAAqB,CAAC,MAAM;QAGrE,IAAI,cAAc,MAChB,OAAO,KAAK,QAAQ,CAAC,UAAU,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC;QAGxD,OAAO;IACT;AACF;IAEA,2CAAe;;;AC3Kf;;;AAWA,MAAM,yCAAmB;AACzB,MAAM,0CAAoB;AAC1B,MAAM,kDAA4B;AAElC,MAAM,yCAAmB;IACvB,CAAC,CAAA,GAAA,yCAAI,EAAE,EAAE,CAAA,GAAA,yCAAa;IACtB,CAAC,CAAA,GAAA,yCAAK,EAAE,EAAE,CAAA,GAAA,yCAAc;AAC1B;AAEA,MAAM,uCAAiB;IACrB,CAAC,CAAA,GAAA,yCAAI,EAAE,EAAE,CAAA,GAAA,yCAAW;IACpB,CAAC,CAAA,GAAA,yCAAK,EAAE,EAAE,CAAA,GAAA,yCAAY;AACxB;AAEA;;;CAGC,GACD,MAAM,mDAA6B,CAAA,GAAA,wCAAgB,AAAD;IAChD,qBAAoC,IAAI,CAAC;IAEzC,UAAU,IAAI,EAAQ;QACpB,IAAI,IAAI,CAAC,YAAY,IACnB,IAAI,CAAC,UAAU;QAGjB,IAAI,uCAAiB,IAAI,CAAC,OAAO;YAC/B,IAAI,CAAC,YAAY;YACjB,IAAI,CAAC,YAAY,CAAC,CAAA,GAAA,yCAAK,AAAD;QACxB,OAAO,IAAI,wCAAkB,IAAI,CAAC,OAAO;YACvC,IAAI,CAAC,YAAY;YACjB,IAAI,CAAC,YAAY,CAAC,CAAA,GAAA,yCAAM,AAAD;QACzB,OAAO,IAAI,gDAA0B,IAAI,CAAC,OACxC,IAAI,CAAC,iBAAiB,CAAC;aAEvB,KAAK,CAAC,SAAS,CAAC;IAEpB;IAEQ,kBAAkB,IAAI,EAAE;QAC9B,IAAI,CAAC,YAAY;QACjB,IAAI,CAAC,UAAU;QACf,MAAM,UAAU,KAAK,KAAK,CAAC,gDAA0B,CAAC,EAAE;QAExD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,MAAM,IAAI,MAAM,wCAAwC;QAE5E,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAA,GAAA,wCAAE,EAAE,CAAA,GAAA,yCAAM,GAAG;IACxC;IAEA,eAAwB;QACtB,OAAO,IAAI,CAAC,QAAQ,KAAK,IAAI,IACxB,IAAI,CAAC,QAAQ,CAAC,OAAO,MACrB,IAAI,CAAC,IAAI,CAAC,YAAY,KAAK,IAAI,IAC/B,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO;IACtC;IAEA,YAAY;QACV,KAAK,CAAC,SAAS;QACf,IAAI,IAAI,CAAC,kBAAkB,KAAK,IAAI,IAAI,IAAI,CAAC,kBAAkB,IAAI,sCACjE,IAAI,CAAC,YAAY;QAEnB,IAAI,CAAC,UAAU,CAAC;YAAE,YAAY,KAAK;QAAC;IACtC;IAEA,aAAa,WAAW,EAAE;QACxB,IAAI,IAAI,CAAC,kBAAkB,EACzB,IAAI,CAAC,UAAU;QAGjB,IAAI,CAAC,kBAAkB,GAAG;QAC1B,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC;QAE/B,IAAI,eAAe,wCACjB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAA,GAAA,wCAAE,EAAE,sCAAgB,CAAC,YAAY;IAE1D;IAEA,WAAW,cAAE,aAAa,IAAI,GAAE,GAAG,CAAC,CAAC,EAAE;QACrC,IAAI,IAAI,CAAC,kBAAkB,KAAK,IAAI,IAAI,IAAI,CAAC,kBAAkB,IAAI,sCAAgB;YACjF,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAA,GAAA,wCAAE,EAAE,oCAAc,CAAC,IAAI,CAAC,kBAAkB,CAAC;YAEhE,IAAI,YACF,IAAI,CAAC,YAAY;QAErB,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAA,GAAA,yCAAG;QAClC,IAAI,CAAC,kBAAkB,GAAG,IAAI;IAChC;IAEA,eAAe;QACb,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO;IACnC;AACF;IAEA,2CAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;;I/C5Cf,2CAAe;qBACb;uBACA;oBACA;sBACA;0BACA;2BACA;aACA;eACA;sBACA;wBACA;UACA;aACA;cACA;eACA;UACA;SACA;aACA;mBACA;0BACA;YACA;mBACA;UACA;SACA;WACA;AACF","sources":["src/index.ts","src/chord_sheet/chord_lyrics_pair.ts","src/chord.ts","src/parser/chord_peg_parser.ts","src/key.ts","src/note.ts","src/constants.ts","src/normalize_mappings/enharmonic-normalize.ts","src/utilities.ts","src/normalize_mappings/suffix-normalize-mapping.ts","src/formatter/chord_pro_formatter.ts","src/formatter/formatter.ts","src/formatter/configuration/configuration.ts","src/formatter/configuration/metadata_configuration.ts","src/chord_sheet/tag.ts","src/chord_sheet/ast_component.ts","src/chord_sheet/chord_pro/ternary.ts","src/chord_sheet/chord_pro/evaluation_error.ts","src/chord_sheet/chord_pro/composite.ts","src/chord_sheet/chord_pro/evaluatable.ts","src/chord_sheet/chord_pro/literal.ts","src/parser/chord_pro_parser.ts","src/parser/peg_based_parser.ts","src/chord_sheet_serializer.ts","src/chord_sheet/song.ts","src/chord_sheet/line.ts","src/chord_sheet/comment.ts","src/chord_sheet/font.ts","src/chord_sheet/paragraph.ts","src/chord_sheet/metadata.ts","src/chord_sheet/metadata_accessors.ts","src/parser/parser_warning.ts","src/chord_sheet/font_stack.ts","src/chord_sheet/font_size.ts","src/parser/chord_pro_peg_parser.ts","src/parser/chord_sheet_parser.ts","src/parser/chords_over_words_parser.ts","src/parser/chords_over_words_peg_parser.ts","src/formatter/html_div_formatter.ts","src/formatter/html_formatter.ts","src/formatter/templates/html_div_formatter.ts","src/helpers.ts","src/key_config.ts","src/template_helpers.ts","src/formatter/html_table_formatter.ts","src/formatter/templates/html_table_formatter.ts","src/formatter/text_formatter.ts","src/parser/ultimate_guitar_parser.ts"],"sourcesContent":["import ChordLyricsPair from './chord_sheet/chord_lyrics_pair';\nimport ChordProFormatter from './formatter/chord_pro_formatter';\nimport ChordProParser from './parser/chord_pro_parser';\nimport ChordSheetParser from './parser/chord_sheet_parser';\nimport ChordSheetSerializer from './chord_sheet_serializer';\nimport ChordsOverWordsParser from './parser/chords_over_words_parser';\nimport Comment from './chord_sheet/comment';\nimport Composite from './chord_sheet/chord_pro/composite';\nimport HtmlDivFormatter from './formatter/html_div_formatter';\nimport HtmlTableFormatter from './formatter/html_table_formatter';\nimport Line from './chord_sheet/line';\nimport Literal from './chord_sheet/chord_pro/literal';\nimport Metadata from './chord_sheet/metadata';\nimport Paragraph from './chord_sheet/paragraph';\nimport Song from './chord_sheet/song';\nimport Tag from './chord_sheet/tag';\nimport Ternary from './chord_sheet/chord_pro/ternary';\nimport TextFormatter from './formatter/text_formatter';\nimport UltimateGuitarParser from './parser/ultimate_guitar_parser';\n\nimport {\n  CHORUS,\n  INDETERMINATE,\n  NONE,\n  TAB,\n  VERSE,\n} from './constants';\n\nexport { default as Chord, parseChord } from './chord';\nexport { default as ChordLyricsPair } from './chord_sheet/chord_lyrics_pair';\nexport { default as ChordProFormatter } from './formatter/chord_pro_formatter';\nexport { default as ChordProParser } from './parser/chord_pro_parser';\nexport { default as ChordSheetParser } from './parser/chord_sheet_parser';\nexport { default as ChordSheetSerializer } from './chord_sheet_serializer';\nexport { default as ChordsOverWordsParser } from './parser/chords_over_words_parser';\nexport { default as Comment } from './chord_sheet/comment';\nexport { default as Composite } from './chord_sheet/chord_pro/composite';\nexport { default as Formatter } from './formatter/formatter';\nexport { default as HtmlFormatter } from './formatter/html_formatter';\nexport { default as HtmlDivFormatter } from './formatter/html_div_formatter';\nexport { default as HtmlTableFormatter } from './formatter/html_table_formatter';\nexport { default as Key } from './key';\nexport { default as Line } from './chord_sheet/line';\nexport { default as Literal } from './chord_sheet/chord_pro/literal';\nexport { default as Metadata } from './chord_sheet/metadata';\nexport { default as Paragraph } from './chord_sheet/paragraph';\nexport { default as Song } from './chord_sheet/song';\nexport { default as Tag } from './chord_sheet/tag';\nexport { default as Ternary } from './chord_sheet/chord_pro/ternary';\nexport { default as TextFormatter } from './formatter/text_formatter';\nexport { default as UltimateGuitarParser } from './parser/ultimate_guitar_parser';\n\nexport {\n  CHORUS,\n  INDETERMINATE,\n  NONE,\n  NUMERIC,\n  SYMBOL,\n  TAB,\n  VERSE,\n} from './constants';\n\nexport default {\n  ChordLyricsPair,\n  ChordProFormatter,\n  ChordProParser,\n  ChordSheetParser,\n  ChordSheetSerializer,\n  ChordsOverWordsParser,\n  Comment,\n  Composite,\n  HtmlDivFormatter,\n  HtmlTableFormatter,\n  Line,\n  Literal,\n  Metadata,\n  Paragraph,\n  Song,\n  Tag,\n  Ternary,\n  TextFormatter,\n  UltimateGuitarParser,\n  CHORUS,\n  INDETERMINATE,\n  NONE,\n  TAB,\n  VERSE,\n};\n","import Chord from '../chord';\nimport Key from '../key';\n\n/**\n * Represents a chord with the corresponding (partial) lyrics\n */\nclass ChordLyricsPair {\n  chords: string;\n\n  lyrics: string | null;\n\n  /**\n   * Initialises a ChordLyricsPair\n   * @param {string} chords The chords\n   * @param {string} lyrics The lyrics\n   */\n  constructor(chords = '', lyrics: string | null = null) {\n    /**\n     * The chords\n     * @member\n     * @type {string}\n     */\n    this.chords = chords || '';\n\n    /**\n     * The lyrics\n     * @member\n     * @type {string}\n     */\n    this.lyrics = lyrics || '';\n  }\n\n  /**\n   * Indicates whether a ChordLyricsPair should be visible in a formatted chord sheet (except for ChordPro sheets)\n   * @returns {boolean}\n   */\n  isRenderable(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns a deep copy of the ChordLyricsPair, useful when programmatically transforming a song\n   * @returns {ChordLyricsPair}\n   */\n  clone(): ChordLyricsPair {\n    return new ChordLyricsPair(this.chords, this.lyrics);\n  }\n\n  toString(): string {\n    return `ChordLyricsPair(chords=${this.chords}, lyrics=${this.lyrics})`;\n  }\n\n  set({ chords, lyrics }: { chords?: string, lyrics?: string }): ChordLyricsPair {\n    return new ChordLyricsPair(\n      chords || this.chords,\n      lyrics || this.lyrics,\n    );\n  }\n\n  setLyrics(lyrics: string): ChordLyricsPair {\n    return this.set({ lyrics });\n  }\n\n  transpose(\n    delta: number,\n    key: string | Key | null = null,\n    { normalizeChordSuffix }: { normalizeChordSuffix: boolean } = { normalizeChordSuffix: false },\n  ): ChordLyricsPair {\n    const chordObj = Chord.parse(this.chords.trim());\n\n    if (chordObj) {\n      let transposedChord = chordObj.transpose(delta);\n\n      if (key) {\n        transposedChord = transposedChord.normalize(key, { normalizeSuffix: normalizeChordSuffix });\n      }\n\n      return this.set({ chords: transposedChord.toString() });\n    }\n\n    return this.clone();\n  }\n}\n\nexport default ChordLyricsPair;\n","import { parse } from './parser/chord_peg_parser';\nimport Key from './key';\nimport SUFFIX_MAPPING from './normalize_mappings/suffix-normalize-mapping';\nimport { deprecate, isMinor } from './utilities';\nimport {\n  ChordType, Modifier, NUMERAL, NUMERIC, SYMBOL,\n} from './constants';\n\nfunction normalizeChordSuffix(suffix: string | null): string | null {\n  if (suffix === null) {\n    return null;\n  }\n\n  if (SUFFIX_MAPPING[suffix] === '[blank]') {\n    return null;\n  }\n\n  return SUFFIX_MAPPING[suffix] || suffix;\n}\n\ninterface ChordProperties {\n  root?: Key;\n  suffix?: string | null;\n  bass?: Key | null;\n}\n\n/**\n * Represents a Chord, consisting of a root, suffix (quality) and bass\n */\nclass Chord implements ChordProperties {\n  bass: Key | null;\n\n  root: Key;\n\n  suffix: string | null;\n\n  /**\n   * Tries to parse a chord string into a chord\n   * Any leading or trailing whitespace is removed first, so a chord like `  \\n  E/G# \\r ` is valid.\n   * @param chordString the chord string, eg `Esus4/G#` or `1sus4/#3`.\n   * @returns {Chord|null}\n   */\n  static parse(chordString: string): Chord | null {\n    try {\n      return this.parseOrFail(chordString);\n    } catch (_error) {\n      return null;\n    }\n  }\n\n  static parseOrFail(chordString: string): Chord {\n    const ast = parse(chordString.trim());\n    return new Chord(ast);\n  }\n\n  /**\n   * Returns a deep copy of the chord\n   * @returns {Chord}\n   */\n  clone(): Chord {\n    return this.set({});\n  }\n\n  /**\n   * Converts the chord to a chord symbol, using the supplied key as a reference.\n   * For example, a numeric chord `#4` with reference key `E` will return the chord symbol `A#`.\n   * When the chord is already a chord symbol, it will return a clone of the object.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a\n   * numeric or numeral.\n   * @returns {Chord} the chord symbol\n   */\n  toChordSymbol(referenceKey: Key | string | null = null): Chord {\n    if (this.isChordSymbol()) {\n      return this.clone();\n    }\n\n    const keyObj = Key.wrapOrFail(referenceKey);\n\n    let chordSymbolChord = new Chord({\n      suffix: this.suffix ? normalizeChordSuffix(this.suffix) : null,\n      root: this.root.toChordSymbol(keyObj),\n      bass: this.bass?.toChordSymbol(keyObj) || null,\n    });\n\n    if (this.root.isMinor()) {\n      chordSymbolChord = chordSymbolChord.makeMinor();\n    }\n\n    chordSymbolChord = chordSymbolChord.normalize(referenceKey);\n\n    return chordSymbolChord;\n  }\n\n  /**\n   * Converts the chord to a chord symbol string, using the supplied key as a reference.\n   * For example, a numeric chord `#4` with reference key `E` will return the chord symbol `A#`.\n   * When the chord is already a chord symbol, it will return a string version of the chord.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a\n   * numeric or numeral.\n   * @returns {string} the chord symbol string\n   * @see {toChordSymbol}\n   */\n  toChordSymbolString(referenceKey: Key | string | null = null): string {\n    return this.toChordSymbol(referenceKey).toString();\n  }\n\n  /**\n   * Determines whether the chord is a chord symbol\n   * @returns {boolean}\n   */\n  isChordSymbol(): boolean {\n    return this.is(SYMBOL);\n  }\n\n  /**\n   * Converts the chord to a numeric chord, using the supplied key as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeric chord #4.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {Chord} the numeric chord\n   */\n  toNumeric(referenceKey: Key | string | null = null): Chord {\n    if (this.isNumeric()) {\n      return this.clone();\n    }\n\n    if (this.isNumeral()) {\n      return this.transform((key) => key.toNumeric());\n    }\n\n    const keyObj = Key.wrapOrFail(referenceKey);\n\n    return new Chord({\n      suffix: normalizeChordSuffix(this.suffix),\n      root: this.root.toNumeric(keyObj),\n      bass: this.bass?.toNumeric(keyObj) || null,\n    });\n  }\n\n  /**\n   * Converts the chord to a numeral chord, using the supplied key as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeral chord #IV.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {Chord} the numeral chord\n   */\n  toNumeral(referenceKey: Key | string | null = null): Chord {\n    if (this.isNumeral()) {\n      return this.clone();\n    }\n\n    if (this.isNumeric()) {\n      return this.transform((key) => key.toNumeral());\n    }\n\n    const keyObj = Key.wrapOrFail(referenceKey);\n\n    return new Chord({\n      suffix: normalizeChordSuffix(this.suffix),\n      root: keyObj ? this.root.toNumeral(keyObj) : null,\n      bass: this.bass?.toNumeral(keyObj) || null,\n    });\n  }\n\n  /**\n   * Converts the chord to a numeral chord string, using the supplied kye as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeral chord #4.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {string} the numeral chord string\n   * @see {toNumeral}\n   */\n  toNumeralString(referenceKey: Key | string | null = null): string {\n    return this.toNumeral(referenceKey).toString();\n  }\n\n  /**\n   * Determines whether the chord is numeric\n   * @returns {boolean}\n   */\n  isNumeric(): boolean {\n    return this.is(NUMERIC);\n  }\n\n  /**\n   * Converts the chord to a numeric chord string, using the supplied kye as a reference.\n   * For example, a chord symbol A# with reference key E will return the numeric chord #4.\n   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol\n   * @returns {string} the numeric chord string\n   * @see {toNumeric}\n   */\n  toNumericString(referenceKey: Key | string | null = null): string {\n    return this.toNumeric(referenceKey).toString();\n  }\n\n  /**\n   * Determines whether the chord is a numeral\n   * @returns {boolean}\n   */\n  isNumeral(): boolean {\n    return this.is(NUMERAL);\n  }\n\n  /**\n   * Converts the chord to a string, eg `Esus4/G#` or `1sus4/#3`\n   * @param {Object} [configuration={}] options\n   * @param {boolean} [configuration.useUnicodeModifier=false] Whether or not to use unicode modifiers.\n   * This will make `#` (sharp) look like `` and `b` (flat) look like ``\n   * @returns {string} the chord string\n   */\n  toString({ useUnicodeModifier = false } = {}): string {\n    const chordString = this.root.toString({ showMinor: false, useUnicodeModifier }) + (this.suffix || '');\n\n    if (this.bass) {\n      return `${chordString}/${this.bass.toString({ useUnicodeModifier })}`;\n    }\n\n    return chordString;\n  }\n\n  /**\n   * Normalizes the chord root and bass notes:\n   * - Fb becomes E\n   * - Cb becomes B\n   * - B# becomes C\n   * - E# becomes F\n   * - 4b becomes 3\n   * - 1b becomes 7\n   * - 7# becomes 1\n   * - 3# becomes 4\n   *\n   * Besides that it normalizes the suffix if `normalizeSuffix` is `true`.\n   * For example, `sus2` becomes `2`, `sus4` becomes `sus`.\n   * All suffix normalizations can be found in `src/normalize_mappings/suffix-mapping.txt`.\n   *\n   * When the chord is minor, bass notes are normalized off of the relative major\n   * of the root note. For example, `Em/A#` becomes `Em/Bb`.\n   * @param {Key|string} [key=null] the key to normalize to\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeSuffix=true] whether to normalize the chord suffix after transposing\n   * @returns {Chord} the normalized chord\n   */\n  normalize(key: Key | string | null = null, { normalizeSuffix = true } = {}): Chord {\n    const suffix = normalizeSuffix ? normalizeChordSuffix(this.suffix) : this.suffix;\n\n    let bassRootKey = this.root.normalize().normalizeEnharmonics(key);\n    if (this.root.isMinor() && this.bass) {\n      bassRootKey = this.root.transpose(3).removeMinor().normalize();\n    }\n\n    return this.set({\n      suffix,\n      root: this.root.normalize().normalizeEnharmonics(key),\n      bass: this.bass ? this.bass.normalize().normalizeEnharmonics(bassRootKey) : null,\n    });\n  }\n\n  /**\n   * Switches to the specified modifier\n   * @param newModifier the modifier to use: `'#'` or `'b'`\n   * @returns {Chord} the new, changed chord\n   */\n  useModifier(newModifier: Modifier): Chord {\n    return this.transform((key) => key.useModifier(newModifier));\n  }\n\n  /**\n   * Transposes the chord up by 1 semitone. Eg. A becomes A#, Eb becomes E\n   * @returns {Chord} the new, transposed chord\n   */\n  transposeUp(): Chord {\n    return this.transform((key) => key.transposeUp());\n  }\n\n  /**\n   * Transposes the chord down by 1 semitone. Eg. A# becomes A, E becomes Eb\n   * @returns {Chord} the new, transposed chord\n   */\n  transposeDown(): Chord {\n    return this.transform((key) => key.transposeDown());\n  }\n\n  /**\n   * Transposes the chord by the specified number of semitones\n   * @param delta de number of semitones\n   * @returns {Chord} the new, transposed chord\n   */\n  transpose(delta: number): Chord {\n    return this.transform((key) => key.transpose(delta));\n  }\n\n  constructor(\n    {\n      base = null,\n      modifier = null,\n      suffix = null,\n      bassBase = null,\n      bassModifier = null,\n      root = null,\n      bass = null,\n    }: {\n      base?: string | number | null,\n      modifier?: Modifier | null,\n      suffix?: string | null,\n      bassBase?: string | number | null,\n      bassModifier?: Modifier | null,\n      root?: Key | null,\n      bass?: Key | null,\n    },\n  ) {\n    this.suffix = suffix || null;\n    this.root = this.determineRoot(root, base, modifier, suffix);\n    this.bass = this.determineBass(bass, bassBase, bassModifier);\n  }\n\n  determineRoot(root: Key | null, base: string | number | null, modifier: Modifier | null, suffix: string | null): Key {\n    if (root) {\n      return root;\n    }\n\n    if (!base) throw new Error('Expected base');\n\n    return new Key({ note: base, modifier, minor: isMinor(suffix) });\n  }\n\n  determineBass(bass: Key | null, bassBase: string | number | null, bassModifier: Modifier | null): Key | null {\n    if (bass) {\n      return bass;\n    }\n\n    if (bassBase) {\n      return new Key({ note: bassBase, modifier: bassModifier || null, minor: false });\n    }\n\n    return null;\n  }\n\n  makeMinor(): Chord {\n    if (!this.suffix || this.suffix[0] !== 'm') {\n      return this.set({ suffix: `m${this.suffix || ''}` });\n    }\n\n    return this.clone();\n  }\n\n  set(properties: ChordProperties): Chord {\n    return new Chord(\n      {\n        root: this.root.clone(),\n        suffix: this.suffix,\n        bass: this.bass?.clone() || null,\n        ...properties,\n      },\n    );\n  }\n\n  private is(type: ChordType): boolean {\n    return this.root.is(type) && (!this.bass || this.bass.is(type));\n  }\n\n  private transform(transformFunc: (_key: Key) => Key): Chord {\n    return this.set({\n      root: transformFunc(this.root),\n      bass: this.bass ? transformFunc(this.bass) : null,\n    });\n  }\n}\n\n/**\n * Tries to parse a chord string into a chord\n * @param chordString the chord string, eg Esus4/G# or 1sus4/#3\n * @deprecated Please use {@link Chord.parse} instead\n * @returns {Chord|null}\n */\nexport function parseChord(chordString: string): Chord | null {\n  deprecate('parseChord() is deprecated, please use Chord.parse() instead');\n  return Chord.parse(chordString);\n}\n\nexport default Chord;\n","\n// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )\n//\n// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs\n\n\"use strict\";\n\nexport interface FilePosition {\n  offset: number;\n  line: number;\n  column: number;\n}\n\nexport interface FileRange {\n  start: FilePosition;\n  end: FilePosition;\n  source: string;\n}\n\nexport interface LiteralExpectation {\n  type: \"literal\";\n  text: string;\n  ignoreCase: boolean;\n}\n\nexport interface ClassParts extends Array<string | ClassParts> {}\n\nexport interface ClassExpectation {\n  type: \"class\";\n  parts: ClassParts;\n  inverted: boolean;\n  ignoreCase: boolean;\n}\n\nexport interface AnyExpectation {\n  type: \"any\";\n}\n\nexport interface EndExpectation {\n  type: \"end\";\n}\n\nexport interface OtherExpectation {\n  type: \"other\";\n  description: string;\n}\n\nexport type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;\n\nfunction peg$padEnd(str: string, targetLength: number, padString: string) {\n  padString = padString || ' ';\n  if (str.length > targetLength) {\n    return str;\n  }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\nexport class PeggySyntaxError extends Error {\n  public static buildMessage(expected: Expectation[], found: string | null) {\n    function hex(ch: string): string {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\"/g,  \"\\\\\\\"\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function classEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\]/g, \"\\\\]\")\n        .replace(/\\^/g, \"\\\\^\")\n        .replace(/-/g,  \"\\\\-\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function describeExpectation(expectation: Expectation) {\n      switch (expectation.type) {\n        case \"literal\":\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        case \"class\":\n          const escapedParts = expectation.parts.map((part) => {\n            return Array.isArray(part)\n              ? classEscape(part[0] as string) + \"-\" + classEscape(part[1] as string)\n              : classEscape(part);\n          });\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        case \"any\":\n          return \"any character\";\n        case \"end\":\n          return \"end of input\";\n        case \"other\":\n          return expectation.description;\n      }\n    }\n\n    function describeExpected(expected1: Expectation[]) {\n      const descriptions = expected1.map(describeExpectation);\n      let i: number;\n      let j: number;\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found1: string | null) {\n      return found1 ? \"\\\"\" + literalEscape(found1) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  }\n\n  public message: string;\n  public expected: Expectation[];\n  public found: string | null;\n  public location: FileRange;\n  public name: string;\n\n  constructor(message: string, expected: Expectation[], found: string | null, location: FileRange) {\n    super();\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"PeggySyntaxError\";\n\n    if (typeof (Object as any).setPrototypeOf === \"function\") {\n      (Object as any).setPrototypeOf(this, PeggySyntaxError.prototype);\n    } else {\n      (this as any).__proto__ = PeggySyntaxError.prototype;\n    }\n    if (typeof (Error as any).captureStackTrace === \"function\") {\n      (Error as any).captureStackTrace(this, PeggySyntaxError);\n    }\n  }\n\n  format(sources: { grammarSource?: string; text: string }[]): string {\n    let str = 'Error: ' + this.message;\n    if (this.location) {\n      let src: string[] | null = null;\n      let k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].grammarSource === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      let s = this.location.start;\n      let loc = this.location.source + ':' + s.line + ':' + s.column;\n      if (src) {\n        let e = this.location.end;\n        let filler = peg$padEnd('', s.line.toString().length, ' ');\n        let line = src[s.line - 1];\n        let last = s.line === e.line ? e.column : line.length + 1;\n        str += '\\n --> ' + loc + '\\n' + filler + ' |\\n' + s.line + ' | ' + line + '\\n' + filler + ' | ' +\n          peg$padEnd('', s.column - 1, ' ') +\n          peg$padEnd('', last - s.column, '^');\n      } else {\n        str += '\\n at ' + loc;\n      }\n    }\n    return str;\n  }\n}\n\nfunction peg$parse(input: string, options?: ParseOptions) {\n  options = options !== undefined ? options : {};\n\n  const peg$FAILED: Readonly<any> = {};\n  const peg$source = options.grammarSource;\n\n  const peg$startRuleFunctions: {[id: string]: any} = { Chord: peg$parseChord };\n  let peg$startRuleFunction: () => any = peg$parseChord;\n\n  const peg$c0 = function(chord: any): any {\n        return { type: \"chord\", ...chord, column: location().start.column };\n      };\n  const peg$c1 = \"#\";\n  const peg$c2 = peg$literalExpectation(\"#\", false);\n  const peg$c3 = \"b\";\n  const peg$c4 = peg$literalExpectation(\"b\", false);\n  const peg$c5 = /^[a-zA-Z0-9()#+]/;\n  const peg$c6 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"(\", \")\", \"#\", \"+\"], false, false);\n  const peg$c7 = function(root: any, modifier: any, suffix: any, bass: any): any {\n    \t  return { base: root, modifier, suffix, ...bass, chordType: \"symbol\" };\n      };\n  const peg$c8 = /^[A-Ga-g]/;\n  const peg$c9 = peg$classExpectation([[\"A\", \"G\"], [\"a\", \"g\"]], false, false);\n  const peg$c10 = \"/\";\n  const peg$c11 = peg$literalExpectation(\"/\", false);\n  const peg$c12 = function(root: any, modifier: any): any {\n        return { bassBase: root, bassModifier: modifier };\n      };\n  const peg$c13 = function(modifier: any, root: any, suffix: any, bass: any): any {\n        return { base: root, modifier, suffix, ...bass, chordType: \"numeral\" };\n      };\n  const peg$c14 = \"III\";\n  const peg$c15 = peg$literalExpectation(\"III\", false);\n  const peg$c16 = \"iii\";\n  const peg$c17 = peg$literalExpectation(\"iii\", false);\n  const peg$c18 = \"VII\";\n  const peg$c19 = peg$literalExpectation(\"VII\", false);\n  const peg$c20 = \"vii\";\n  const peg$c21 = peg$literalExpectation(\"vii\", false);\n  const peg$c22 = \"II\";\n  const peg$c23 = peg$literalExpectation(\"II\", false);\n  const peg$c24 = \"ii\";\n  const peg$c25 = peg$literalExpectation(\"ii\", false);\n  const peg$c26 = \"IV\";\n  const peg$c27 = peg$literalExpectation(\"IV\", false);\n  const peg$c28 = \"iv\";\n  const peg$c29 = peg$literalExpectation(\"iv\", false);\n  const peg$c30 = \"VI\";\n  const peg$c31 = peg$literalExpectation(\"VI\", false);\n  const peg$c32 = \"vi\";\n  const peg$c33 = peg$literalExpectation(\"vi\", false);\n  const peg$c34 = \"I\";\n  const peg$c35 = peg$literalExpectation(\"I\", false);\n  const peg$c36 = \"i\";\n  const peg$c37 = peg$literalExpectation(\"i\", false);\n  const peg$c38 = \"V\";\n  const peg$c39 = peg$literalExpectation(\"V\", false);\n  const peg$c40 = \"v\";\n  const peg$c41 = peg$literalExpectation(\"v\", false);\n  const peg$c42 = function(modifier: any, root: any): any {\n        return { bassBase: root, bassModifier: modifier };\n      };\n  const peg$c43 = function(modifier: any, root: any, suffix: any, bass: any): any {\n        return { base: root, modifier, suffix, ...bass, chordType: \"numeric\" };\n      };\n  const peg$c44 = /^[1-7]/;\n  const peg$c45 = peg$classExpectation([[\"1\", \"7\"]], false, false);\n\n  let peg$currPos = 0;\n  let peg$savedPos = 0;\n  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  let peg$maxFailPos = 0;\n  let peg$maxFailExpected: Expectation[] = [];\n  let peg$silentFails = 0;\n\n  let peg$result;\n\n  if (options.startRule !== undefined) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text(): string {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location(): FileRange {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description: string, location1?: FileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location1\n    );\n  }\n\n  function error(message: string, location1?: FileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location1);\n  }\n\n  function peg$literalExpectation(text1: string, ignoreCase: boolean): LiteralExpectation {\n    return { type: \"literal\", text: text1, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts: ClassParts, inverted: boolean, ignoreCase: boolean): ClassExpectation {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation(): AnyExpectation {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation(): EndExpectation {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description: string): OtherExpectation {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos: number) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos: number, endPos: number): FileRange {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected1: Expectation) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected1);\n  }\n\n  function peg$buildSimpleError(message: string, location1: FileRange) {\n    return new PeggySyntaxError(message, [], \"\", location1);\n  }\n\n  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: FileRange) {\n    return new PeggySyntaxError(\n      PeggySyntaxError.buildMessage(expected1, found),\n      expected1,\n      found,\n      location1\n    );\n  }\n\n  function peg$parseChord(): any {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseNumeral();\n    if (s1 as any === peg$FAILED) {\n      s1 = peg$parseNumeric();\n      if (s1 as any === peg$FAILED) {\n        s1 = peg$parseChordSymbol();\n      }\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c0(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseChordModifier(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s0 = peg$c1;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c2); }\n    }\n    if (s0 as any === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 98) {\n        s0 = peg$c3;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSuffix(): any {\n    let s0, s1;\n\n    s0 = [];\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    while (s1 as any !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c5.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSymbol(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordSymbolRoot();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordModifier();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseChordSuffix();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseChordSymbolBass();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c7(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSymbolRoot(): any {\n    let s0;\n\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSymbolBass(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c10;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c11); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordSymbolRoot();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseChordModifier();\n        if (s3 as any === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c12(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeral(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordModifier();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNumeralRoot();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseChordSuffix();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseNumeralBass();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeralRoot(): any {\n    let s0;\n\n    if (input.substr(peg$currPos, 3) === peg$c14) {\n      s0 = peg$c14;\n      peg$currPos += 3;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s0 as any === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c16) {\n        s0 = peg$c16;\n        peg$currPos += 3;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c17); }\n      }\n      if (s0 as any === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c18) {\n          s0 = peg$c18;\n          peg$currPos += 3;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s0 as any === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c20) {\n            s0 = peg$c20;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c21); }\n          }\n          if (s0 as any === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c22) {\n              s0 = peg$c22;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s0 as any === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c24) {\n                s0 = peg$c24;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c25); }\n              }\n              if (s0 as any === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c26) {\n                  s0 = peg$c26;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c27); }\n                }\n                if (s0 as any === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c28) {\n                    s0 = peg$c28;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c29); }\n                  }\n                  if (s0 as any === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c30) {\n                      s0 = peg$c30;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n                    }\n                    if (s0 as any === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c32) {\n                        s0 = peg$c32;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c33); }\n                      }\n                      if (s0 as any === peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 73) {\n                          s0 = peg$c34;\n                          peg$currPos++;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c35); }\n                        }\n                        if (s0 as any === peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 105) {\n                            s0 = peg$c36;\n                            peg$currPos++;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c37); }\n                          }\n                          if (s0 as any === peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 86) {\n                              s0 = peg$c38;\n                              peg$currPos++;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n                            }\n                            if (s0 as any === peg$FAILED) {\n                              if (input.charCodeAt(peg$currPos) === 118) {\n                                s0 = peg$c40;\n                                peg$currPos++;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c41); }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeralBass(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c10;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c11); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordModifier();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseNumeralRoot();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c42(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeric(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordModifier();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNumericRoot();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseChordSuffix();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseNumericBass();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c43(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumericRoot(): any {\n    let s0;\n\n    if (peg$c44.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c45); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumericBass(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c10;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c11); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordModifier();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseNumericRoot();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c42(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nexport interface ParseOptions {\n  filename?: string;\n  startRule?: string;\n  tracer?: any;\n  [key: string]: any;\n}\nexport type ParseFunction = (input: string, options?: ParseOptions) => any;\nexport const parse: ParseFunction = peg$parse;\n\n","import Note from './note';\nimport {\n  ChordType, Modifier, NUMERAL, NUMERIC, SYMBOL,\n} from './constants';\nimport ENHARMONIC_MAPPING from './normalize_mappings/enharmonic-normalize';\nimport { isEmptyString } from './utilities';\n\nconst FLAT = 'b';\nconst SHARP = '#';\n\nconst symbolKeyRegex = /^(?<note>[A-G])(?<modifier>#|b)?(?<minor>m)?$/i;\nconst numericKeyRegex = /^(?<modifier>#|b)?(?<note>[1-7])(?<minor>m)?$/;\nconst numeralKeyRegex = /^(?<modifier>#|b)?(?<note>I{1,3}|IV|VI{0,2}|i{1,3}|iv|vi{0,2})$/;\n\nconst regexes = [symbolKeyRegex, numericKeyRegex, numeralKeyRegex];\n\nfunction modifierTransposition(modifier: Modifier | null): number {\n  switch (modifier) {\n    case SHARP: return 1;\n    case FLAT: return -1;\n    default: return 0;\n  }\n}\n\ninterface KeyProperties {\n  note?: Note;\n  modifier?: Modifier | null;\n  minor?: boolean;\n}\n\n/**\n * Represents a key, such as Eb (symbol), #3 (numeric) or VII (numeral).\n *\n * The only function considered public API is `Key.distance`\n */\nclass Key implements KeyProperties {\n  note: Note;\n\n  modifier: Modifier | null = null;\n\n  get unicodeModifier(): string | null {\n    switch (this.modifier) {\n      case FLAT:\n        return '\\u266d';\n      case SHARP:\n        return '\\u266f';\n      default:\n        return null;\n    }\n  }\n\n  minor = false;\n\n  static parse(keyString: string | null): null | Key {\n    if (!keyString || isEmptyString(keyString)) return null;\n\n    for (let i = 0, count = regexes.length; i < count; i += 1) {\n      const match = keyString.match(regexes[i]);\n\n      if (match) {\n        const { note, modifier, minor } = match.groups as { note: string, modifier?: Modifier, minor?: string };\n        return new Key({ note, modifier, minor: !!minor });\n      }\n    }\n\n    return null;\n  }\n\n  static parseOrFail(keyString: string | null): Key {\n    const parsed = this.parse(keyString);\n\n    if (!parsed) throw new Error(`Failed to parse ${keyString}`);\n\n    return parsed;\n  }\n\n  static wrap(keyStringOrObject: Key | string): Key | null {\n    if (keyStringOrObject instanceof Key) return keyStringOrObject;\n\n    return this.parse(keyStringOrObject);\n  }\n\n  static wrapOrFail(keyStringOrObject: Key | string | null = null): Key {\n    if (keyStringOrObject === null) throw new Error('Unexpected null key');\n\n    const wrapped = this.wrap(keyStringOrObject);\n\n    if (wrapped === null) throw new Error(`Failed: invalid key ${keyStringOrObject}`);\n\n    return wrapped;\n  }\n\n  static toString(keyStringOrObject: Key | string) {\n    return `${Key.wrapOrFail(keyStringOrObject)}`;\n  }\n\n  /**\n   * Calculates the distance in semitones between one key and another.\n   * @param {Key | string} oneKey the key\n   * @param {Key | string} otherKey the other key\n   * @return {number} the distance in semitones\n   */\n  static distance(oneKey: Key | string, otherKey: Key | string): number {\n    return this.wrapOrFail(oneKey).distanceTo(otherKey);\n  }\n\n  distanceTo(otherKey: Key | string): number {\n    const otherKeyObj = Key.wrapOrFail(otherKey);\n    let key = this.useModifier(otherKeyObj.modifier);\n    let delta = 0;\n\n    while (!key.equals(otherKeyObj) && delta < 20) {\n      key = key.transposeUp().useModifier(otherKeyObj.modifier);\n      delta += 1;\n    }\n\n    return delta;\n  }\n\n  constructor(\n    { note, modifier = null, minor = false }:\n      { note: Note | string | number, modifier?: Modifier | null, minor?: boolean },\n  ) {\n    this.note = (note instanceof Note) ? note : Note.parse(note);\n    this.modifier = modifier || null;\n    this.minor = minor || false;\n\n    if (this.minor) this.note.minor = true;\n  }\n\n  isMinor(): boolean {\n    return this.minor || this.note.isMinor();\n  }\n\n  clone(): Key {\n    return this.set({});\n  }\n\n  toChordSymbol(key: Key): Key {\n    if (this.is(SYMBOL)) return this.clone();\n\n    const transposeDistance = this.note.getTransposeDistance(key.minor) + modifierTransposition(this.modifier);\n\n    return key.transpose(transposeDistance).normalize().useModifier(key.modifier);\n  }\n\n  toChordSymbolString(key: Key): string {\n    return this.toChordSymbol(key).toString();\n  }\n\n  is(type: ChordType): boolean {\n    return this.note.is(type);\n  }\n\n  isNumeric(): boolean {\n    return this.is(NUMERIC);\n  }\n\n  isChordSymbol(): boolean {\n    return this.is(SYMBOL);\n  }\n\n  isNumeral(): boolean {\n    return this.is(NUMERAL);\n  }\n\n  equals(otherKey: Key): boolean {\n    return this.note.equals(otherKey.note) && this.modifier === otherKey.modifier;\n  }\n\n  toNumeric(key: Key | null = null): Key {\n    if (this.isNumeric()) return this.clone();\n\n    if (this.isNumeral()) return this.set({ note: this.note.toNumeric() });\n\n    if (!key) throw new Error('key is required');\n\n    return this.transposeNoteUpToKey(1, key);\n  }\n\n  toNumericString(key: Key | null = null): string {\n    return this.toNumeric(key).toString();\n  }\n\n  toNumeral(key: Key | null = null): Key {\n    if (this.isNumeral()) return this.clone();\n\n    if (this.isNumeric()) return this.set({ note: this.note.toNumeral() });\n\n    if (key) return this.transposeNoteUpToKey('I', key);\n\n    return this.clone();\n  }\n\n  toNumeralString(key: Key | null = null): string {\n    return this.toNumeral(key).toString();\n  }\n\n  toString({ showMinor = true, useUnicodeModifier = false } = {}): string {\n    switch (this.note.type) {\n      case SYMBOL:\n        return this.formatChordSymbolString(showMinor, useUnicodeModifier);\n      case NUMERIC:\n        return this.formatNumericString(showMinor);\n      case NUMERAL:\n        return this.formatNumeralString();\n      default:\n        throw new Error(`Unexpected note type ${this.note.type}`);\n    }\n  }\n\n  private formatChordSymbolString(showMinor: boolean, unicodeModifier: boolean): string {\n    const modifier = unicodeModifier ? this.unicodeModifier : this.modifier;\n    return `${this.note}${modifier || ''}${this.minor && showMinor ? 'm' : ''}`;\n  }\n\n  private formatNumericString(showMinor: boolean): string {\n    return `${this.modifier || ''}${this.note}${this.minor && showMinor ? 'm' : ''}`;\n  }\n\n  private formatNumeralString(): string {\n    return `${this.modifier || ''}${this.note}`;\n  }\n\n  transpose(delta: number): Key {\n    if (delta === 0) return this;\n\n    const originalModifier = this.modifier;\n    let transposedKey = this.clone();\n    const func = (delta < 0) ? 'transposeDown' : 'transposeUp';\n\n    for (let i = 0, count = Math.abs(delta); i < count; i += 1) {\n      transposedKey = transposedKey[func]();\n    }\n\n    return transposedKey.useModifier(originalModifier);\n  }\n\n  transposeUp(): Key {\n    if (this.modifier === FLAT) return this.set({ modifier: null });\n\n    if (this.note.isOneOf(3, 7, 'E', 'B')) return this.set({ note: this.note.up() });\n\n    if (this.modifier === SHARP) return this.set({ note: this.note.up(), modifier: null });\n\n    return this.set({ modifier: SHARP });\n  }\n\n  transposeDown(): Key {\n    if (this.modifier === SHARP) return this.set({ modifier: null });\n\n    if (this.note.isOneOf(1, 4, 'C', 'F')) {\n      return this.set({ note: this.note.down() });\n    }\n\n    if (this.modifier === FLAT) return this.set({ note: this.note.down(), modifier: null });\n\n    return this.set({ modifier: FLAT });\n  }\n\n  useModifier(newModifier: Modifier | null): Key {\n    if (this.modifier === FLAT && newModifier === SHARP) {\n      return this.set({ note: this.note.down(), modifier: SHARP });\n    }\n\n    if (this.modifier === SHARP && newModifier === FLAT) {\n      return this.set({ note: this.note.up(), modifier: FLAT });\n    }\n\n    return this.clone();\n  }\n\n  normalize(): Key {\n    if (this.modifier === SHARP && this.note.isOneOf(3, 7, 'E', 'B')) {\n      return this.set({ note: this.note.up(), modifier: null });\n    }\n\n    if (this.modifier === FLAT && this.note.isOneOf(1, 4, 'C', 'F')) {\n      return this.set({ note: this.note.down(), modifier: null });\n    }\n\n    return this.clone();\n  }\n\n  removeMinor(): Key {\n    return this.set({ minor: false });\n  }\n\n  normalizeEnharmonics(key: Key | string | null): Key {\n    if (key) {\n      const rootKeyString = Key.wrapOrFail(key).toString({ showMinor: true });\n      const enharmonics = ENHARMONIC_MAPPING[rootKeyString];\n      const thisKeyString = this.toString({ showMinor: false });\n\n      if (enharmonics && enharmonics[thisKeyString]) {\n        return Key.parseOrFail(enharmonics[thisKeyString]);\n      }\n    }\n\n    return this.clone();\n  }\n\n  private set(attributes: KeyProperties): Key {\n    return new Key({\n      note: this.note.clone(),\n      modifier: this.modifier,\n      minor: this.minor,\n      ...attributes,\n    });\n  }\n\n  private transposeNoteUpToKey(note: number | string, key: Key) {\n    let numericKey = new Key({ note });\n    let symbolKey = key.clone();\n    const reference = this.clone().normalize().useModifier(key.modifier).normalizeEnharmonics(key);\n\n    while (!symbolKey.equals(reference)) {\n      numericKey = numericKey.transposeUp().useModifier(key.modifier);\n      symbolKey = symbolKey.transposeUp().normalize().useModifier(key.modifier).normalizeEnharmonics(key);\n    }\n\n    return numericKey;\n  }\n}\n\nexport default Key;\n","import {\n  ChordType,\n  NUMERAL,\n  NUMERIC,\n  ROMAN_NUMERALS,\n  SYMBOL,\n} from './constants';\n\nconst A = 'A'.charCodeAt(0);\nconst G = 'G'.charCodeAt(0);\n\nconst TRANSPOSE_DISTANCE_MAJOR: Record<number, number> = {\n  1: 0,\n  2: 2,\n  3: 4,\n  4: 5,\n  5: 7,\n  6: 9,\n  7: 11,\n};\n\nconst TRANSPOSE_DISTANCE_MINOR: Record<number, number> = {\n  1: 0,\n  2: 2,\n  3: 3,\n  4: 5,\n  5: 7,\n  6: 8,\n  7: 11,\n};\n\nfunction keyToCharCode(key: string): number {\n  return key.toUpperCase().charCodeAt(0);\n}\n\nfunction clamp(note: number, min: number, max: number): number {\n  let newNote = note;\n\n  if (newNote < min) {\n    newNote += 7;\n  } else if (newNote > max) {\n    newNote -= 7;\n  }\n\n  return newNote;\n}\n\nfunction numeralToNumber(numeral: string): null | number {\n  for (let i = 0, count = ROMAN_NUMERALS.length; i < count; i += 1) {\n    const romanNumeral = ROMAN_NUMERALS[i];\n\n    if (romanNumeral === numeral || romanNumeral.toLowerCase() === numeral) {\n      return i + 1;\n    }\n  }\n\n  return null;\n}\n\nfunction numberToNumeral(number: number): string {\n  return ROMAN_NUMERALS[number - 1];\n}\n\ntype AtomicNote = string | number;\n\ninterface NoteProperties {\n  note?: AtomicNote;\n  type?: ChordType;\n  minor?: boolean;\n}\n\nclass Note implements NoteProperties {\n  _note: AtomicNote;\n\n  type: ChordType;\n\n  minor = false;\n\n  constructor({ note, type, minor = false }: { note: AtomicNote, type: ChordType, minor?: boolean }) {\n    this._note = note;\n    this.type = type;\n    this.minor = minor;\n  }\n\n  static parse(note: string | number): Note {\n    const noteString = note.toString();\n\n    if (/^[A-Ga-g]$/.test(noteString)) {\n      return new Note({ note: noteString.toUpperCase(), type: SYMBOL });\n    }\n\n    if (/^[1-7]$/.test(noteString)) {\n      return new Note({ note: parseInt(noteString, 10), type: NUMERIC });\n    }\n\n    const romanNumeralValue = numeralToNumber(noteString);\n\n    if (romanNumeralValue) {\n      return new Note({\n        note: romanNumeralValue,\n        type: NUMERAL,\n        minor: (noteString.toLowerCase() === note),\n      });\n    }\n\n    throw new Error(`Invalid note ${note}`);\n  }\n\n  toNumeral(): Note {\n    if (this.isNumeral()) {\n      return this.clone();\n    }\n\n    if (this.isNumeric()) {\n      return this.set({ type: NUMERAL });\n    }\n\n    throw new Error(`Converting a ${this.type} note to numeral is not supported`);\n  }\n\n  toNumeric(): Note {\n    if (this.isNumeric()) {\n      return this.clone();\n    }\n\n    if (this.isNumeral()) {\n      return this.set({ type: NUMERIC });\n    }\n\n    throw new Error(`Converting a ${this.type} note to numeric is not supported`);\n  }\n\n  isMinor(): boolean {\n    return this.minor;\n  }\n\n  equals(otherNote: Note): boolean {\n    return this._note === otherNote._note && this.type === otherNote.type && this.minor === otherNote.minor;\n  }\n\n  clone(): Note {\n    return this.set({});\n  }\n\n  up(): Note {\n    return this.change(1);\n  }\n\n  down(): Note {\n    return this.change(-1);\n  }\n\n  isOneOf(...options: AtomicNote[]): boolean {\n    return options.includes(this._note);\n  }\n\n  isNumeric(): boolean {\n    return this.is(NUMERIC);\n  }\n\n  isChordSymbol(): boolean {\n    return this.is(SYMBOL);\n  }\n\n  isNumeral(): boolean {\n    return this.is(NUMERAL);\n  }\n\n  is(noteType: ChordType): boolean {\n    return this.type === noteType;\n  }\n\n  getTransposeDistance(minor: boolean): number {\n    if (typeof this._note === 'number') {\n      if (minor && this._note in TRANSPOSE_DISTANCE_MINOR) {\n        return TRANSPOSE_DISTANCE_MINOR[this._note];\n      }\n\n      if (this._note in TRANSPOSE_DISTANCE_MAJOR) {\n        return TRANSPOSE_DISTANCE_MAJOR[this._note];\n      }\n    }\n\n    return 0;\n  }\n\n  change(delta: number): Note {\n    if (this.isChordSymbol()) {\n      let charCode;\n      charCode = keyToCharCode(this._note as string);\n      charCode += delta;\n      charCode = clamp(charCode, A, G);\n\n      return this.set({ note: String.fromCharCode(charCode) });\n    }\n\n    let newNote = clamp((this._note as number) + delta, 1, 7);\n\n    if (newNote < 1) {\n      newNote += 7;\n    } else if (newNote > 7) {\n      newNote -= 7;\n    }\n\n    return this.set({ note: newNote });\n  }\n\n  get note(): string | number {\n    if (this.isNumeral()) {\n      const numeral = numberToNumeral(this._note as number);\n\n      if (this.isMinor()) {\n        return numeral.toLowerCase();\n      }\n\n      return numeral;\n    }\n\n    return this._note;\n  }\n\n  toString(): string {\n    const note = this.note as string;\n\n    switch (this.type) {\n      case NUMERAL:\n        return `${this.minor ? note.toLowerCase() : note.toUpperCase()}`;\n      default:\n        return `${this.note}`;\n    }\n  }\n\n  private set(properties: NoteProperties): Note {\n    return new Note({\n      note: this._note,\n      type: this.type,\n      minor: this.minor,\n      ...properties,\n    });\n  }\n}\n\nexport default Note;\n","/**\n * Used to mark a paragraph as verse\n * @constant\n * @type {string}\n */\nexport const VERSE = 'verse';\n\n/**\n * Used to mark a paragraph as chorus\n * @constant\n * @type {string}\n */\nexport const CHORUS = 'chorus';\n\n/**\n * Used to mark a paragraph as not containing a line marked with a type\n * @constant\n * @type {string}\n */\nexport const NONE = 'none';\n\n/**\n * Used to mark a paragraph as containing lines with both verse and chorus type\n * @constant\n * @type {string}\n */\nexport const INDETERMINATE = 'indeterminate';\n\n/**\n * Used to mark a paragraph as tab\n * @constant\n * @type {string}\n */\nexport const TAB = 'tab';\n\nexport type ParagraphType = 'verse' | 'chorus' | 'none' | 'indeterminate' | 'tab';\n\nexport const SYMBOL = 'symbol';\nexport const NUMERIC = 'numeric';\nexport const NUMERAL = 'numeral';\n\nexport const ROMAN_NUMERALS = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];\n\nexport type Modifier = '#' | 'b';\n\nexport type ChordType = 'symbol' | 'numeric' | 'numeral';\n","const enharmonics: Record<string, Record<string, string>> = {\n  'Ab': {\n    'B': 'Cb',\n  },\n  'Cb': {\n    'B': 'Cb',\n    'A#': 'Bb',\n    'E': 'Fb',\n  },\n  'C': {\n    'C#': 'Db',\n    'D#': 'Eb',\n    'F#': 'Gb',\n    'G#': 'Ab',\n    'A#': 'Bb',\n  },\n  'C#': {\n    'Eb': 'D#',\n    'Bb': 'A#',\n  },\n  'Db': {\n    'B': 'Cb',\n    'F#': 'Gb',\n  },\n  'D': {\n    'D#': 'Eb',\n    'A#': 'Bb',\n    'Gb': 'F#',\n  },\n  'Eb': {\n    'D#': 'Eb',\n    'F#': 'Gb',\n    'G#': 'Ab',\n    'A#': 'Bb'\n  },\n  'E': {\n    'Ab': 'G#',\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'Db': 'C#',\n    'Eb': 'D#',\n  },\n  'F': {\n    'A#': 'Bb',\n    'F#': 'Gb',\n    'C#': 'Db',\n    'D#': 'Eb',\n    'G#': 'Ab',\n  },\n  'F#': {\n    'Bb': 'A#',\n    'Eb': 'D#',\n  },\n  'Gb': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'G#': 'Ab',\n    'B': 'Cb',\n    'E': 'Fb',\n  },\n  'G': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'G#': 'Ab',\n    'C#': 'Db',\n  },\n  'G#': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'Cb': 'B#',\n  },\n  'Am': {\n    'Gb': 'G',\n    'G#': 'Ab',\n    'F#': 'Gb',\n    'C#': 'Db',\n    'D#': 'Eb',\n    'A#': 'Bb',\n  },\n  'Bbm': {\n    'Cb': 'B',\n    'Gb': 'F#',\n  },\n  'Bm': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n  },\n  'C#m': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'Gb': 'F#',\n  },\n  'Cm': {\n    'G#': 'Ab',\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'F#': 'Gb',\n    'C#': 'Db',\n  },\n  'Dm': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'F#': 'Gb',\n    'G#': 'Ab',\n    'C#': 'Db',\n  },\n  'Em': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'C#': 'Db',\n  },\n  'F#m': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'Gb': 'F#',\n    'Ab': 'G#',\n    'Db': 'C#',\n  },\n  'Fm': {\n    'G#': 'Ab',\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'F#': 'Gb',\n    'C#': 'Db',\n  },\n  'Gm': {\n    'G#': 'Ab',\n    'A#': 'Bb',\n    'D#': 'Eb',\n    'C#': 'Db',\n    'F#': 'Gb',\n  },\n  'G#m': {\n    'A#': 'Bb',\n    'D#': 'Eb',\n  },\n  'B': {\n    'Eb': 'D#',\n  }\n};\n\nexport default enharmonics;\n","import Line from './chord_sheet/line';\nimport ChordLyricsPair from './chord_sheet/chord_lyrics_pair';\nimport Item from './chord_sheet/item';\n\nexport const hasChordContents = (line: Line): boolean => (\n  line.items.some((item) => (item instanceof ChordLyricsPair) && !!item.chords)\n);\n\nexport const isEvaluatable = (item: Item): boolean => ('evaluate' in item) && (typeof item.evaluate === 'function');\n\nexport const padLeft = (string: string, length: number): string => {\n  let paddedString = string;\n  for (let l = string.length; l < length; l += 1, paddedString += ' ');\n  return paddedString;\n};\n\ntype ObjectWithLength = any[] | string | null;\n\nexport const isPresent = (object: ObjectWithLength): boolean => !!object && object.length > 0;\nexport const isString = (obj: any): boolean => (typeof obj === 'string');\n\nfunction dasherize(string: string): string {\n  return string.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n}\n\ntype CssObject = Record<string, Record<string, string>>;\n\nexport function scopeCss(css: CssObject, scope = ''): string {\n  return Object\n    .entries(css)\n    .map(([selector, styles]) => {\n      const rules = Object\n        .entries(styles)\n        .map(([property, value]) => `${dasherize(property)}: ${value};`)\n        .join('\\n  ');\n\n      const scopedSelector = `${scope} ${selector}`.trim();\n\n      return `\n${scopedSelector} {\n  ${rules}\n}`.substring(1);\n    })\n    .join('\\n\\n');\n}\n\nexport function deprecate(message: string): void {\n  try {\n    throw new Error(`DEPRECATION: ${message}`);\n  } catch (e) {\n    const error = (e as Error);\n    const proc = globalThis.process;\n\n    if (typeof proc === 'object' && typeof proc.emitWarning === 'function') {\n      proc.emitWarning(`${message}\\n${error.stack}`);\n    } else {\n      console.warn(`${message}\\n${error.stack}`);\n    }\n  }\n}\n\nexport function breakingChange(message: string): void {\n  throw new Error(`BREAKING CHANGE: ${message}`);\n}\n\nexport function isEmptyString(string: string | null | undefined): boolean {\n  return (string === null || string === undefined || string === '');\n}\n\nexport function isMinor(suffix: any): boolean {\n  if (typeof suffix !== 'string') {\n    return false;\n  }\n\n  return suffix[0] === 'm' && suffix.substring(0, 3).toLowerCase() !== 'maj';\n}\n\nexport function normalizeLineEndings(string: string): string {\n  return string.replace(/\\r\\n?/g, '\\n');\n}\n","const mapping: Record<string, string> = {\n  \"2\": \"2\",\n  \"4\": \"sus\",\n  \"5\": \"5\",\n  \"6\": \"6\",\n  \"7\": \"7\",\n  \"9\": \"9\",\n  \"11\": \"11\",\n  \"13\": \"13\",\n  \"42\": \"4(2)\",\n  \"69\": \"6(9)\",\n  \"(#4)\": \"(#4)\",\n  \"#4\": \"(#4)\",\n  \"+4\": \"(#4)\",\n  \"(+4)\": \"(#4)\",\n  \"(11)\": \"(11)\",\n  \"add11\": \"(11)\",\n  \"(add11)\": \"(11)\",\n  \"(13)\": \"(13)\",\n  \"add13\": \"(13)\",\n  \"(add13)\": \"(13)\",\n  \"(2)\": \"(2)\",\n  \"add2\": \"(2)\",\n  \"(add2)\": \"(2)\",\n  \"(4)\": \"(4)\",\n  \"add4\": \"(4)\",\n  \"(add4)\": \"(4)\",\n  \"sus(4)\": \"(4)\",\n  \"(6)\": \"(6)\",\n  \"add6\": \"(6)\",\n  \"(add6)\": \"(6)\",\n  \"(7)\": \"(7)\",\n  \"(9)\": \"(9)\",\n  \"add9\": \"(9)\",\n  \"(add9)\": \"(9)\",\n  \"(b5)\": \"(b5)\",\n  \"-5\": \"(b5)\",\n  \"(-5)\": \"(b5)\",\n  \"b5\": \"(b5)\",\n  \"2(6)\": \"2(6)\",\n  \"(b6)\": \"(b6)\",\n  \"(unis)\": \"(unis)\",\n  \"unis\": \"(unis)\",\n  \"[blank]\": \"[blank]\",\n  \"maj\": \"[blank]\",\n  \"major\": \"[blank]\",\n  \"M\": \"[blank]\",\n  \"ma\": \"[blank]\",\n  \"Ma\": \"[blank]\",\n  \"Majj\": \"[blank]\",\n  \"+\": \"+\",\n  \"aug\": \"+\",\n  \"(#5)\": \"+\",\n  \"#5\": \"+\",\n  \"+5\": \"+\",\n  \"(+5)\": \"+\",\n  \"x\": \"+\",\n  \"dom11\": \"11\",\n  \"dom 11\": \"11\",\n  \"11(#5)\": \"11(#5)\",\n  \"11#5\": \"11(#5)\",\n  \"11+5\": \"11(#5)\",\n  \"11(+5)\": \"11(#5)\",\n  \"11(#9)\": \"11(#9)\",\n  \"11#9\": \"11(#9)\",\n  \"11+9\": \"11(#9)\",\n  \"11(+9)\": \"11(#9)\",\n  \"11(b13)\": \"11(b13)\",\n  \"11b13\": \"11(b13)\",\n  \"11-13\": \"11(b13)\",\n  \"11(-13)\": \"11(b13)\",\n  \"11(b5)\": \"11(b5)\",\n  \"11b5\": \"11(b5)\",\n  \"11-5\": \"11(b5)\",\n  \"11(-5)\": \"11(b5)\",\n  \"11(b9)\": \"11(b9)\",\n  \"11b9\": \"11(b9)\",\n  \"11-9\": \"11(b9)\",\n  \"11(-9)\": \"11(b9)\",\n  \"11sus4\": \"11sus4\",\n  \"11sus\": \"11sus4\",\n  \"m11sus4\": \"11sus4\",\n  \"m11sus\": \"11sus4\",\n  \"dom13\": \"13\",\n  \"dom 13\": \"13\",\n  \"13(#11)\": \"13(#11)\",\n  \"13#11\": \"13(#11)\",\n  \"13+11\": \"13(#11)\",\n  \"13(+11)\": \"13(#11)\",\n  \"13(#5)\": \"13(#5)\",\n  \"13#5\": \"13(#5)\",\n  \"13+5\": \"13(#5)\",\n  \"13(+5)\": \"13(#5)\",\n  \"13(#9)\": \"13(#9)\",\n  \"13#9\": \"13(#9)\",\n  \"13(+9)\": \"13(#9)\",\n  \"13+9\": \"13(#9)\",\n  \"13(#9#5)\": \"13(#9#5)\",\n  \"13#9#5\": \"13(#9#5)\",\n  \"13(+9+5)\": \"13(#9#5)\",\n  \"13+9+5\": \"13(#9#5)\",\n  \"13(#9b5)\": \"13(#9b5)\",\n  \"13#9b5\": \"13(#9b5)\",\n  \"13(+9-5)\": \"13(#9b5)\",\n  \"13+9-5\": \"13(#9b5)\",\n  \"13(add4)\": \"13(add4)\",\n  \"13(b5)\": \"13(b5)\",\n  \"13b5\": \"13(b5)\",\n  \"13-5\": \"13(b5)\",\n  \"13(-5)\": \"13(b5)\",\n  \"13(b9)\": \"13(b9)\",\n  \"13b9\": \"13(b9)\",\n  \"13-9\": \"13(b9)\",\n  \"13(-9)\": \"13(b9)\",\n  \"13(b9#5)\": \"13(b9#5)\",\n  \"13b9#5\": \"13(b9#5)\",\n  \"13-9+5\": \"13(b9#5)\",\n  \"13(-9+5)\": \"13(b9#5)\",\n  \"13(b9b5)\": \"13(b9b5)\",\n  \"13b9b5\": \"13(b9b5)\",\n  \"13-9-5\": \"13(b9b5)\",\n  \"13(-9-5)\": \"13(b9b5)\",\n  \"13sus4\": \"13sus4\",\n  \"13sus\": \"13sus4\",\n  \"m13sus4\": \"13sus4\",\n  \"m13sus\": \"13sus4\",\n  \"sus2\": \"2\",\n  \"add9(no3)\": \"2\",\n  \"2(#11)\": \"2(#11)\",\n  \"2(#4)\": \"2(#4)\",\n  \"2+4\": \"2(#4)\",\n  \"2#4\": \"2(#4)\",\n  \"2(+4)\": \"2(#4)\",\n  \"(#4)2\": \"2(#4)\",\n  \"2(#4)(#42)(2#4)\": \"2(#4)(#42)(2#4)\",\n  \"2(+7)\": \"2(+7)\",\n  \"2(4)\": \"2(4)\",\n  \"sus2(4)\": \"2(4)\",\n  \"2(ma7)\": \"2(ma7)\",\n  \"2(no3)\": \"2(no3)\",\n  \"4(2)\": \"4(2)\",\n  \"sus42\": \"4(2)\",\n  \"no3\": \"5\",\n  \"(no3)\": \"5\",\n  \"(no 3)\": \"5\",\n  \"(no 3rd)\": \"5\",\n  \"5(no3)\": \"5\",\n  \"6(2)\": \"6(2)\",\n  \"6(b9)\": \"6(b9)\",\n  \"6(no3)\": \"6(no3)\",\n  \"6(9)\": \"6(9)\",\n  \"6(add9)\": \"6(9)\",\n  \"dom7\": \"7\",\n  \"dom 7\": \"7\",\n  \"dom 7th\": \"7\",\n  \"7(#11)\": \"7(#11)\",\n  \"7#11\": \"7(#11)\",\n  \"7+11\": \"7(#11)\",\n  \"7(+11)\": \"7(#11)\",\n  \"7(#5)\": \"7(#5)\",\n  \"aug7\": \"7(#5)\",\n  \"7#5\": \"7(#5)\",\n  \"7+5\": \"7(#5)\",\n  \"7(+5)\": \"7(#5)\",\n  \"x7\": \"7(#5)\",\n  \"aug 7\": \"7(#5)\",\n  \"aug 7th\": \"7(#5)\",\n  \"7(#5#11)\": \"7(#5#11)\",\n  \"7#5#11\": \"7(#5#11)\",\n  \"7+5+11\": \"7(#5#11)\",\n  \"7(+5+11)\": \"7(#5#11)\",\n  \"7(#9)\": \"7(#9)\",\n  \"7#9\": \"7(#9)\",\n  \"7+9\": \"7(#9)\",\n  \"7(+9)\": \"7(#9)\",\n  \"7(#9#5)\": \"7(#9#5)\",\n  \"7(#5#9)\": \"7(#9#5)\",\n  \"7#5#9\": \"7(#9#5)\",\n  \"7+5+9\": \"7(#9#5)\",\n  \"7(+5+9)\": \"7(#9#5)\",\n  \"7(#9b13)\": \"7(#9b13)\",\n  \"7#9b13\": \"7(#9b13)\",\n  \"7(+9-13)\": \"7(#9b13)\",\n  \"7+9-13\": \"7(#9b13)\",\n  \"7(b13#9)\": \"7(#9b13)\",\n  \"7b13#9\": \"7(#9b13)\",\n  \"7-13+9\": \"7(#9b13)\",\n  \"7(-13+9)\": \"7(#9b13)\",\n  \"7(#9b5)\": \"7(#9b5)\",\n  \"7(6)\": \"7(6)\",\n  \"7(b13)\": \"7(b13)\",\n  \"7b13\": \"7(b13)\",\n  \"7-13\": \"7(b13)\",\n  \"7(-13)\": \"7(b13)\",\n  \"7(b5)\": \"7(b5)\",\n  \"7b5\": \"7(b5)\",\n  \"7-5\": \"7(b5)\",\n  \"7(-5)\": \"7(b5)\",\n  \"7(b5#11)\": \"7(b5#11)\",\n  \"7b5#11\": \"7(b5#11)\",\n  \"7-5+11\": \"7(b5#11)\",\n  \"7(-5+11)\": \"7(b5#11)\",\n  \"7(b5#9)\": \"7(b5#9)\",\n  \"7b5#9\": \"7(b5#9)\",\n  \"7-5+9\": \"7(b5#9)\",\n  \"7(-5+9)\": \"7(b5#9)\",\n  \"7(b5b9)\": \"7(b5b9)\",\n  \"7b5b9\": \"7(b5b9)\",\n  \"7-5-9\": \"7(b5b9)\",\n  \"7(-5-9)\": \"7(b5b9)\",\n  \"7(b9)\": \"7(b9)\",\n  \"7b9\": \"7(b9)\",\n  \"7-9\": \"7(b9)\",\n  \"7(-9)\": \"7(b9)\",\n  \"7(b9#5)\": \"7(b9#5)\",\n  \"7(#5b9)\": \"7(b9#5)\",\n  \"7#5b9\": \"7(b9#5)\",\n  \"7+5-9\": \"7(b9#5)\",\n  \"7(+5-9)\": \"7(b9#5)\",\n  \"7(b9b13)\": \"7(b9b13)\",\n  \"7b9b13\": \"7(b9b13)\",\n  \"7-9-13\": \"7(b9b13)\",\n  \"7(-9-13)\": \"7(b9b13)\",\n  \"7(b13b9)\": \"7(b9b13)\",\n  \"7b13b9\": \"7(b9b13)\",\n  \"7-13-9\": \"7(b9b13)\",\n  \"7(-13-9)\": \"7(b9b13)\",\n  \"7(b9b5)\": \"7(b9b5)\",\n  \"7(no3)\": \"7(no3)\",\n  \"7aug5\": \"7aug5\",\n  \"7b9sus4\": \"7b9sus4\",\n  \"7sus(6)\": \"7sus(6)\",\n  \"7sus(b9)\": \"7sus(b9)\",\n  \"7sus4\": \"7sus4\",\n  \"7sus\": \"7sus4\",\n  \"dom9\": \"9\",\n  \"dom 9\": \"9\",\n  \"9(#11)\": \"9(#11)\",\n  \"9#11\": \"9(#11)\",\n  \"9+11\": \"9(#11)\",\n  \"9(+11)\": \"9(#11)\",\n  \"9(#5)\": \"9(#5)\",\n  \"9#5\": \"9(#5)\",\n  \"9+5\": \"9(#5)\",\n  \"9(+5)\": \"9(#5)\",\n  \"aug9\": \"9(#5)\",\n  \"x9\": \"9(#5)\",\n  \"9(b13)\": \"9(b13)\",\n  \"9b13\": \"9(b13)\",\n  \"9-13\": \"9(b13)\",\n  \"9(-13)\": \"9(b13)\",\n  \"9(b5)\": \"9(b5)\",\n  \"9b5\": \"9(b5)\",\n  \"9-5\": \"9(b5)\",\n  \"9(-5)\": \"9(b5)\",\n  \"9aug\": \"9aug\",\n  \"9sus4\": \"9sus4\",\n  \"9sus\": \"9sus4\",\n  \"m9sus4\": \"9sus4\",\n  \"m9sus\": \"9sus4\",\n  \"b69(#11)\": \"b69(#11)\",\n  \"b69sus\": \"b69sus\",\n  \"b9sus\": \"b9sus\",\n  \"dim\": \"dim\",\n  \"m(b5)\": \"dim\",\n  \"mb5\": \"dim\",\n  \"m-5\": \"dim\",\n  \"m(-5)\": \"dim\",\n  \"-(b5)\": \"dim\",\n  \"-b5\": \"dim\",\n  \"dim7\": \"dim7\",\n  \"o7\": \"dim7\",\n  \"dim 7\": \"dim7\",\n  \"dim 7th\": \"dim7\",\n  \"m\": \"m\",\n  \"mi\": \"m\",\n  \"min\": \"m\",\n  \"minor\": \"m\",\n  \"-\": \"m\",\n  \"m(11)\": \"m(11)\",\n  \"m(add11)\": \"m(11)\",\n  \"m(4)\": \"m(4)\",\n  \"m(add4)\": \"m(4)\",\n  \"m(9)\": \"m(9)\",\n  \"m(add9)\": \"m(9)\",\n  \"m(ma7)\": \"m(ma7)\",\n  \"m(M7)\": \"m(ma7)\",\n  \"mi(maj7)\": \"m(ma7)\",\n  \"min(maj7)\": \"m(ma7)\",\n  \"m(maj7)\": \"m(ma7)\",\n  \"m(+7)\": \"m(ma7)\",\n  \"m+7\": \"m(ma7)\",\n  \"m(ma9)\": \"m(ma9)\",\n  \"m(M9)\": \"m(ma9)\",\n  \"mi(maj9)\": \"m(ma9)\",\n  \"min(maj9)\": \"m(ma9)\",\n  \"m(maj9)\": \"m(ma9)\",\n  \"m(+9)\": \"m(ma9)\",\n  \"m+9\": \"m(ma9)\",\n  \"m(no5)\": \"m(no5)\",\n  \"m11\": \"m11\",\n  \"mi11\": \"m11\",\n  \"min11\": \"m11\",\n  \"-11\": \"m11\",\n  \"m11(#5)\": \"m11(#5)\",\n  \"m11#5\": \"m11(#5)\",\n  \"m11+5\": \"m11(#5)\",\n  \"m11(+5)\": \"m11(#5)\",\n  \"-11(#5)\": \"m11(#5)\",\n  \"-11#5\": \"m11(#5)\",\n  \"m9+5\": \"m9(#5)\",\n  \"-11(+5)\": \"m11(#5)\",\n  \"m11(#9)\": \"m11(#9)\",\n  \"m11#9\": \"m11(#9)\",\n  \"m11+9\": \"m11(#9)\",\n  \"m11(+9)\": \"m11(#9)\",\n  \"-11(#9)\": \"m11(#9)\",\n  \"-11#9\": \"m11(#9)\",\n  \"-11+9\": \"m11(#9)\",\n  \"-11(+9)\": \"m11(#9)\",\n  \"m11(#9#5)\": \"m11(#9#5)\",\n  \"m11(#5#9)\": \"m11(#9#5)\",\n  \"m11#5#9\": \"m11(#9#5)\",\n  \"m11+5+9\": \"m11(#9#5)\",\n  \"m11(+5+9)\": \"m11(#9#5)\",\n  \"-11(#5#9)\": \"m11(#9#5)\",\n  \"-11#5#9\": \"m11(#9#5)\",\n  \"m9+5+9\": \"m11(#9#5)\",\n  \"-11(+5+9)\": \"m11(#9#5)\",\n  \"m11(#9b13)\": \"m11(#9b13)\",\n  \"m11#9b13\": \"m11(#9b13)\",\n  \"m11+9-13\": \"m11(#9b13)\",\n  \"m11(+9-13)\": \"m11(#9b13)\",\n  \"-11(#9b13)\": \"m11(#9b13)\",\n  \"-11#9b13\": \"m11(#9b13)\",\n  \"-11+9-13\": \"m11(#9b13)\",\n  \"-11(+9-13)\": \"m11(#9b13)\",\n  \"m11(b13)\": \"m11(b13)\",\n  \"m11b13\": \"m11(b13)\",\n  \"m11-13\": \"m11(b13)\",\n  \"m11(-13)\": \"m11(b13)\",\n  \"-11(b13)\": \"m11(b13)\",\n  \"-11b13\": \"m11(b13)\",\n  \"-11-13\": \"m11(b13)\",\n  \"-11(-13)\": \"m11(b13)\",\n  \"m11(b13#5)\": \"m11(b13#5)\",\n  \"m11(#5b13)\": \"m11(b13#5)\",\n  \"m11#5b13\": \"m11(b13#5)\",\n  \"m11+5-13\": \"m11(b13#5)\",\n  \"m11(+5-13)\": \"m11(b13#5)\",\n  \"-11(#5b13)\": \"m11(b13#5)\",\n  \"-11#5b13\": \"m11(b13#5)\",\n  \"-11+5-13\": \"m11(b13#5)\",\n  \"-11(+5-13)\": \"m11(b13#5)\",\n  \"m11(b5)\": \"m11(b5)\",\n  \"m11b5\": \"m11(b5)\",\n  \"m11-5\": \"m11(b5)\",\n  \"m11(-5)\": \"m11(b5)\",\n  \"-11(b5)\": \"m11(b5)\",\n  \"-11b5\": \"m11(b5)\",\n  \"-9-5\": \"m9(b5)\",\n  \"-11(-5)\": \"m11(b5)\",\n  \"m11(b5#9)\": \"m11(b5#9)\",\n  \"m11b5#9\": \"m11(b5#9)\",\n  \"m11-5+9\": \"m11(b5#9)\",\n  \"m11(-5+9)\": \"m11(b5#9)\",\n  \"-11(b5#9)\": \"m11(b5#9)\",\n  \"-11b5#9\": \"m11(b5#9)\",\n  \"-11-5+9\": \"m11(b5#9)\",\n  \"-11(-5+9)\": \"m11(b5#9)\",\n  \"m11(b5b13)\": \"m11(b5b13)\",\n  \"m11b5b13\": \"m11(b5b13)\",\n  \"m11(-5-13)\": \"m11(b5b13)\",\n  \"m11-5-13\": \"m11(b5b13)\",\n  \"-11(b5b13)\": \"m11(b5b13)\",\n  \"-11b5b13\": \"m11(b5b13)\",\n  \"-11(-5-13)\": \"m11(b5b13)\",\n  \"-11-5-13\": \"m11(b5b13)\",\n  \"m11(b5b9)\": \"m11(b5b9)\",\n  \"m11b5b9\": \"m11(b5b9)\",\n  \"m11-5-9\": \"m11(b5b9)\",\n  \"m11(-5-9)\": \"m11(b5b9)\",\n  \"-11(b5b9)\": \"m11(b5b9)\",\n  \"-11b5b9\": \"m11(b5b9)\",\n  \"-11-5-9\": \"m11(b5b9)\",\n  \"-11(-5-9)\": \"m11(b5b9)\",\n  \"m11(b9)\": \"m11(b9)\",\n  \"m11b9\": \"m11(b9)\",\n  \"m11(-9)\": \"m11(b9)\",\n  \"m11-9\": \"m11(b9)\",\n  \"-11(b9)\": \"m11(b9)\",\n  \"-11b9\": \"m11(b9)\",\n  \"-11(-9)\": \"m11(b9)\",\n  \"-11-9\": \"m11(b9)\",\n  \"m11(b9#5)\": \"m11(b9#5)\",\n  \"m11(#5b9)\": \"m11(b9#5)\",\n  \"m11#5b9\": \"m11(b9#5)\",\n  \"m11+5-9\": \"m11(b9#5)\",\n  \"m11(+5-9)\": \"m11(b9#5)\",\n  \"-11(#5b9)\": \"m11(b9#5)\",\n  \"-11#5b9\": \"m11(b9#5)\",\n  \"m9+5-9\": \"m11(b9#5)\",\n  \"-11(+5-9)\": \"m11(b9#5)\",\n  \"m11(b9b13)\": \"m11(b9b13)\",\n  \"m11b9b13\": \"m11(b9b13)\",\n  \"m11(-9-13)\": \"m11(b9b13)\",\n  \"m11-9-13\": \"m11(b9b13)\",\n  \"-11(b9b13)\": \"m11(b9b13)\",\n  \"-11b9b13\": \"m11(b9b13)\",\n  \"-11(-9-13)\": \"m11(b9b13)\",\n  \"-11-9-13\": \"m11(b9b13)\",\n  \"m13\": \"m13\",\n  \"mi13\": \"m13\",\n  \"min13\": \"m13\",\n  \"-13\": \"m13\",\n  \"m13(#11)\": \"m13(#11)\",\n  \"m13#11\": \"m13(#11)\",\n  \"m13+11\": \"m13(#11)\",\n  \"m13(+11)\": \"m13(#11)\",\n  \"-13(#11)\": \"m13(#11)\",\n  \"-13#11\": \"m13(#11)\",\n  \"-13+11\": \"m13(#11)\",\n  \"-13(+11)\": \"m13(#11)\",\n  \"m13(#5)\": \"m13(#5)\",\n  \"m13#5\": \"m13(#5)\",\n  \"m13+5\": \"m13(#5)\",\n  \"m13(+5)\": \"m13(#5)\",\n  \"-13(#5)\": \"m13(#5)\",\n  \"-13#5\": \"m13(#5)\",\n  \"-13(+5)\": \"m13(#5)\",\n  \"m13(#9)\": \"m13(#9)\",\n  \"m13#9\": \"m13(#9)\",\n  \"m13(+9)\": \"m13(#9)\",\n  \"m13+9\": \"m13(#9)\",\n  \"-13(#9)\": \"m13(#9)\",\n  \"-13#9\": \"m13(#9)\",\n  \"-13(+9)\": \"m13(#9)\",\n  \"-13+9\": \"m13(#9)\",\n  \"m13(b5)\": \"m13(b5)\",\n  \"m13b5\": \"m13(b5)\",\n  \"m13-5\": \"m13(b5)\",\n  \"m13(-5)\": \"m13(b5)\",\n  \"-13(b5)\": \"m13(b5)\",\n  \"-13b5\": \"m13(b5)\",\n  \"-13-5\": \"m13(b5)\",\n  \"-13(-5)\": \"m13(b5)\",\n  \"m13(b9)\": \"m13(b9)\",\n  \"m13b9\": \"m13(b9)\",\n  \"m13-9\": \"m13(b9)\",\n  \"m13(-9)\": \"m13(b9)\",\n  \"-13(b13)\": \"m13(b9)\",\n  \"-13b13\": \"m13(b9)\",\n  \"-13-13\": \"m13(b9)\",\n  \"-13(-13)\": \"m13(b9)\",\n  \"m2\": \"m2\",\n  \"mi2\": \"m2\",\n  \"min2\": \"m2\",\n  \"m(add2)\": \"m2\",\n  \"madd2\": \"m2\",\n  \"m4\": \"m4\",\n  \"m6\": \"m6\",\n  \"mi6\": \"m6\",\n  \"min6\": \"m6\",\n  \"-6\": \"m6\",\n  \"m6(#5)\": \"m6(#5)\",\n  \"m6(9)\": \"m6(9)\",\n  \"m6add9\": \"m6(9)\",\n  \"m6(add9)\": \"m6(9)\",\n  \"m69\": \"m6(9)\",\n  \"m6(ma7)\": \"m6(ma7)\",\n  \"m6(M7)\": \"m6(ma7)\",\n  \"m6(+7)\": \"m6(ma7)\",\n  \"m6M7\": \"m6(ma7)\",\n  \"m6+7\": \"m6(ma7)\",\n  \"m7\": \"m7\",\n  \"mi7\": \"m7\",\n  \"min7\": \"m7\",\n  \"-7\": \"m7\",\n  \"m7(#11)\": \"m7(#11)\",\n  \"m7#11\": \"m7(#11)\",\n  \"m7+11\": \"m7(#11)\",\n  \"m7(+11)\": \"m7(#11)\",\n  \"-7(#11)\": \"m7(#11)\",\n  \"-7#11\": \"m7(#11)\",\n  \"-7+11\": \"m7(#11)\",\n  \"-7(+11)\": \"m7(#11)\",\n  \"m7(#5)\": \"m7(#5)\",\n  \"m7#5\": \"m7(#5)\",\n  \"m7+5\": \"m7(#5)\",\n  \"m7(+5)\": \"m7(#5)\",\n  \"-7(#5)\": \"m7(#5)\",\n  \"-7#5\": \"m7(#5)\",\n  \"-7(+5)\": \"m7(#5)\",\n  \"m7(#9)\": \"m7(#9)\",\n  \"m7#9\": \"m7(#9)\",\n  \"m7+9\": \"m7(#9)\",\n  \"m7(+9)\": \"m7(#9)\",\n  \"-7(#9)\": \"m7(#9)\",\n  \"-7#9\": \"m7(#9)\",\n  \"-7(+9)\": \"m7(#9)\",\n  \"m7(11)\": \"m7(11)\",\n  \"m7(4)\": \"m7(4)\",\n  \"m7(add4)\": \"m7(4)\",\n  \"m7(add11)\": \"m7(4)\",\n  \"m74\": \"m7(4)\",\n  \"m7(6)\": \"m7(6)\",\n  \"m7(add6)\": \"m7(add6)\",\n  \"m7(b13)\": \"m7(b13)\",\n  \"m7b13\": \"m7(b13)\",\n  \"m7-13\": \"m7(b13)\",\n  \"m7(-13)\": \"m7(b13)\",\n  \"-7(b13)\": \"m7(b13)\",\n  \"-7b13\": \"m7(b13)\",\n  \"-7-13\": \"m7(b13)\",\n  \"-7(-13)\": \"m7(b13)\",\n  \"m7(b5)\": \"m7(b5)\",\n  \"m7b5\": \"m7(b5)\",\n  \"m7-5\": \"m7(b5)\",\n  \"m7(-5)\": \"m7(b5)\",\n  \"-7(b5)\": \"m7(b5)\",\n  \"-7b5\": \"m7(b5)\",\n  \"-7(-5)\": \"m7(b5)\",\n  \"m7(b9)\": \"m7(b9)\",\n  \"m7b9\": \"m7(b9)\",\n  \"m7-9\": \"m7(b9)\",\n  \"m7(-9)\": \"m7(b9)\",\n  \"-7(b9)\": \"m7(b9)\",\n  \"-7b9\": \"m7(b9)\",\n  \"-7(-9)\": \"m7(b9)\",\n  \"m7(no3)\": \"m7(no3)\",\n  \"min7(no3)\": \"m7(no3)\",\n  \"m7sus4\": \"m7sus4\",\n  \"m7sus\": \"m7sus4\",\n  \"m9\": \"m9\",\n  \"mi9\": \"m9\",\n  \"min9\": \"m9\",\n  \"-9\": \"m9\",\n  \"m9(#11)\": \"m9(#11)\",\n  \"m9#11\": \"m9(#11)\",\n  \"m9+11\": \"m9(#11)\",\n  \"m9(+11)\": \"m9(#11)\",\n  \"-9(#11)\": \"m9(#11)\",\n  \"-9#11\": \"m9(#11)\",\n  \"-9+11\": \"m9(#11)\",\n  \"-9(+11)\": \"m9(#11)\",\n  \"m9(#5)\": \"m9(#5)\",\n  \"m9#5\": \"m9(#5)\",\n  \"m9(+5)\": \"m9(#5)\",\n  \"-9(#5)\": \"m9(#5)\",\n  \"-9#5\": \"m9(#5)\",\n  \"-9(+5)\": \"m9(#5)\",\n  \"m9(#7)\": \"m9(#7)\",\n  \"m9(b13)\": \"m9(b13)\",\n  \"m9b13\": \"m9(b13)\",\n  \"m9-13\": \"m9(b13)\",\n  \"m9(-13)\": \"m9(b13)\",\n  \"-9(b13)\": \"m9(b13)\",\n  \"-9b13\": \"m9(b13)\",\n  \"-9-13\": \"m9(b13)\",\n  \"-9(-13)\": \"m9(b13)\",\n  \"m9(b5)\": \"m9(b5)\",\n  \"m9b5\": \"m9(b5)\",\n  \"m9-5\": \"m9(b5)\",\n  \"m9(-5)\": \"m9(b5)\",\n  \"-9(b5)\": \"m9(b5)\",\n  \"-9b5\": \"m9(b5)\",\n  \"-9(-5)\": \"m9(b5)\",\n  \"m9(ma7)\": \"m9(ma7)\",\n  \"m9(maj7)\": \"m9(ma7)\",\n  \"m9(+7)\": \"m9(ma7)\",\n  \"m9(M7)\": \"m9(ma7)\",\n  \"m9M7\": \"m9(ma7)\",\n  \"ma9\": \"ma9\",\n  \"maj9\": \"ma9\",\n  \"ma11\": \"ma11\",\n  \"11(#7)\": \"ma11\",\n  \"11#7\": \"ma11\",\n  \"11+7\": \"ma11\",\n  \"11(+7)\": \"ma11\",\n  \"+11\": \"ma11\",\n  \"M11\": \"ma11\",\n  \"ma11(#5)\": \"ma11(#5)\",\n  \"maj11#5\": \"ma11(#5)\",\n  \"maj11+5\": \"ma11(#5)\",\n  \"maj11(+5)\": \"ma11(#5)\",\n  \"+11(#5)\": \"ma11(#5)\",\n  \"+11#5\": \"ma11(#5)\",\n  \"M11+5\": \"ma11(#5)\",\n  \"+11(+5)\": \"ma11(#5)\",\n  \"maj11(#5)\": \"ma11(#5)\",\n  \"ma11#5\": \"ma11(#5)\",\n  \"ma11+5\": \"ma11(#5)\",\n  \"ma11(+5)\": \"ma11(#5)\",\n  \"ma11(#9)\": \"ma11(#9)\",\n  \"maj11#9\": \"ma11(#9)\",\n  \"maj11+9\": \"ma11(#9)\",\n  \"maj11(+9)\": \"ma11(#9)\",\n  \"+11(#9)\": \"ma11(#9)\",\n  \"+11#9\": \"ma11(#9)\",\n  \"M11+9\": \"ma11(#9)\",\n  \"+11(+9)\": \"ma11(#9)\",\n  \"maj11(#9)\": \"ma11(#9)\",\n  \"ma11#9\": \"ma11(#9)\",\n  \"ma11+9\": \"ma11(#9)\",\n  \"ma11(+9)\": \"ma11(#9)\",\n  \"ma11(b13)\": \"ma11(b13)\",\n  \"maj11b13\": \"ma11(b13)\",\n  \"maj11-13\": \"ma11(b13)\",\n  \"maj11(-13)\": \"ma11(b13)\",\n  \"+11(b13)\": \"ma11(b13)\",\n  \"+11b13\": \"ma11(b13)\",\n  \"M11-13\": \"ma11(b13)\",\n  \"+11(-13)\": \"ma11(b13)\",\n  \"maj11(b13)\": \"ma11(b13)\",\n  \"ma11b13\": \"ma11(b13)\",\n  \"ma11-13\": \"ma11(b13)\",\n  \"ma11(-13)\": \"ma11(b13)\",\n  \"ma11(b5)\": \"ma11(b5)\",\n  \"maj11b5\": \"ma11(b5)\",\n  \"maj11-5\": \"ma11(b5)\",\n  \"maj11(-5)\": \"ma11(b5)\",\n  \"+11(b5)\": \"ma11(b5)\",\n  \"+11b5\": \"ma11(b5)\",\n  \"M11-5\": \"ma11(b5)\",\n  \"+11(-5)\": \"ma11(b5)\",\n  \"maj11(b5)\": \"ma11(b5)\",\n  \"ma11b5\": \"ma11(b5)\",\n  \"ma11-5\": \"ma11(b5)\",\n  \"ma11(-5)\": \"ma11(b5)\",\n  \"ma11(b9)\": \"ma11(b9)\",\n  \"maj11b9\": \"ma11(b9)\",\n  \"maj11(-9)\": \"ma11(b9)\",\n  \"maj11-9\": \"ma11(b9)\",\n  \"+11(b9)\": \"ma11(b9)\",\n  \"+11b9\": \"ma11(b9)\",\n  \"M11(-9)\": \"ma11(b9)\",\n  \"+11-9\": \"ma11(b9)\",\n  \"maj11(b9)\": \"ma11(b9)\",\n  \"ma11b9\": \"ma11(b9)\",\n  \"ma11(-9)\": \"ma11(b9)\",\n  \"ma11-9\": \"ma11(b9)\",\n  \"ma13\": \"ma13\",\n  \"13(#7)\": \"ma13\",\n  \"+13\": \"ma13\",\n  \"M13\": \"ma13\",\n  \"ma13(#11)\": \"ma13(#11)\",\n  \"maj13#11\": \"ma13(#11)\",\n  \"maj13+11\": \"ma13(#11)\",\n  \"maj13(+11)\": \"ma13(#11)\",\n  \"+13(#11)\": \"ma13(#11)\",\n  \"+13#11\": \"ma13(#11)\",\n  \"M13+11\": \"ma13(#11)\",\n  \"+13(+11)\": \"ma13(#11)\",\n  \"maj13(#11)\": \"ma13(#11)\",\n  \"ma7#11\": \"ma9(#11)\",\n  \"ma13+11\": \"ma13(#11)\",\n  \"ma13(+11)\": \"ma13(#11)\",\n  \"ma13(#11#5)\": \"ma13(#11#5)\",\n  \"maj13#11#5\": \"ma13(#11#5)\",\n  \"maj13+11+5\": \"ma13(#11#5)\",\n  \"maj13(+11+5)\": \"ma13(#11#5)\",\n  \"+13(#11#5)\": \"ma13(#11#5)\",\n  \"+13#11#5\": \"ma13(#11#5)\",\n  \"M13+11+5\": \"ma13(#11#5)\",\n  \"+13(+11+5)\": \"ma13(#11#5)\",\n  \"maj13(#11#5)\": \"ma13(#11#5)\",\n  \"ma7#11#5\": \"ma9(#11#5)\",\n  \"ma13+11+5\": \"ma13(#11#5)\",\n  \"ma13(+11+5)\": \"ma13(#11#5)\",\n  \"ma13(#5)\": \"ma13(#5)\",\n  \"maj13#5\": \"ma13(#5)\",\n  \"maj13+5\": \"ma13(#5)\",\n  \"maj13(+5)\": \"ma13(#5)\",\n  \"+13(#5)\": \"ma13(#5)\",\n  \"+13#5\": \"ma13(#5)\",\n  \"M13+5\": \"ma13(#5)\",\n  \"+13(+5)\": \"ma13(#5)\",\n  \"maj13(#5)\": \"ma13(#5)\",\n  \"ma13#5\": \"ma13(#5)\",\n  \"ma13+5\": \"ma13(#5)\",\n  \"ma13(+5)\": \"ma13(#5)\",\n  \"ma13(#9)\": \"ma13(#9)\",\n  \"maj13#9\": \"ma13(#9)\",\n  \"maj13(+9)\": \"ma13(#9)\",\n  \"maj13+9\": \"ma13(#9)\",\n  \"+13(#9)\": \"ma13(#9)\",\n  \"+13#9\": \"ma13(#9)\",\n  \"M13(+9)\": \"ma13(#9)\",\n  \"+13+9\": \"ma13(#9)\",\n  \"maj13(#9)\": \"ma13(#9)\",\n  \"ma13#9\": \"ma13(#9)\",\n  \"ma13(+9)\": \"ma13(#9)\",\n  \"ma13+9\": \"ma13(#9)\",\n  \"ma13(#9#5)\": \"ma13(#9#5)\",\n  \"maj13#9#5\": \"ma13(#9#5)\",\n  \"maj13(+9+5)\": \"ma13(#9#5)\",\n  \"maj13+9+5\": \"ma13(#9#5)\",\n  \"+13(#9#5)\": \"ma13(#9#5)\",\n  \"+13#9#5\": \"ma13(#9#5)\",\n  \"M13(+9+5)\": \"ma13(#9#5)\",\n  \"+13+9+5\": \"ma13(#9#5)\",\n  \"maj13(#9#5)\": \"ma13(#9#5)\",\n  \"ma7#9#5\": \"ma13(#9#5)\",\n  \"ma13(+9+5)\": \"ma13(#9#5)\",\n  \"ma13+9+5\": \"ma13(#9#5)\",\n  \"ma13(b5)\": \"ma13(b5)\",\n  \"maj13b5\": \"ma13(b5)\",\n  \"maj13-5\": \"ma13(b5)\",\n  \"maj13(-5)\": \"ma13(b5)\",\n  \"+13(b5)\": \"ma13(b5)\",\n  \"+13b5\": \"ma13(b5)\",\n  \"M13-5\": \"ma13(b5)\",\n  \"+13(-5)\": \"ma13(b5)\",\n  \"maj13(b5)\": \"ma13(b5)\",\n  \"ma13b5\": \"ma13(b5)\",\n  \"ma13-5\": \"ma13(b5)\",\n  \"ma13(-5)\": \"ma13(b5)\",\n  \"ma13(b9)\": \"ma13(b9)\",\n  \"maj13b9\": \"ma13(b9)\",\n  \"maj13-9\": \"ma13(b9)\",\n  \"maj13(-9)\": \"ma13(b9)\",\n  \"+13(b9)\": \"ma13(b9)\",\n  \"+13b9\": \"ma13(b9)\",\n  \"M13-9\": \"ma13(b9)\",\n  \"+13(-9)\": \"ma13(b9)\",\n  \"maj13(b9)\": \"ma13(b9)\",\n  \"ma13b9\": \"ma13(b9)\",\n  \"ma13-9\": \"ma13(b9)\",\n  \"ma13(-9)\": \"ma13(b9)\",\n  \"ma13(b9#5)\": \"ma13(b9#5)\",\n  \"maj13b9#5\": \"ma13(b9#5)\",\n  \"maj13-9+5\": \"ma13(b9#5)\",\n  \"maj13(-9+5)\": \"ma13(b9#5)\",\n  \"+13(b9#5)\": \"ma13(b9#5)\",\n  \"+13b9#5\": \"ma13(b9#5)\",\n  \"M13-9+5\": \"ma13(b9#5)\",\n  \"+13(-9+5)\": \"ma13(b9#5)\",\n  \"maj13(b9#5)\": \"ma13(b9#5)\",\n  \"ma7b9#5\": \"ma13(b9#5)\",\n  \"ma13-9+5\": \"ma13(b9#5)\",\n  \"ma13(-9+5)\": \"ma13(b9#5)\",\n  \"ma6\": \"ma6\",\n  \"ma6(9)\": \"ma6(9)\",\n  \"ma69\": \"ma6(9)\",\n  \"ma7\": \"ma7\",\n  \"+7\": \"ma7\",\n  \"#7\": \"ma7\",\n  \"M7\": \"ma7\",\n  \"Maj7\": \"ma7\",\n  \"maj7\": \"ma7\",\n  \"(triangle)\": \"ma7\",\n  \"ma7(#11)\": \"ma7(#11)\",\n  \"maj7#11\": \"ma7(#11)\",\n  \"maj7+11\": \"ma7(#11)\",\n  \"maj7(+11)\": \"ma7(#11)\",\n  \"+7(#11)\": \"ma7(#11)\",\n  \"+7#11\": \"ma7(#11)\",\n  \"M7+11\": \"ma7(#11)\",\n  \"+7(+11)\": \"ma7(#11)\",\n  \"maj7(#11)\": \"ma7(#11)\",\n  \"ma7+11\": \"ma7(#11)\",\n  \"ma7(+11)\": \"ma7(#11)\",\n  \"ma7(#4)\": \"ma7(#4)\",\n  \"ma7(#5)\": \"ma7(#5)\",\n  \"maj7#5\": \"ma7(#5)\",\n  \"maj7+5\": \"ma7(#5)\",\n  \"maj7(+5)\": \"ma7(#5)\",\n  \"+7(#5)\": \"ma7(#5)\",\n  \"+7#5\": \"ma7(#5)\",\n  \"M7+5\": \"ma7(#5)\",\n  \"+7(+5)\": \"ma7(#5)\",\n  \"maj7(#5)\": \"ma7(#5)\",\n  \"ma7#5\": \"ma7(#5)\",\n  \"ma7+5\": \"ma7(#5)\",\n  \"ma7(+5)\": \"ma7(#5)\",\n  \"aug(M7)\": \"ma7(#5)\",\n  \"aug(+7)\": \"ma7(#5)\",\n  \"aug(ma7)\": \"ma7(#5)\",\n  \"aug(maj7)\": \"ma7(#5)\",\n  \"ma7(#9)\": \"ma7(#9)\",\n  \"maj7#9\": \"ma7(#9)\",\n  \"maj7+9\": \"ma7(#9)\",\n  \"maj7(+9)\": \"ma7(#9)\",\n  \"+7(#9)\": \"ma7(#9)\",\n  \"+7#9\": \"ma7(#9)\",\n  \"M7+9\": \"ma7(#9)\",\n  \"+7(+9)\": \"ma7(#9)\",\n  \"maj7(#9)\": \"ma7(#9)\",\n  \"ma7#9\": \"ma7(#9)\",\n  \"ma7+9\": \"ma7(#9)\",\n  \"ma7(+9)\": \"ma7(#9)\",\n  \"ma7(b13)\": \"ma7(b13)\",\n  \"maj7b13\": \"ma7(b13)\",\n  \"maj7-13\": \"ma7(b13)\",\n  \"maj7(-13)\": \"ma7(b13)\",\n  \"+7(b13)\": \"ma7(b13)\",\n  \"+7b13\": \"ma7(b13)\",\n  \"M7-13\": \"ma7(b13)\",\n  \"+7(-13)\": \"ma7(b13)\",\n  \"maj7(b13)\": \"ma7(b13)\",\n  \"ma7b13\": \"ma9(b13)\",\n  \"ma7-13\": \"ma7(b13)\",\n  \"ma7(-13)\": \"ma7(b13)\",\n  \"ma7(b5)\": \"ma7(b5)\",\n  \"maj7b5\": \"ma7(b5)\",\n  \"maj7-5\": \"ma7(b5)\",\n  \"maj7(-5)\": \"ma7(b5)\",\n  \"+7(b5)\": \"ma7(b5)\",\n  \"+7b5\": \"ma7(b5)\",\n  \"M7-5\": \"ma7(b5)\",\n  \"+7(-5)\": \"ma7(b5)\",\n  \"maj7(b5)\": \"ma7(b5)\",\n  \"ma7b5\": \"ma7(b5)\",\n  \"ma7-5\": \"ma7(b5)\",\n  \"ma7(-5)\": \"ma7(b5)\",\n  \"ma7(b9)\": \"ma7(b9)\",\n  \"maj7b9\": \"ma7(b9)\",\n  \"maj7-9\": \"ma7(b9)\",\n  \"maj7(-9)\": \"ma7(b9)\",\n  \"+7(b9)\": \"ma7(b9)\",\n  \"+7b9\": \"ma7(b9)\",\n  \"M7-9\": \"ma7(b9)\",\n  \"+7(-9)\": \"ma7(b9)\",\n  \"maj7(b9)\": \"ma7(b9)\",\n  \"ma7b9\": \"ma7(b9)\",\n  \"ma7-9\": \"ma7(b9)\",\n  \"ma7(-9)\": \"ma7(b9)\",\n  \"ma7(no3)\": \"ma7(no3)\",\n  \"9(#7)\": \"ma9\",\n  \"+9\": \"ma9\",\n  \"M9\": \"ma9\",\n  \"ma9(#11)\": \"ma9(#11)\",\n  \"maj9#11\": \"ma9(#11)\",\n  \"maj9+11\": \"ma9(#11)\",\n  \"maj9(+11)\": \"ma9(#11)\",\n  \"+9(#11)\": \"ma9(#11)\",\n  \"+9#11\": \"ma9(#11)\",\n  \"M9+11\": \"ma9(#11)\",\n  \"+9(+11)\": \"ma9(#11)\",\n  \"maj9(#11)\": \"ma9(#11)\",\n  \"ma9+11\": \"ma9(#11)\",\n  \"ma9(+11)\": \"ma9(#11)\",\n  \"ma9(#11#5)\": \"ma9(#11#5)\",\n  \"maj9#11#5\": \"ma9(#11#5)\",\n  \"maj9+11+5\": \"ma9(#11#5)\",\n  \"maj9(+11+5)\": \"ma9(#11#5)\",\n  \"+9(#11#5)\": \"ma9(#11#5)\",\n  \"+9#11#5\": \"ma9(#11#5)\",\n  \"M9+11+5\": \"ma9(#11#5)\",\n  \"+9(+11+5)\": \"ma9(#11#5)\",\n  \"maj9(#11#5)\": \"ma9(#11#5)\",\n  \"ma9+11+5\": \"ma9(#11#5)\",\n  \"ma9(+11+5)\": \"ma9(#11#5)\",\n  \"ma9(#4)\": \"ma9(#4)\",\n  \"ma9(#5)\": \"ma9(#5)\",\n  \"maj9#5\": \"ma9(#5)\",\n  \"maj9+5\": \"ma9(#5)\",\n  \"maj9(+5)\": \"ma9(#5)\",\n  \"+9(#5)\": \"ma9(#5)\",\n  \"+9#5\": \"ma9(#5)\",\n  \"M9+5\": \"ma9(#5)\",\n  \"+9(+5)\": \"ma9(#5)\",\n  \"maj9(#5)\": \"ma9(#5)\",\n  \"ma9#5\": \"ma9(#5)\",\n  \"ma9+5\": \"ma9(#5)\",\n  \"ma9(+5)\": \"ma9(#5)\",\n  \"ma9(13)\": \"ma9(13)\",\n  \"ma9(b13)\": \"ma9(b13)\",\n  \"maj9b13\": \"ma9(b13)\",\n  \"maj9-13\": \"ma9(b13)\",\n  \"maj9(-13)\": \"ma9(b13)\",\n  \"+9(b13)\": \"ma9(b13)\",\n  \"+9b13\": \"ma9(b13)\",\n  \"M9-13\": \"ma9(b13)\",\n  \"+9(-13)\": \"ma9(b13)\",\n  \"maj9(b13)\": \"ma9(b13)\",\n  \"ma9-13\": \"ma9(b13)\",\n  \"ma9(-13)\": \"ma9(b13)\",\n  \"ma9(b13#5)\": \"ma9(b13#5)\",\n  \"maj9b13#5\": \"ma9(b13#5)\",\n  \"maj9-13+5\": \"ma9(b13#5)\",\n  \"maj9(-13+5)\": \"ma9(b13#5)\",\n  \"+9(b13#5)\": \"ma9(b13#5)\",\n  \"+9b13#5\": \"ma9(b13#5)\",\n  \"M9-13+5\": \"ma9(b13#5)\",\n  \"+9(-13+5)\": \"ma9(b13#5)\",\n  \"maj9(b13#5)\": \"ma9(b13#5)\",\n  \"ma7b13#5\": \"ma9(b13#5)\",\n  \"ma9-13+5\": \"ma9(b13#5)\",\n  \"ma9(-13+5)\": \"ma9(b13#5)\",\n  \"ma9(b5)\": \"ma9(b5)\",\n  \"maj9b5\": \"ma9(b5)\",\n  \"maj9-5\": \"ma9(b5)\",\n  \"maj9(-5)\": \"ma9(b5)\",\n  \"+9(b5)\": \"ma9(b5)\",\n  \"+9b5\": \"ma9(b5)\",\n  \"M9-5\": \"ma9(b5)\",\n  \"+9(-5)\": \"ma9(b5)\",\n  \"maj9(b5)\": \"ma9(b5)\",\n  \"ma9b5\": \"ma9(b5)\",\n  \"ma9-5\": \"ma9(b5)\",\n  \"ma9(-5)\": \"ma9(b5)\",\n  \"sus\": \"sus\",\n  \"sus4\": \"sus\",\n  \"sus(no5)\": \"sus(no5)\",\n  \"sus#42\": \"sus#42\"\n};\n\nexport default mapping;","import Formatter from './formatter';\nimport Tag from '../chord_sheet/tag';\nimport ChordLyricsPair from '../chord_sheet/chord_lyrics_pair';\nimport Ternary from '../chord_sheet/chord_pro/ternary';\nimport Literal from '../chord_sheet/chord_pro/literal';\nimport Song from '../chord_sheet/song';\nimport Line from '../chord_sheet/line';\nimport Metadata from '../chord_sheet/metadata';\nimport Item from '../chord_sheet/item';\nimport Evaluatable from '../chord_sheet/chord_pro/evaluatable';\n\nconst NEW_LINE = '\\n';\n\n/**\n * Formats a song into a ChordPro chord sheet\n */\nclass ChordProFormatter extends Formatter {\n  /**\n   * Formats a song into a ChordPro chord sheet.\n   * @param {Song} song The song to be formatted\n   * @returns {string} The ChordPro string\n   */\n  format(song: Song): string {\n    const { lines, metadata } = song;\n\n    return lines\n      .map((line) => this.formatLine(line, metadata))\n      .join(NEW_LINE);\n  }\n\n  formatLine(line: Line, metadata: Metadata): string {\n    return line.items\n      .map((item) => this.formatItem(item, metadata))\n      .join('');\n  }\n\n  formatItem(item: Item, metadata: Metadata): string {\n    if (item instanceof Tag) {\n      return this.formatTag(item);\n    }\n\n    if (item instanceof ChordLyricsPair) {\n      return this.formatChordLyricsPair(item);\n    }\n\n    if ('evaluate' in item) {\n      return this.formatOrEvaluateItem(item, metadata);\n    }\n\n    throw new Error(`Don't know how to format a ${item.constructor.name}`);\n  }\n\n  formatOrEvaluateItem(item: Evaluatable, metadata: Metadata): string {\n    if (this.configuration.evaluate) {\n      return item.evaluate(metadata, this.configuration.get('metadata.separator'));\n    }\n\n    if (item instanceof Ternary) {\n      return this.formatTernary(item);\n    }\n\n    if (item instanceof Literal) {\n      return item.evaluate();\n    }\n\n    throw new Error(`Don't know how to format a ${item.constructor.name}`);\n  }\n\n  formatTernary(ternary: Ternary): string {\n    const {\n      variable,\n      valueTest,\n      trueExpression,\n      falseExpression,\n    } = ternary;\n\n    return [\n      '%{',\n      variable || '',\n      this.formatValueTest(valueTest),\n      this.formatExpressionRange(trueExpression),\n      this.formatExpressionRange(falseExpression),\n      '}',\n    ].join('');\n  }\n\n  formatValueTest(valueTest: string | null): string {\n    if (!valueTest) {\n      return '';\n    }\n\n    return `=${valueTest}`;\n  }\n\n  formatExpressionRange(expressionRange: Evaluatable[]): string {\n    if (!expressionRange.length) {\n      return '';\n    }\n\n    return `|${expressionRange.map((expression) => this.formatExpression(expression)).join('')}`;\n  }\n\n  formatExpression(expression: Evaluatable): string {\n    if (expression instanceof Ternary) {\n      return this.formatTernary(expression);\n    }\n\n    if (expression instanceof Literal) {\n      return expression.string;\n    }\n\n    return '';\n  }\n\n  formatTag(tag): string {\n    if (tag.hasValue()) {\n      return `{${tag.originalName}: ${tag.value}}`;\n    }\n\n    return `{${tag.originalName}}`;\n  }\n\n  formatChordLyricsPair(chordLyricsPair): string {\n    return [\n      this.formatChordLyricsPairChords(chordLyricsPair),\n      this.formatChordLyricsPairLyrics(chordLyricsPair),\n    ].join('');\n  }\n\n  formatChordLyricsPairChords(chordLyricsPair): string {\n    if (chordLyricsPair.chords) {\n      return `[${chordLyricsPair.chords}]`;\n    }\n\n    return '';\n  }\n\n  formatChordLyricsPairLyrics(chordLyricsPair): string {\n    return chordLyricsPair.lyrics || '';\n  }\n}\n\nexport default ChordProFormatter;\n","import Configuration, { ConfigurationProperties } from './configuration/configuration';\n\n/**\n * Base class for all formatters, taking care of receiving a configuration wrapping that inside a Configuration object\n */\nclass Formatter {\n  configuration: Configuration;\n\n  /**\n     * Instantiate\n     * @param {Object} [configuration={}] options\n     * @param {boolean} [configuration.evaluate=false] Whether or not to evaluate meta expressions.\n     * For more info about meta expressions, see: https://bit.ly/2SC9c2u\n     * @param {object} [configuration.metadata={}]\n     * @param {string} [configuration.metadata.separator=\", \"] The separator to be used when rendering a\n     * metadata value that has multiple values. See: https://bit.ly/2SC9c2u\n     * @param {Key|string} [configuration.key=null] The key to use for rendering. The chord sheet will be\n     * transposed from the song's original key (as indicated by the `{key}` directive) to the specified key.\n     * Note that transposing will only work if the original song key is set.\n     * @param {boolean} [configuration.expandChorusDirective=false] Whether or not to expand `{chorus}` directives\n     * by rendering the last defined chorus inline after the directive.\n     * @param {boolean} [configuration.useUnicodeModifiers=false] Whether or not to use unicode flat and sharp\n     * symbols.\n     * @param {boolean} [configuration.normalizeChords=true] Whether or not to automatically normalize chords\n     */\n  constructor(configuration: ConfigurationProperties | null = null) {\n    this.configuration = new Configuration(configuration || {});\n  }\n}\n\nexport default Formatter;\n","import lodashGet from 'lodash.get';\n\nimport MetadataConfiguration from './metadata_configuration';\nimport Key from '../../key';\n\nexport type ConfigurationProperties = Record<string, any> & {\n  evaluate?: boolean,\n  metadata?: {\n    separator: string,\n  },\n  key?: Key | string | null,\n  expandChorusDirective?: boolean,\n  useUnicodeModifiers?: boolean,\n  normalizeChords?: boolean,\n}\n\nexport const defaultConfiguration: ConfigurationProperties = {\n  evaluate: false,\n  metadata: { separator: ',' },\n  key: null,\n  expandChorusDirective: false,\n  useUnicodeModifiers: false,\n  normalizeChords: true,\n};\n\nclass Configuration {\n  metadata: MetadataConfiguration;\n\n  evaluate: boolean;\n\n  key: Key | null;\n\n  configuration: Record<string, any>;\n\n  expandChorusDirective: boolean;\n\n  useUnicodeModifiers: boolean;\n\n  normalizeChords: boolean;\n\n  constructor(configuration: ConfigurationProperties = defaultConfiguration) {\n    const mergedConfig: ConfigurationProperties = { ...defaultConfiguration, ...configuration };\n    this.evaluate = !!mergedConfig.evaluate;\n    this.expandChorusDirective = !!mergedConfig.expandChorusDirective;\n    this.useUnicodeModifiers = !!mergedConfig.useUnicodeModifiers;\n    this.normalizeChords = !!mergedConfig.normalizeChords;\n    this.metadata = new MetadataConfiguration(configuration.metadata);\n    this.key = configuration.key ? Key.wrap(configuration.key) : null;\n    this.configuration = configuration;\n  }\n\n  get(key: string): string {\n    return lodashGet(this, key);\n  }\n}\n\nexport default Configuration;\n","interface MetadataConfigurationProperties {\n  separator?: string;\n}\n\nexport const defaultMetadataConfiguration: MetadataConfigurationProperties = {\n  separator: ',',\n};\n\nclass MetadataConfiguration {\n  separator?: string;\n\n  constructor(metadataConfiguration: MetadataConfigurationProperties = defaultMetadataConfiguration) {\n    this.separator = metadataConfiguration.separator;\n  }\n}\n\nexport default MetadataConfiguration;\n","/**\n * Album meta directive. See https://www.chordpro.org/chordpro/directives-album/\n * @type {string}\n */\nimport AstComponent from './ast_component';\nimport TraceInfo from './trace_info';\n\nexport const ALBUM = 'album';\n\n/**\n * Artist meta directive. See https://www.chordpro.org/chordpro/directives-artist/\n * @type {string}\n */\nexport const ARTIST = 'artist';\n\n/**\n * Capo meta directive. See https://www.chordpro.org/chordpro/directives-capo/\n * @type {string}\n */\nexport const CAPO = 'capo';\n\n/**\n * Comment directive. See https://www.chordpro.org/chordpro/directives-comment/\n * @type {string}\n */\nexport const COMMENT = 'comment';\n\n/**\n * Composer meta directive. See https://www.chordpro.org/chordpro/directives-composer/\n * @type {string}\n */\nexport const COMPOSER = 'composer';\n\n/**\n * Copyright meta directive. See https://www.chordpro.org/chordpro/directives-copyright/\n * @type {string}\n */\nexport const COPYRIGHT = 'copyright';\n\n/**\n * Duration meta directive. See https://www.chordpro.org/chordpro/directives-duration/\n * @type {string}\n */\nexport const DURATION = 'duration';\n\n/**\n * End of bridge directive. See https://chordpro.org/chordpro/directives-env_bridge/\n * @type {string}\n */\nexport const END_OF_BRIDGE = 'end_of_bridge';\n\n/**\n * End of chorus directive. See https://www.chordpro.org/chordpro/directives-env_chorus/\n * @type {string}\n */\nexport const END_OF_CHORUS = 'end_of_chorus';\n\n/**\n * End of tab directive. See https://www.chordpro.org/chordpro/directives-env_tab/\n * @type {string}\n */\nexport const END_OF_TAB = 'end_of_tab';\n\n/**\n * End of verse directive. See https://www.chordpro.org/chordpro/directives-env_verse/\n * @type {string}\n */\nexport const END_OF_VERSE = 'end_of_verse';\n\n/**\n * Key meta directive. See https://www.chordpro.org/chordpro/directives-key/\n * @type {string}\n */\nexport const KEY = 'key';\n\n/**\n * _Key meta directive. Reflects the key as transposed by the capo value\n * See https://www.chordpro.org/chordpro/directives-key/\n * @type {string}\n */\nexport const _KEY = '_key';\n\n/**\n * Lyricist meta directive. See https://www.chordpro.org/chordpro/directives-lyricist/\n * @type {string}\n */\nexport const LYRICIST = 'lyricist';\n\n/**\n * Start of bridge directive. See https://chordpro.org/chordpro/directives-env_bridge/\n * @type {string}\n */\nexport const START_OF_BRIDGE = 'start_of_bridge';\n\n/**\n * Start of chorus directive. See https://www.chordpro.org/chordpro/directives-env_chorus/\n * @type {string}\n */\nexport const START_OF_CHORUS = 'start_of_chorus';\n\n/**\n * Start of tab directive. See https://www.chordpro.org/chordpro/directives-env_tab/\n * @type {string}\n */\nexport const START_OF_TAB = 'start_of_tab';\n\n/**\n * Start of verse directive. See https://www.chordpro.org/chordpro/directives-env_verse/\n * @type {string}\n */\nexport const START_OF_VERSE = 'start_of_verse';\n\n/**\n * Subtitle meta directive. See https://www.chordpro.org/chordpro/directives-subtitle/\n * @type {string}\n */\nexport const SUBTITLE = 'subtitle';\n\n/**\n * Tempo meta directive. See https://www.chordpro.org/chordpro/directives-tempo/\n * @type {string}\n */\nexport const TEMPO = 'tempo';\n\n/**\n * Time meta directive. See https://www.chordpro.org/chordpro/directives-time/\n * @type {string}\n */\nexport const TIME = 'time';\n\n/**\n * Title meta directive. See https://www.chordpro.org/chordpro/directives-title/\n * @type {string}\n */\nexport const TITLE = 'title';\n\n/**\n * Transpose meta directive. See: https://www.chordpro.org/chordpro/directives-transpose/\n * @type {string}\n */\nexport const TRANSPOSE = 'transpose';\n/**\n * New Key meta directive. See: https://github.com/PraiseCharts/ChordChartJS/issues/53\n * @type {string}\n */\nexport const NEW_KEY = 'new_key';\n\n/**\n * Year meta directive. See https://www.chordpro.org/chordpro/directives-year/\n * @type {string}\n */\nexport const YEAR = 'year';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_chord_legacy/\n * @type {string}\n */\nexport const CHORDFONT = 'chordfont';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_chord_legacy/\n * @type {string}\n */\nexport const CHORDSIZE = 'chordsize';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_chord_legacy/\n * @type {string}\n */\nexport const CHORDCOLOUR = 'chordcolour';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_text_legacy/\n * @type {string}\n */\nexport const TEXTFONT = 'textfont';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_text_legacy/\n * @type {string}\n */\nexport const TEXTSIZE = 'textsize';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_text_legacy/\n * @type {string}\n */\nexport const TEXTCOLOUR = 'textcolour';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_title_legacy/\n * @type {string}\n */\nexport const TITLEFONT = 'titlefont';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_title_legacy/\n * @type {string}\n */\nexport const TITLESIZE = 'titlesize';\n\n/**\n * Chordfont directive. See https://www.chordpro.org/chordpro/directives-props_title_legacy/\n * @type {string}\n */\nexport const TITLECOLOUR = 'titlecolour';\n\n/**\n * Chorus directive. Support repeating an earlier defined section.\n * See https://www.chordpro.org/chordpro/directives-env_chorus/\n * @type {string}\n */\nexport const CHORUS = 'chorus';\n\nconst TITLE_SHORT = 't';\nconst SUBTITLE_SHORT = 'st';\nconst COMMENT_SHORT = 'c';\nconst START_OF_CHORUS_SHORT = 'soc';\nconst END_OF_CHORUS_SHORT = 'eoc';\nconst START_OF_TAB_SHORT = 'sot';\nconst END_OF_TAB_SHORT = 'eot';\nconst NEW_KEY_SHORT = 'nk';\nconst CHORDFONT_SHORT = 'cf';\nconst CHORDSIZE_SHORT = 'cs';\nconst TEXTFONT_SHORT = 'tf';\nconst TEXTSIZE_SHORT = 'ts';\n\nconst RENDERABLE_TAGS = [COMMENT];\n\nexport const META_TAGS = [\n  ALBUM,\n  ARTIST,\n  CAPO,\n  COMPOSER,\n  COPYRIGHT,\n  DURATION,\n  KEY,\n  LYRICIST,\n  TEMPO,\n  TIME,\n  TITLE,\n  SUBTITLE,\n  YEAR,\n];\n\nexport const READ_ONLY_TAGS = [_KEY];\n\nconst SECTION_DELIMITERS = [\n  START_OF_CHORUS,\n  END_OF_CHORUS,\n  START_OF_TAB,\n  END_OF_TAB,\n  START_OF_VERSE,\n  END_OF_VERSE,\n];\n\nconst INLINE_FONT_TAGS = [\n  CHORDFONT,\n  CHORDSIZE,\n  CHORDCOLOUR,\n  TEXTFONT,\n  TEXTSIZE,\n  TEXTCOLOUR,\n];\n\nconst DIRECTIVES_WITH_RENDERABLE_LABEL = [\n  START_OF_VERSE,\n  START_OF_CHORUS,\n  START_OF_BRIDGE,\n  START_OF_TAB,\n  CHORUS,\n];\n\nconst ALIASES: Record<string, string> = {\n  [TITLE_SHORT]: TITLE,\n  [SUBTITLE_SHORT]: SUBTITLE,\n  [COMMENT_SHORT]: COMMENT,\n  [START_OF_CHORUS_SHORT]: START_OF_CHORUS,\n  [END_OF_CHORUS_SHORT]: END_OF_CHORUS,\n  [START_OF_TAB_SHORT]: START_OF_TAB,\n  [END_OF_TAB_SHORT]: END_OF_TAB,\n  [NEW_KEY_SHORT]: NEW_KEY,\n  [CHORDFONT_SHORT]: CHORDFONT,\n  [CHORDSIZE_SHORT]: CHORDSIZE,\n  [TEXTFONT_SHORT]: TEXTFONT,\n  [TEXTSIZE_SHORT]: TEXTSIZE,\n};\n\nconst TAG_REGEX = /^([^:\\s]+)(:?\\s*(.+))?$/;\nconst CUSTOM_META_TAG_NAME_REGEX = /^x_(.+)$/;\n\nexport function isReadonlyTag(tagName: string) {\n  return READ_ONLY_TAGS.includes(tagName);\n}\n\nconst translateTagNameAlias = (name: string) => {\n  if (!name) {\n    return name;\n  }\n\n  const sanitizedName = name.trim();\n\n  if (sanitizedName in ALIASES) {\n    return ALIASES[sanitizedName];\n  }\n\n  return sanitizedName;\n};\n\n/**\n * Represents a tag/directive. See https://www.chordpro.org/chordpro/chordpro-directives/\n */\nclass Tag extends AstComponent {\n  _originalName = '';\n\n  _name = '';\n\n  _value = '';\n\n  _isMetaTag = false;\n\n  constructor(name: string, value: string | null = null, traceInfo: TraceInfo | null = null) {\n    super(traceInfo);\n    this.parseNameValue(name, value);\n  }\n\n  private parseNameValue(name: string, value: string | null): void {\n    if (name === 'meta') {\n      this.parseMetaTag(value);\n    } else {\n      this.name = name;\n      this.value = value || '';\n    }\n  }\n\n  private parseMetaTag(value: string | null) {\n    if (!value) {\n      throw new Error('Expected value');\n    }\n\n    const [metaName, metaValue] = value.split(/\\s(.+)/);\n    this.name = metaName;\n    this.value = metaValue || '';\n    this._isMetaTag = true;\n  }\n\n  static parse(tag: string | Tag): Tag | null {\n    if (tag instanceof Tag) {\n      return tag;\n    }\n\n    return this.parseWithRegex(tag, TAG_REGEX);\n  }\n\n  static parseWithRegex(tag: string, regex: RegExp): Tag | null {\n    const matches = tag.match(regex);\n\n    if (matches !== null) {\n      return new Tag(matches[1], matches[3] || null);\n    }\n\n    return null;\n  }\n\n  static parseOrFail(tag: string | Tag): Tag {\n    const parsed = this.parse(tag);\n\n    if (!parsed) {\n      throw new Error(`Failed to parse ${tag}`);\n    }\n\n    return parsed;\n  }\n\n  isSectionDelimiter(): boolean {\n    return SECTION_DELIMITERS.includes(this.name);\n  }\n\n  isInlineFontTag(): boolean {\n    return INLINE_FONT_TAGS.includes(this.name);\n  }\n\n  set name(name) {\n    this._name = translateTagNameAlias(name);\n    this._originalName = name;\n  }\n\n  /**\n   * The tag full name. When the original tag used the short name, `name` will return the full name.\n   * @member\n   * @type {string}\n   */\n  get name() {\n    return this._name.trim();\n  }\n\n  /**\n   * The original tag name that was used to construct the tag.\n   * @member\n   * @type {string}\n   */\n  get originalName() {\n    return this._originalName.trim();\n  }\n\n  set value(value) {\n    this._value = value || '';\n  }\n\n  /**\n   * The tag value\n   * @member\n   * @type {string}\n   */\n  get value(): string {\n    return `${this._value}`.trim();\n  }\n\n  /**\n   * Checks whether the tag value is a non-empty string.\n   * @returns {boolean}\n   */\n  hasValue(): boolean {\n    return this.value.length > 0;\n  }\n\n  /**\n   * Checks whether the tag is usually rendered inline. It currently only applies to comment tags.\n   * @returns {boolean}\n   */\n  isRenderable(): boolean {\n    return RENDERABLE_TAGS.includes(this.name) || this.hasRenderableLabel();\n  }\n\n  /**\n   * Check whether this tag's label (if any) should be rendered, as applicable to tags like\n   * `start_of_verse` and `start_of_chorus`.\n   * See https://chordpro.org/chordpro/directives-env_chorus/, https://chordpro.org/chordpro/directives-env_verse/,\n   * https://chordpro.org/chordpro/directives-env_bridge/, https://chordpro.org/chordpro/directives-env_tab/\n   */\n  hasRenderableLabel(): boolean {\n    return DIRECTIVES_WITH_RENDERABLE_LABEL.includes(this.name) && this.hasValue();\n  }\n\n  /**\n   * Checks whether the tag is either a standard meta tag or a custom meta directive (`{x_some_name}`)\n   * @returns {boolean}\n   */\n  isMetaTag(): boolean {\n    return this._isMetaTag || CUSTOM_META_TAG_NAME_REGEX.test(this.name) || META_TAGS.indexOf(this.name) !== -1;\n  }\n\n  /**\n   * Returns a clone of the tag.\n   * @returns {Tag} The cloned tag\n   */\n  clone(): Tag {\n    return new Tag(this._originalName, this.value);\n  }\n\n  toString(): string {\n    return `Tag(name=${this.name}, value=${this.value})`;\n  }\n\n  set({ value }: { value: string }): Tag {\n    return new Tag(this._originalName, value);\n  }\n}\n\nexport default Tag;\n","import TraceInfo from './trace_info';\n\nabstract class AstComponent {\n  line: number | null = null;\n\n  column: number | null = null;\n\n  offset: number | null = null;\n\n  protected constructor(traceInfo: TraceInfo | null = null) {\n    if (traceInfo) {\n      this.line = traceInfo.line || null;\n      this.column = traceInfo.column || null;\n      this.offset = traceInfo.offset || null;\n    }\n  }\n\n  abstract clone(): AstComponent;\n}\n\nexport default AstComponent;\n","import EvaluationError from './evaluation_error';\nimport { isEmptyString } from '../../utilities';\nimport Composite from './composite';\nimport TraceInfo from '../trace_info';\nimport Evaluatable from './evaluatable';\nimport Metadata from '../metadata';\n\nexport type TernaryProperties = TraceInfo & {\n  variable?: string | null;\n  valueTest?: string | null;\n  trueExpression?: Evaluatable[];\n  falseExpression?: Evaluatable[];\n}\n\nclass Ternary extends Evaluatable {\n  variable: string | null;\n\n  valueTest: string | null;\n\n  trueExpression: Evaluatable[] = [];\n\n  falseExpression: Evaluatable[] = [];\n\n  constructor(\n    {\n      variable = null,\n      valueTest = null,\n      trueExpression = [],\n      falseExpression = [],\n      line = null,\n      column = null,\n      offset = null,\n    }: TernaryProperties,\n  ) {\n    super({ line, column, offset });\n    this.variable = variable || null;\n    this.valueTest = valueTest || null;\n    this.trueExpression = trueExpression;\n    this.falseExpression = falseExpression;\n  }\n\n  /**\n   * Evaluate the meta expression\n   * @param {Metadata} metadata The metadata object to use for evaluating the expression\n   * @param {string} [metadataSeparator=null] The metadata separator to use if necessary\n   * @returns {string} The evaluated expression\n   */\n  evaluate(metadata: Metadata, metadataSeparator: string, upperContext: string | null = null): string {\n    if (this.variable) {\n      return this.evaluateWithVariable(metadata, metadataSeparator);\n    }\n\n    if (!upperContext) {\n      throw new EvaluationError('Unexpected empty expression', this.line, this.column, this.offset);\n    }\n\n    return this.evaluateToString(metadata.get(upperContext) || '', metadataSeparator);\n  }\n\n  evaluateToString(value: string[] | string, metadataSeparator: string): string {\n    if (Array.isArray(value)) {\n      return value.join(metadataSeparator);\n    }\n\n    return value;\n  }\n\n  evaluateWithVariable(metadata: Metadata, metadataSeparator: string): string {\n    if (!this.variable) {\n      throw new Error('Expected this.variable to be present');\n    }\n\n    const value = metadata.get(this.variable);\n\n    if (value && (isEmptyString(this.valueTest) || value === this.valueTest)) {\n      return this.evaluateForTruthyValue(metadata, metadataSeparator, value);\n    }\n\n    if (this.falseExpression.length) {\n      return new Composite(this.falseExpression, this.variable).evaluate(metadata, metadataSeparator);\n    }\n\n    return '';\n  }\n\n  evaluateForTruthyValue(metadata: Metadata, metadataSeparator: string, value: string | string[]): string {\n    if (this.trueExpression.length) {\n      return new Composite(this.trueExpression, this.variable).evaluate(metadata, metadataSeparator);\n    }\n\n    return this.evaluateToString(value, metadataSeparator);\n  }\n\n  isRenderable(): boolean {\n    return true;\n  }\n\n  clone(): Ternary {\n    return new Ternary({\n      variable: this.variable,\n      valueTest: this.valueTest,\n      trueExpression: this.trueExpression.map((part) => part.clone()),\n      falseExpression: this.falseExpression.map((part) => part.clone()),\n      line: this.line,\n      column: this.column,\n      offset: this.offset,\n    });\n  }\n}\n\nexport default Ternary;\n","class EvaluationError extends Error {\n  line: number | null = null;\n\n  column: number | null = null;\n\n  offset: number | null = null;\n\n  constructor(message: string, line: number | null = null, column: number | null = null, offset: number | null = null) {\n    super(`${message} on line ${line} column ${column}`);\n    this.name = 'ExpressionError';\n    this.line = line;\n    this.column = column;\n    this.offset = offset;\n  }\n}\n\nexport default EvaluationError;\n","import Evaluatable from './evaluatable';\nimport Metadata from '../metadata';\n\nclass Composite extends Evaluatable {\n  expressions: Evaluatable[] = [];\n\n  variable: string | null;\n\n  constructor(expressions: Evaluatable[], variable: string | null = null) {\n    super();\n    this.expressions = expressions;\n    this.variable = variable;\n  }\n\n  evaluate(metadata: Metadata, metadataSeparator: string): string {\n    return this.expressions.map((expression) => (\n      expression.evaluate(metadata, metadataSeparator, this.variable)\n    )).join('');\n  }\n\n  isRenderable(): boolean {\n    return true;\n  }\n\n  clone(): Composite {\n    return new Composite(\n      this.expressions.map((expression) => expression.clone()),\n      this.variable,\n    );\n  }\n}\n\nexport default Composite;\n","import AstComponent from '../ast_component';\nimport Metadata from '../metadata';\n\nabstract class Evaluatable extends AstComponent {\n  abstract evaluate(_metadata: Metadata, _metadataSeparator: string, _variable?: string | null): string;\n\n  abstract clone(): Evaluatable;\n}\n\nexport default Evaluatable;\n","import Evaluatable from './evaluatable';\n\nclass Literal extends Evaluatable {\n  string: string;\n\n  constructor(expression: string) {\n    super();\n    this.string = expression;\n  }\n\n  evaluate(): string {\n    return this.string;\n  }\n\n  isRenderable(): boolean {\n    return true;\n  }\n\n  clone(): Literal {\n    return new Literal(this.string);\n  }\n}\n\nexport default Literal;\n","import PegBasedParser from './peg_based_parser';\nimport { parse } from './chord_pro_peg_parser';\nimport Song from '../chord_sheet/song';\n\n/**\n * Parses a ChordPro chord sheet\n */\nclass ChordProParser extends PegBasedParser {\n  /**\n   * Parses a ChordPro chord sheet into a song\n   * @param {string} chordProChordSheet the ChordPro chord sheet\n   * @returns {Song} The parsed song\n   */\n  parse(chordProChordSheet: string): Song {\n    return this.parseWithParser(chordProChordSheet, parse);\n  }\n}\n\nexport default ChordProParser;\n","// eslint-disable-next-line import/no-cycle\nimport { Song } from '../index';\nimport ChordSheetSerializer from '../chord_sheet_serializer';\nimport ParserWarning from './parser_warning';\nimport { normalizeLineEndings } from '../utilities';\n\ninterface IParseOptions {\n  filename?: string;\n  startRule?: string;\n  tracer?: any;\n  [key: string]: any;\n}\nexport type ParseFunction = (_input: string, _options?: IParseOptions) => any;\n\n/**\n * Parses a chords over words sheet\n */\nclass PegBasedParser {\n  song: Song = new Song();\n\n  /**\n   * All warnings raised during parsing the chord sheet\n   * @member\n   * @type {ParserWarning[]}\n   */\n  get warnings(): ParserWarning[] {\n    return this.song.warnings;\n  }\n\n  protected parseWithParser(chordSheet: string, parser: ParseFunction): Song {\n    const ast = parser(normalizeLineEndings(chordSheet));\n    this.song = new ChordSheetSerializer().deserialize(ast);\n    return this.song;\n  }\n}\n\nexport default PegBasedParser;\n","import Literal from './chord_sheet/chord_pro/literal';\nimport Song from './chord_sheet/song';\nimport ChordLyricsPair from './chord_sheet/chord_lyrics_pair';\nimport Tag from './chord_sheet/tag';\nimport Comment from './chord_sheet/comment';\nimport Ternary from './chord_sheet/chord_pro/ternary';\nimport Chord from './chord';\nimport Line from './chord_sheet/line';\nimport AstType from './chord_sheet/ast_type';\nimport Item from './chord_sheet/item';\nimport Evaluatable from './chord_sheet/chord_pro/evaluatable';\nimport { Modifier } from './constants';\n\nconst CHORD_SHEET = 'chordSheet';\nconst CHORD_LYRICS_PAIR = 'chordLyricsPair';\nconst TAG = 'tag';\nconst COMMENT = 'comment';\nconst TERNARY = 'ternary';\nconst LINE = 'line';\n\ntype SerializedTraceInfo = {\n  location?: {\n    offset: number | null,\n    line: number | null,\n    column: number | null,\n  },\n};\n\ntype SerializedChord = {\n  type: 'chord',\n  base: string,\n  modifier: Modifier | null,\n  suffix: string | null,\n  bassBase: string | null,\n  bassModifier: Modifier | null,\n  chordType: string,\n};\n\nexport type SerializedChordLyricsPair = {\n  type: 'chordLyricsPair',\n  chord?: SerializedChord | null,\n  chords: string,\n  lyrics: string | null,\n};\n\nexport type SerializedTag = SerializedTraceInfo & {\n  type: 'tag',\n  name: string,\n  value: string,\n};\n\ntype SerializedComment = {\n  type: 'comment',\n  comment: string,\n};\n\ntype SerializedLiteral = string;\n\nexport interface SerializedTernary extends SerializedTraceInfo {\n  type: 'ternary',\n  variable: string | null,\n  valueTest: string | null,\n  trueExpression: Array<SerializedLiteral | SerializedTernary>,\n  falseExpression: Array<SerializedLiteral | SerializedTernary>,\n}\n\nexport type SerializedComposite = Array<SerializedLiteral | SerializedTernary>;\n\nexport type SerializedItem = SerializedChordLyricsPair | SerializedTag | SerializedComment | SerializedTernary;\n\ntype SerializedLine = {\n  type: 'line',\n  items: SerializedItem[],\n};\n\nexport type SerializedSong = {\n  type: 'chordSheet',\n  lines: SerializedLine[],\n};\n\ntype SerializedComponent =\n  SerializedLine |\n  SerializedSong |\n  SerializedChordLyricsPair |\n  SerializedTag |\n  SerializedComment |\n  SerializedTernary |\n  SerializedLiteral;\n\n/**\n * Serializes a song into een plain object, and deserializes the serialized object back into a {@link Song}\n */\nclass ChordSheetSerializer {\n  song: Song = new Song();\n\n  /**\n   * Serializes the chord sheet to a plain object, which can be converted to any format like JSON, XML etc\n   * Can be deserialized using {@link deserialize}\n   * @returns object A plain JS object containing all chord sheet data\n   */\n  serialize(song: Song): SerializedSong {\n    return {\n      type: CHORD_SHEET,\n      lines: song.lines.map((line) => this.serializeLine(line)),\n    };\n  }\n\n  serializeLine(line: Line): SerializedLine {\n    return {\n      type: LINE,\n      items: line.items.map((item) => this.serializeItem(item) as SerializedItem),\n    };\n  }\n\n  serializeItem(item: AstType): SerializedComponent {\n    if (item instanceof Tag) {\n      return this.serializeTag(item) as SerializedComponent;\n    }\n\n    if (item instanceof ChordLyricsPair) {\n      return this.serializeChordLyricsPair(item) as SerializedComponent;\n    }\n\n    if (item instanceof Ternary) {\n      return this.serializeTernary(item) as SerializedComponent;\n    }\n\n    if (item instanceof Literal) {\n      return this.serializeLiteral(item);\n    }\n\n    throw new Error(`Don't know how to serialize ${item.constructor.name}`);\n  }\n\n  serializeTag(tag: Tag): SerializedTag {\n    return {\n      type: TAG,\n      name: tag.originalName,\n      value: tag.value,\n    };\n  }\n\n  serializeChordLyricsPair(chordLyricsPair: ChordLyricsPair) {\n    return {\n      type: CHORD_LYRICS_PAIR,\n      chords: chordLyricsPair.chords,\n      chord: null,\n      lyrics: chordLyricsPair.lyrics,\n    };\n  }\n\n  serializeTernary(ternary: Ternary): object {\n    return {\n      type: TERNARY,\n      variable: ternary.variable,\n      valueTest: ternary.valueTest,\n      trueExpression: this.serializeExpression(ternary.trueExpression),\n      falseExpression: this.serializeExpression(ternary.falseExpression),\n    };\n  }\n\n  serializeLiteral(literal: Literal) {\n    return literal.string;\n  }\n\n  serializeExpression(expression: AstType[]) {\n    return expression.map((part) => this.serializeItem(part));\n  }\n\n  /**\n   * Deserializes a song that has been serialized using {@link serialize}\n   * @param {object} serializedSong The serialized song\n   * @returns {Song} The deserialized song\n   */\n  deserialize(serializedSong: SerializedSong): Song {\n    this.parseAstComponent(serializedSong);\n    return this.song;\n  }\n\n  parseAstComponent(astComponent: SerializedComponent): null | ChordLyricsPair | Tag | Comment | Ternary | Literal {\n    if (!astComponent) {\n      return null;\n    }\n\n    if (typeof astComponent === 'string') {\n      return new Literal(astComponent);\n    }\n\n    const { type } = astComponent;\n\n    switch (type) {\n      case CHORD_SHEET:\n        this.parseChordSheet(astComponent);\n        break;\n      case CHORD_LYRICS_PAIR:\n        return this.parseChordLyricsPair(astComponent);\n      case TAG:\n        return this.parseTag(astComponent);\n      case COMMENT:\n        return this.parseComment(astComponent);\n      case TERNARY:\n        return this.parseTernary(astComponent);\n      default:\n        console.warn(`Unhandled AST component \"${type}\"`, astComponent);\n    }\n\n    return null;\n  }\n\n  parseChordSheet(astComponent: SerializedSong): void {\n    const { lines } = astComponent;\n    this.song = new Song();\n    lines.forEach((line) => this.parseLine(line));\n  }\n\n  parseLine(astComponent: SerializedLine): void {\n    const { items } = astComponent;\n    this.song.addLine();\n\n    items.forEach((item) => {\n      const parsedItem = this.parseAstComponent(item) as Item;\n      this.song.addItem(parsedItem);\n    });\n  }\n\n  parseChordLyricsPair(astComponent: SerializedChordLyricsPair): ChordLyricsPair {\n    const { chord, chords, lyrics } = astComponent;\n\n    return new ChordLyricsPair(\n      chord ? new Chord(chord).toString() : chords,\n      lyrics,\n    );\n  }\n\n  parseTag(astComponent: SerializedTag): Tag {\n    const {\n      name,\n      value,\n      location: { offset = null, line = null, column = null } = {},\n    } = astComponent;\n    return new Tag(name, value, { line, column, offset });\n  }\n\n  parseComment(astComponent: SerializedComment): Comment {\n    const { comment } = astComponent;\n    return new Comment(comment);\n  }\n\n  parseTernary(astComponent: SerializedTernary): Ternary {\n    const {\n      variable,\n      valueTest,\n      trueExpression,\n      falseExpression,\n      location: { offset = null, line = null, column = null } = {},\n    } = astComponent;\n\n    return new Ternary({\n      variable,\n      valueTest,\n      trueExpression: this.parseExpression(trueExpression) as Evaluatable[],\n      falseExpression: this.parseExpression(falseExpression) as Evaluatable[],\n      offset,\n      line,\n      column,\n    });\n  }\n\n  parseExpression(expression: Array<SerializedLiteral | SerializedTernary>): Array<AstType | null> {\n    return (expression || [])\n      .map((part) => this.parseAstComponent(part))\n      .filter((part) => part !== null);\n  }\n}\n\nexport default ChordSheetSerializer;\n","import Line, { LineType } from './line';\nimport Paragraph from './paragraph';\nimport Key from '../key';\nimport ChordLyricsPair from './chord_lyrics_pair';\nimport { deprecate } from '../utilities';\nimport Metadata from './metadata';\nimport ParserWarning from '../parser/parser_warning';\nimport MetadataAccessors from './metadata_accessors';\nimport Item from './item';\nimport TraceInfo from './trace_info';\nimport FontStack from './font_stack';\n\nimport {\n  CHORUS, NONE, ParagraphType, TAB, VERSE,\n} from '../constants';\n\nimport Tag, {\n  CAPO,\n  END_OF_CHORUS,\n  END_OF_TAB,\n  END_OF_VERSE,\n  KEY,\n  NEW_KEY,\n  START_OF_CHORUS,\n  START_OF_TAB,\n  START_OF_VERSE,\n  TRANSPOSE,\n  CHORUS as CHORUS_TAG,\n} from './tag';\n\ninterface MapItemsCallback {\n  (_item: Item): Item | null;\n}\n\ninterface MapLinesCallback {\n  (_line: Line): Line | null;\n}\n\n/**\n * Represents a song in a chord sheet. Currently a chord sheet can only have one song.\n */\nclass Song extends MetadataAccessors {\n  /**\n   * The {@link Line} items of which the song consists\n   * @member {Line[]}\n   */\n  lines: Line[] = [];\n\n  /**\n   * The song's metadata. When there is only one value for an entry, the value is a string. Else, the value is\n   * an array containing all unique values for the entry.\n   * @type {Metadata}\n   */\n  metadata: Metadata;\n\n  currentLine: Line | null = null;\n\n  warnings: ParserWarning[] = [];\n\n  sectionType: ParagraphType = NONE;\n\n  fontStack: FontStack = new FontStack();\n\n  currentKey: string | null = null;\n\n  transposeKey: string | null = null;\n\n  _bodyParagraphs: Paragraph[] | null = null;\n\n  _bodyLines: Line[] | null = null;\n\n  /**\n   * Creates a new {Song} instance\n   * @param metadata {Object|Metadata} predefined metadata\n   */\n  constructor(metadata = {}) {\n    super();\n    this.metadata = new Metadata(metadata);\n  }\n\n  get previousLine(): Line | null {\n    const count = this.lines.length;\n\n    if (count >= 2) {\n      return this.lines[count - 2];\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the song lines, skipping the leading empty lines (empty as in not rendering any content). This is useful\n   * if you want to skip the \"header lines\": the lines that only contain meta data.\n   * @returns {Line[]} The song body lines\n   */\n  get bodyLines(): Line[] {\n    if (!this._bodyLines) {\n      this._bodyLines = this.selectRenderableItems(this.lines) as Line[];\n    }\n\n    return this._bodyLines;\n  }\n\n  /**\n   * Returns the song paragraphs, skipping the paragraphs that only contain empty lines\n   * (empty as in not rendering any content)\n   * @see {@link bodyLines}\n   * @returns {Paragraph[]}\n   */\n  get bodyParagraphs(): Paragraph[] {\n    if (!this._bodyParagraphs) {\n      this._bodyParagraphs = this.selectRenderableItems(this.paragraphs) as Paragraph[];\n    }\n\n    return this._bodyParagraphs;\n  }\n\n  selectRenderableItems(items: Array<Line | Paragraph>): Array<Line | Paragraph> {\n    const copy = [...items];\n\n    while (copy.length && !copy[0].hasRenderableItems()) {\n      copy.shift();\n    }\n\n    return copy;\n  }\n\n  chords(chr: string): void {\n    if (!this.currentLine) throw new Error('Expected this.currentLine to be present');\n    this.currentLine.chords(chr);\n  }\n\n  lyrics(chr: string): void {\n    this.ensureLine();\n    if (!this.currentLine) throw new Error('Expected this.currentLine to be present');\n    this.currentLine.lyrics(chr);\n  }\n\n  addLine(line?: Line): Line {\n    if (line) {\n      this.currentLine = line;\n    } else {\n      this.currentLine = new Line();\n      this.lines.push(this.currentLine);\n    }\n\n    this.setCurrentProperties(this.sectionType);\n    this.currentLine.transposeKey = this.transposeKey ?? this.currentKey;\n    this.currentLine.key = this.currentKey || this.metadata.getSingle(KEY);\n    this.currentLine.lineNumber = this.lines.length - 1;\n    return this.currentLine;\n  }\n\n  private expandLine(line: Line): Line[] {\n    const expandedLines = line.items.flatMap((item: Item) => {\n      if (item instanceof Tag && item.name === CHORUS_TAG) {\n        return this.getLastChorusBefore(line.lineNumber);\n      }\n\n      return [];\n    });\n\n    return [line, ...expandedLines];\n  }\n\n  private getLastChorusBefore(lineNumber: number | null): Line[] {\n    const lines: Line[] = [];\n\n    if (!lineNumber) {\n      return lines;\n    }\n\n    for (let i = lineNumber - 1; i >= 0; i -= 1) {\n      const line = this.lines[i];\n\n      if (line.type === CHORUS) {\n        const filteredLine = this.filterChorusStartEndDirectives(line);\n\n        if (!(line.isNotEmpty() && filteredLine.isEmpty())) {\n          lines.unshift(line);\n        }\n      } else if (lines.length > 0) {\n        break;\n      }\n    }\n\n    return lines;\n  }\n\n  private filterChorusStartEndDirectives(line: Line) {\n    return line.mapItems((item: Item) => {\n      if (item instanceof Tag) {\n        if (item.name === START_OF_CHORUS || item.name === END_OF_CHORUS) {\n          return null;\n        }\n      }\n\n      return item;\n    });\n  }\n\n  /**\n   * The {@link Paragraph} items of which the song consists\n   * @member {Paragraph[]}\n   */\n  get paragraphs(): Paragraph[] {\n    return this.linesToParagraphs(this.lines);\n  }\n\n  /**\n   * The body paragraphs of the song, with any `{chorus}` tag expanded into the targetted chorus\n   * @type {Paragraph[]}\n   */\n  get expandedBodyParagraphs(): Paragraph[] {\n    return this.selectRenderableItems(\n      this.linesToParagraphs(\n        this.lines.flatMap((line: Line) => this.expandLine(line)),\n      ),\n    ) as Paragraph[];\n  }\n\n  linesToParagraphs(lines: Line[]) {\n    let currentParagraph = new Paragraph();\n    const paragraphs = [currentParagraph];\n\n    lines.forEach((line) => {\n      if (line.isEmpty()) {\n        currentParagraph = new Paragraph();\n        paragraphs.push(currentParagraph);\n      } else if (line.hasRenderableItems()) {\n        currentParagraph.addLine(line);\n      }\n    });\n\n    return paragraphs;\n  }\n\n  setCurrentProperties(sectionType: ParagraphType): void {\n    if (!this.currentLine) throw new Error('Expected this.currentLine to be present');\n\n    this.currentLine.type = sectionType as LineType;\n    this.currentLine.textFont = this.fontStack.textFont.clone();\n    this.currentLine.chordFont = this.fontStack.chordFont.clone();\n  }\n\n  ensureLine(): void {\n    if (this.currentLine === null) {\n      this.addLine();\n    }\n  }\n\n  addTag(tagContents: string | Tag): Tag {\n    const tag = Tag.parseOrFail(tagContents);\n    this.applyTagOnSong(tag);\n    this.applyTagOnLine(tag);\n    return tag;\n  }\n\n  private applyTagOnLine(tag: Tag) {\n    this.ensureLine();\n    if (!this.currentLine) throw new Error('Expected this.currentLine to be present');\n    this.currentLine.addTag(tag);\n  }\n\n  private applyTagOnSong(tag: Tag) {\n    if (tag.isMetaTag()) {\n      this.setMetadata(tag.name, tag.value || '');\n    } else if (tag.name === TRANSPOSE) {\n      this.transposeKey = tag.value;\n    } else if (tag.name === NEW_KEY) {\n      this.currentKey = tag.value;\n    } else if (tag.isSectionDelimiter()) {\n      this.setSectionTypeFromTag(tag);\n    } else if (tag.isInlineFontTag()) {\n      this.fontStack.applyTag(tag);\n    }\n  }\n\n  setSectionTypeFromTag(tag: Tag): void {\n    switch (tag.name) {\n      case START_OF_CHORUS:\n        this.startSection(CHORUS, tag);\n        break;\n\n      case END_OF_CHORUS:\n        this.endSection(CHORUS, tag);\n        break;\n\n      case START_OF_TAB:\n        this.startSection(TAB, tag);\n        break;\n\n      case END_OF_TAB:\n        this.endSection(TAB, tag);\n        break;\n\n      case START_OF_VERSE:\n        this.startSection(VERSE, tag);\n        break;\n\n      case END_OF_VERSE:\n        this.endSection(VERSE, tag);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  startSection(sectionType: ParagraphType, tag: Tag): void {\n    this.checkCurrentSectionType(NONE, tag);\n    this.sectionType = sectionType;\n    this.setCurrentProperties(sectionType);\n  }\n\n  endSection(sectionType: ParagraphType, tag: Tag): void {\n    this.checkCurrentSectionType(sectionType, tag);\n    this.sectionType = NONE;\n  }\n\n  checkCurrentSectionType(sectionType: ParagraphType, tag: Tag): void {\n    if (this.sectionType !== sectionType) {\n      this.addWarning(`Unexpected tag {${tag.originalName}, current section is: ${this.sectionType}`, tag);\n    }\n  }\n\n  addWarning(message: string, { line, column }: TraceInfo): void {\n    const warning = new ParserWarning(message, line || null, column || null);\n    this.warnings.push(warning);\n  }\n\n  addItem(item: Item): void {\n    if (item instanceof Tag) {\n      this.addTag(item);\n    } else {\n      this.ensureLine();\n      if (!this.currentLine) throw new Error('Expected this.currentLine to be present');\n      this.currentLine.addItem(item);\n    }\n  }\n\n  /**\n   * Returns a deep clone of the song\n   * @returns {Song} The cloned song\n   */\n  clone(): Song {\n    return this.mapItems((item) => item);\n  }\n\n  setMetadata(name: string, value: string): void {\n    this.metadata.add(name, value);\n  }\n\n  /**\n   * The song's metadata. Please use {@link metadata} instead.\n   * @deprecated\n   * @returns {@link Metadata} The metadata\n   */\n  get metaData(): Metadata {\n    deprecate('metaData has been deprecated, please use metadata instead (notice the lowercase \"d\")');\n    return this.metadata;\n  }\n\n  getMetadata(name: string): string | string[] | undefined {\n    return this.metadata.getMetadata(name);\n  }\n\n  getSingleMetadata(name: string): string {\n    return this.metadata.getSingleMetadata(name);\n  }\n\n  /**\n   * Returns a copy of the song with the key value set to the specified key. It changes:\n   * - the value for `key` in the {@link metadata} set\n   * - any existing `key` directive\n   * @param {number|null} key the key. Passing `null` will:\n   * - remove the current key from {@link metadata}\n   * - remove any `key` directive\n   * @returns {Song} The changed song\n   */\n  setKey(key: string | number | null): Song {\n    const strKey = key ? key.toString() : null;\n    return this.changeMetadata(KEY, strKey);\n  }\n\n  /**\n   * Returns a copy of the song with the key value set to the specified capo. It changes:\n   * - the value for `capo` in the {@link metadata} set\n   * - any existing `capo` directive\n   * @param {number|null} capo the capo. Passing `null` will:\n   * - remove the current key from {@link metadata}\n   * - remove any `capo` directive\n   * @returns {Song} The changed song\n   */\n  setCapo(capo: number | null): Song {\n    const strCapo = capo ? capo.toString() : null;\n    return this.changeMetadata(CAPO, strCapo);\n  }\n\n  private setDirective(name: string, value: string | null): Song {\n    if (value === null) {\n      return this.removeItem((item: Item) => item instanceof Tag && item.name === name);\n    }\n\n    return this.updateItem(\n      (item: Item) => item instanceof Tag && item.name === name,\n      (item: Item) => (('set' in item) ? item.set({ value }) : item),\n      (song: Song) => song.insertDirective(name, value),\n    );\n  }\n\n  /**\n   * Transposes the song by the specified delta. It will:\n   * - transpose all chords, see: {@link Chord#transpose}\n   * - transpose the song key in {@link metadata}\n   * - update any existing `key` directive\n   * @param {number} delta The number of semitones (positive or negative) to transpose with\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing\n   * @returns {Song} The transposed song\n   */\n  transpose(delta: number, { normalizeChordSuffix = false } = {}): Song {\n    const wrappedKey = Key.wrap(this.key);\n    let transposedKey: Key | null = null;\n    let song = (this as Song);\n\n    if (wrappedKey) {\n      transposedKey = wrappedKey.transpose(delta);\n      song = song.setKey(transposedKey.toString());\n    }\n\n    return song.mapItems((item) => {\n      if (item instanceof ChordLyricsPair) {\n        return (item as ChordLyricsPair).transpose(delta, transposedKey, { normalizeChordSuffix });\n      }\n\n      return item;\n    });\n  }\n\n  /**\n   * Transposes the song up by one semitone. It will:\n   * - transpose all chords, see: {@link Chord#transpose}\n   * - transpose the song key in {@link metadata}\n   * - update any existing `key` directive\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing\n   * @returns {Song} The transposed song\n   */\n  transposeUp({ normalizeChordSuffix = false } = {}): Song {\n    return this.transpose(1, { normalizeChordSuffix });\n  }\n\n  /**\n   * Transposes the song down by one semitone. It will:\n   * - transpose all chords, see: {@link Chord#transpose}\n   * - transpose the song key in {@link metadata}\n   * - update any existing `key` directive\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing\n   * @returns {Song} The transposed song\n   */\n  transposeDown({ normalizeChordSuffix = false } = {}): Song {\n    return this.transpose(-1, { normalizeChordSuffix });\n  }\n\n  /**\n   * Returns a copy of the song with the key set to the specified key. It changes:\n   * - the value for `key` in the {@link metadata} set\n   * - any existing `key` directive\n   * - all chords, those are transposed according to the distance between the current and the new key\n   * @param {string} newKey The new key.\n   * @returns {Song} The changed song\n   */\n  changeKey(newKey: string | Key): Song {\n    const transpose = this.getTransposeDistance(newKey);\n\n    const updatedSong = this.mapItems((item) => {\n      if (item instanceof Tag && item.name === KEY) {\n        return item.set({ value: newKey.toString() });\n      }\n\n      if (item instanceof ChordLyricsPair) {\n        return item.transpose(transpose, newKey);\n      }\n\n      return item;\n    });\n\n    this.setKey(newKey.toString());\n    return updatedSong;\n  }\n\n  getTransposeDistance(newKey: string | Key): number {\n    const wrappedKey = Key.wrap(this.key);\n\n    if (!wrappedKey) {\n      throw new Error(`\nCannot change song key, the original key is unknown.\n\nEither ensure a key directive is present in the song (when using chordpro):\n  \\`{key: C}\\`\n\nOr set the song key before changing key:\n  \\`song.setKey('C');\\``.substring(1));\n    }\n\n    return wrappedKey.distanceTo(newKey);\n  }\n\n  /**\n   * Returns a copy of the song with the directive value set to the specified value.\n   * - when there is a matching directive in the song, it will update the directive\n   * - when there is no matching directive, it will be inserted\n   * If `value` is `null` it will act as a delete, any directive matching `name` will be removed.\n   * @param {string} name The directive name\n   * @param {string | null} value The value to set, or `null` to remove the directive\n   */\n  changeMetadata(name: string, value: string | null): Song {\n    const updatedSong = this.setDirective(name, value);\n    updatedSong.metadata.set(name, value);\n    return updatedSong;\n  }\n\n  private insertDirective(name: string, value: string, { after = null } = {}): Song {\n    const insertIndex = this.lines.findIndex((line) => (\n      line.items.some((item) => (\n        !(item instanceof Tag) || (after && item instanceof Tag && item.name === after)\n      ))\n    ));\n\n    const newLine = new Line();\n    newLine.addTag(name, value);\n\n    const clonedSong = this.clone();\n    const { lines } = clonedSong;\n    clonedSong.lines = [...lines.slice(0, insertIndex), newLine, ...lines.slice(insertIndex)];\n\n    return clonedSong;\n  }\n\n  /**\n   * Change the song contents inline. Return a new {@link Item} to replace it. Return `null` to remove it.\n   * @example\n   * // transpose all chords:\n   * song.mapItems((item) => {\n   *   if (item instanceof ChordLyricsPair) {\n   *     return item.transpose(2, 'D');\n   *   }\n   *\n   *   return item;\n   * });\n   * @param {MapItemsCallback} func the callback function\n   * @returns {Song} the changed song\n   */\n  mapItems(func: MapItemsCallback): Song {\n    const clonedSong = new Song();\n\n    this.lines.forEach((line) => {\n      clonedSong.addLine();\n\n      line.items.forEach((item) => {\n        const changedItem = func(item);\n\n        if (changedItem) {\n          clonedSong.addItem(changedItem);\n        }\n      });\n    });\n\n    return clonedSong;\n  }\n\n  /**\n   * Change the song contents inline. Return a new {@link Line} to replace it. Return `null` to remove it.\n   * @example\n   * // remove lines with only Tags:\n   * song.mapLines((line) => {\n   *   if (line.items.every(item => item instanceof Tag)) {\n   *     return null;\n   *   }\n   *\n   *   return line;\n   * });\n   * @param {MapLinesCallback} func the callback function\n   * @returns {Song} the changed song\n   */\n  mapLines(func: MapLinesCallback): Song {\n    const clonedSong = new Song();\n\n    this.lines.forEach((line) => {\n      const changedLine = func(line);\n\n      if (changedLine) {\n        clonedSong.addLine();\n        changedLine.items.forEach((item) => clonedSong.addItem(item));\n      }\n    });\n\n    return clonedSong;\n  }\n\n  private updateItem(\n    findCallback: (_item: Item) => boolean,\n    updateCallback: (_item: Item) => Item,\n    notFoundCallback: (_song: Song) => Song,\n  ): Song {\n    let found = false;\n\n    const updatedSong = this.mapItems((item) => {\n      if (findCallback(item)) {\n        found = true;\n        return updateCallback(item);\n      }\n\n      return item;\n    });\n\n    if (!found) {\n      return notFoundCallback(updatedSong);\n    }\n\n    return updatedSong;\n  }\n\n  private removeItem(callback: (_item: Item) => boolean): Song {\n    return this.mapLines((line) => {\n      const { items } = line;\n      const index = items.findIndex(callback);\n\n      if (index === -1) {\n        return line;\n      }\n\n      if (items.length === 1) {\n        return null;\n      }\n\n      return line.set({\n        items: [...items.slice(0, index), ...items.slice(index + 1)],\n      });\n    });\n  }\n}\n\nexport default Song;\n","import ChordLyricsPair from './chord_lyrics_pair';\nimport Tag from './tag';\nimport Comment from './comment';\nimport { CHORUS, NONE, VERSE } from '../constants';\nimport Item from './item';\nimport Font from './font';\n\ntype MapItemFunc = (_item: Item) => Item | null;\n\nexport type LineType = 'verse' | 'chorus' | 'none';\n\n/**\n * Represents a line in a chord sheet, consisting of items of type ChordLyricsPair or Tag\n */\nclass Line {\n  /**\n   * The items ({@link ChordLyricsPair} or {@link Tag} or {@link Comment}) of which the line consists\n   * @type {Array.<(ChordLyricsPair|Tag|Comment)>}\n   */\n  items: Item[] = [];\n\n  /**\n   * The line type, This is set by the ChordProParser when it read tags like {start_of_chorus} or {start_of_verse}\n   * Values can be {@link VERSE}, {@link CHORUS} or {@link NONE}\n   * @type {string}\n   */\n  type: LineType = NONE;\n\n  currentChordLyricsPair: ChordLyricsPair = new ChordLyricsPair();\n\n  key: string | null = null;\n\n  transposeKey: string | null = null;\n\n  lineNumber: number | null = null;\n\n  /**\n   * The text font that applies to this line. Is derived from the directives:\n   * `textfont`, `textsize` and `textcolour`\n   * See: https://www.chordpro.org/chordpro/directives-props_text_legacy/\n   * @type {Font}\n   */\n  textFont: Font = new Font();\n\n  /**\n   * The chord font that applies to this line. Is derived from the directives:\n   * `chordfont`, `chordsize` and `chordcolour`\n   * See: https://www.chordpro.org/chordpro/directives-props_chord_legacy/\n   * @type {Font}\n   */\n  chordFont: Font = new Font();\n\n  constructor({ type, items }: { type: LineType, items: Item[]} = { type: NONE, items: [] }) {\n    this.type = type;\n    this.items = items;\n  }\n\n  /**\n   * Indicates whether the line contains any items\n   * @returns {boolean}\n   */\n  isEmpty(): boolean {\n    return this.items.length === 0;\n  }\n\n  isNotEmpty(): boolean {\n    return !this.isEmpty();\n  }\n\n  /**\n   * Adds an item ({@link ChordLyricsPair} or {@link Tag}) to the line\n   * @param {ChordLyricsPair|Tag} item The item to be added\n   */\n  addItem(item: Item): void {\n    if (item instanceof Tag) {\n      this.addTag(item);\n    } else if (item instanceof ChordLyricsPair) {\n      this.addChordLyricsPair(item);\n    } else if (item instanceof Comment) {\n      this.addComment(item);\n    } else {\n      this.items.push(item);\n    }\n  }\n\n  /**\n   * Indicates whether the line contains items that are renderable\n   * @returns {boolean}\n   */\n  hasRenderableItems(): boolean {\n    return this.items.some((item) => item.isRenderable());\n  }\n\n  /**\n   * Returns a deep copy of the line and all of its items\n   * @returns {Line}\n   */\n  clone(): Line {\n    return this.mapItems(null);\n  }\n\n  mapItems(func: MapItemFunc | null): Line {\n    const clonedLine = new Line();\n\n    clonedLine.items = this.items\n      .map((item) => {\n        const clonedItem = item.clone();\n        return func ? func(clonedItem) : clonedItem;\n      })\n      .filter((item) => item !== null) as Item[];\n\n    clonedLine.type = this.type;\n    return clonedLine;\n  }\n\n  /**\n   * Indicates whether the line type is {@link VERSE}\n   * @returns {boolean}\n   */\n  isVerse(): boolean {\n    return this.type === VERSE;\n  }\n\n  /**\n   * Indicates whether the line type is {@link CHORUS}\n   * @returns {boolean}\n   */\n  isChorus(): boolean {\n    return this.type === CHORUS;\n  }\n\n  /**\n   * Indicates whether the line contains items that are renderable. Please use {@link hasRenderableItems}\n   * @deprecated\n   * @returns {boolean}\n   */\n  hasContent(): boolean {\n    return this.hasRenderableItems();\n  }\n\n  addChordLyricsPair(chords: ChordLyricsPair | string | null = null, lyrics = null): ChordLyricsPair {\n    if (chords instanceof ChordLyricsPair) {\n      this.currentChordLyricsPair = chords;\n    } else {\n      this.currentChordLyricsPair = new ChordLyricsPair(chords || '', lyrics || '');\n    }\n\n    this.items.push(this.currentChordLyricsPair);\n    return this.currentChordLyricsPair;\n  }\n\n  ensureChordLyricsPair(): void {\n    if (!this.currentChordLyricsPair) {\n      this.addChordLyricsPair();\n    }\n  }\n\n  chords(chr: string): void {\n    this.ensureChordLyricsPair();\n    this.currentChordLyricsPair.chords += chr;\n  }\n\n  lyrics(chr: string): void {\n    this.ensureChordLyricsPair();\n    this.currentChordLyricsPair.lyrics += chr;\n  }\n\n  addTag(nameOrTag: Tag | string, value: string | null = null): Tag {\n    const tag = (nameOrTag instanceof Tag) ? nameOrTag : new Tag(nameOrTag, value);\n    this.items.push(tag);\n    return tag;\n  }\n\n  addComment(content: Comment | string): Comment {\n    const comment = (content instanceof Comment) ? content : new Comment(content);\n    this.items.push(comment);\n    return comment;\n  }\n\n  set(properties: { type?: LineType, items?: Item[] }): Line {\n    return new Line(\n      {\n        type: this.type,\n        items: this.items,\n        ...properties,\n      },\n    );\n  }\n}\n\nexport default Line;\n","/**\n * Represents a comment. See https://www.chordpro.org/chordpro/chordpro-file-format-specification/#overview\n */\nclass Comment {\n  content: string;\n\n  constructor(content: string) {\n    this.content = content;\n  }\n\n  /**\n   * Indicates whether a Comment should be visible in a formatted chord sheet (except for ChordPro sheets)\n   * @returns {boolean}\n   */\n  isRenderable(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns a deep copy of the Comment, useful when programmatically transforming a song\n   * @returns {Comment}\n   */\n  clone(): Comment {\n    return new Comment(this.content);\n  }\n\n  toString(): string {\n    return `Comment(content=${this.content})`;\n  }\n}\n\nexport default Comment;\n","import FontSize from './font_size';\n\ninterface FontProperties {\n  font?: string | null;\n  size?: FontSize | null;\n  colour?: string | null;\n}\n\nclass Font {\n  /**\n   * The font\n   * @member {string | null}\n   */\n  font: string | null = null;\n\n  /**\n   * The font size, expressed in either pixels or percentage.\n   * @member {FontSize | null}\n   */\n  size: FontSize | null = null;\n\n  /**\n   * The font color\n   * @member {string | null}\n   */\n  colour: string | null = null;\n\n  constructor({ font, size, colour }: FontProperties = { font: null, size: null, colour: null }) {\n    this.font = font ? font.replace(/\"/g, '\\'') : null;\n    this.size = size || null;\n    this.colour = colour || null;\n  }\n\n  clone() {\n    return new Font({\n      font: this.font,\n      size: this.size,\n      colour: this.colour,\n    });\n  }\n\n  /**\n   * Converts the font, size and color to a CSS string.\n   * If possible, font and size are combined to the `font` shorthand.\n   * If `font` contains double quotes (`\"`) those will be converted to single quotes (`'`).\n   *\n   * @example\n   * // Returns \"font-family: 'Times New Roman'\"\n   * new Font({ font: '\"Times New Roman\"' }).toCssString()\n   * @example\n   * // Returns \"color: red; font-family: Verdana\"\n   * new Font({ font: 'Verdana', colour: 'red' }).toCssString()\n   * @example\n   * // Returns \"font: 30px Verdana\"\n   * new Font({ font: 'Verdana', size: '30' }).toCssString()\n   * @example\n   * // Returns \"color: blue; font: 30% Verdana\"\n   * new Font({ font: 'Verdana', size: '30%', colour: 'blue' }).toCssString()\n   *\n   * @return {string} The CSS string\n   */\n  toCssString(): string {\n    const properties: Record<string, string> = {};\n\n    if (this.colour) {\n      properties.color = this.colour;\n    }\n\n    if (this.font && this.size) {\n      properties.font = `${this.size} ${this.font}`;\n    } else if (this.font) {\n      properties['font-family'] = this.font;\n    } else if (this.size) {\n      properties['font-size'] = `${this.size}`;\n    }\n\n    return Object\n      .keys(properties)\n      .map((key) => `${key}: ${properties[key]}`)\n      .join('; ');\n  }\n}\n\nexport default Font;\n","import { INDETERMINATE } from '../constants';\nimport Line from './line';\n\n/**\n * Represents a paragraph of lines in a chord sheet\n */\nclass Paragraph {\n  /**\n   * The {@link Line} items of which the paragraph consists\n   * @member\n   * @type {Line[]}\n   */\n  lines: Line[] = [];\n\n  addLine(line): void {\n    this.lines.push(line);\n  }\n\n  /**\n   * Tries to determine the common type for all lines. If the types for all lines are equal, it returns that type.\n   * If not, it returns {@link INDETERMINATE}\n   * @returns {string}\n   */\n  get type(): 'verse' | 'chorus' | 'none' | 'indeterminate' {\n    const types = this.lines.map((line) => line.type);\n    const uniqueTypes = [...new Set(types)];\n\n    if (uniqueTypes.length === 1) {\n      return uniqueTypes[0];\n    }\n\n    return INDETERMINATE;\n  }\n\n  /**\n   * Indicates whether the paragraph contains lines with renderable items.\n   * @see {@link Line.hasRenderableItems}\n   * @returns {boolean}\n   */\n  hasRenderableItems(): boolean {\n    return this.lines.some((line) => line.hasRenderableItems());\n  }\n}\n\nexport default Paragraph;\n","import Chord from '../chord';\nimport MetadataAccessors from './metadata_accessors';\n\nimport {\n  _KEY,\n  CAPO,\n  KEY,\n  isReadonlyTag,\n} from './tag';\n\nfunction appendValue(array: string[], value: string): void {\n  if (!array.includes(value)) {\n    array.push(value);\n  }\n}\n\n/**\n * Stores song metadata. Properties can be accessed using the get() method:\n *\n * const metadata = new Metadata({ author: 'John' });\n * metadata.get('author')   // => 'John'\n *\n * See {@link Metadata#get}\n */\nclass Metadata extends MetadataAccessors {\n  metadata: Record<string, string | string[]> = {};\n\n  constructor(metadata: Record<string, string | string[]> = {}) {\n    super();\n\n    if (metadata) {\n      this.assign(metadata);\n    }\n  }\n\n  merge(metadata: Record<string, string | string[]>): Metadata {\n    const clone = this.clone();\n    clone.assign(metadata);\n    return clone;\n  }\n\n  contains(key: string): boolean {\n    return key in this.metadata;\n  }\n\n  add(key: string, value: string): void {\n    if (isReadonlyTag(key)) {\n      return;\n    }\n\n    if (!(key in this.metadata)) {\n      this.metadata[key] = value;\n      return;\n    }\n\n    const currentValue = this.metadata[key];\n\n    if (currentValue === value) {\n      return;\n    }\n\n    if (currentValue instanceof Array) {\n      appendValue(currentValue, value);\n      return;\n    }\n\n    this.metadata[key] = [currentValue, value];\n  }\n\n  set(key: string, value: string | null): void {\n    if (value) {\n      this.metadata[key] = value;\n    } else {\n      delete this.metadata[key];\n    }\n  }\n\n  getMetadata(name: string): string | string[] | undefined {\n    return this.get(name);\n  }\n\n  getSingleMetadata(name: string): string {\n    return this.getSingle(name);\n  }\n\n  /**\n   * Reads a metadata value by key. This method supports simple value lookup, as well as fetching single array values.\n   *\n   * This method deprecates direct property access, eg: metadata['author']\n   *\n   * Examples:\n   *\n   * const metadata = new Metadata({ lyricist: 'Pete', author: ['John', 'Mary'] });\n   * metadata.get('lyricist') // => 'Pete'\n   * metadata.get('author')   // => ['John', 'Mary']\n   * metadata.get('author.1') // => 'John'\n   * metadata.get('author.2') // => 'Mary'\n   *\n   * Using a negative index will start counting at the end of the list:\n   *\n   * const metadata = new Metadata({ lyricist: 'Pete', author: ['John', 'Mary'] });\n   * metadata.get('author.-1') // => 'Mary'\n   * metadata.get('author.-2') // => 'John'\n   *\n   * @param prop the property name\n   * @returns {Array<String>|String} the metadata value(s). If there is only one value, it will return a String,\n   * else it returns an array of strings.\n   */\n  get(prop: string): string | string[] | undefined {\n    if (prop === _KEY) {\n      return this.calculateKeyFromCapo();\n    }\n\n    if (prop in this.metadata) {\n      return this.metadata[prop];\n    }\n\n    return this.getArrayItem(prop);\n  }\n\n  /**\n   * Returns a single metadata value. If the actual value is an array, it returns the first value. Else, it returns\n   * the value.\n   * @ignore\n   * @param {string} prop the property name\n   * @returns {String} The metadata value\n   */\n  getSingle(prop: string): string {\n    const value = this.get(prop);\n\n    if (Array.isArray(value)) {\n      return value[0];\n    }\n\n    return value as string;\n  }\n\n  parseArrayKey(prop: string): [string, number] | null {\n    const match = prop.match(/(.+)\\.(-?\\d+)$/);\n\n    if (!match) {\n      return null;\n    }\n\n    const key = match[1];\n    const index = parseInt(match[2], 10);\n    return [key, index];\n  }\n\n  getArrayItem(prop: string): string | undefined {\n    const parsedKey = this.parseArrayKey(prop);\n\n    if (parsedKey === null) {\n      return undefined;\n    }\n\n    const [key, index] = parsedKey;\n    const arrayValue = (this.metadata[key] || []);\n    let itemIndex = index;\n\n    if (itemIndex < 0) {\n      itemIndex = arrayValue.length + itemIndex;\n    } else if (itemIndex > 0) {\n      itemIndex -= 1;\n    }\n\n    return arrayValue[itemIndex];\n  }\n\n  /**\n   * Returns a deep clone of this Metadata object\n   * @returns {Metadata} the cloned Metadata object\n   */\n  clone(): Metadata {\n    return new Metadata(this.metadata);\n  }\n\n  calculateKeyFromCapo(): string | undefined {\n    const capo = this.getSingle(CAPO);\n    const key = this.getSingle(KEY);\n\n    if (capo && key) {\n      const chord = Chord.parse(key);\n\n      if (!chord) {\n        throw new Error(`Could not parse ${key}`);\n      }\n\n      return chord.transpose(parseInt(capo, 10)).toString();\n    }\n\n    return undefined;\n  }\n\n  private assign(metadata: Record<string, string | string[]>): void {\n    Object\n      .keys(metadata)\n      .filter((key) => !isReadonlyTag(key))\n      .forEach((key) => {\n        const value = metadata[key];\n\n        if (value instanceof Array) {\n          this.metadata[key] = [...value];\n        } else {\n          this.metadata[key] = value;\n        }\n      });\n  }\n}\n\nexport default Metadata;\n","import {\n  ALBUM,\n  ARTIST,\n  CAPO,\n  COMPOSER,\n  COPYRIGHT,\n  DURATION,\n  KEY,\n  LYRICIST,\n  SUBTITLE,\n  TEMPO,\n  TIME,\n  TITLE,\n  YEAR,\n} from './tag';\n\nabstract class MetadataAccessors {\n  abstract getMetadata(_name: string): string | string[] | undefined;\n\n  abstract getSingleMetadata(_name: string): string;\n\n  get key(): string { return this.getSingleMetadata(KEY); }\n\n  get title(): string { return this.getSingleMetadata(TITLE); }\n\n  get subtitle(): string { return this.getSingleMetadata(SUBTITLE); }\n\n  get capo(): string | string[] | undefined { return this.getMetadata(CAPO); }\n\n  get duration(): string { return this.getSingleMetadata(DURATION); }\n\n  get tempo(): string { return this.getSingleMetadata(TEMPO); }\n\n  get time(): string | string[] | undefined { return this.getMetadata(TIME); }\n\n  get year(): string { return this.getSingleMetadata(YEAR); }\n\n  get album(): string | string[] | undefined { return this.getMetadata(ALBUM); }\n\n  get copyright(): string { return this.getSingleMetadata(COPYRIGHT); }\n\n  get lyricist(): string | string[] | undefined { return this.getMetadata(LYRICIST); }\n\n  get artist(): string | string[] | undefined { return this.getMetadata(ARTIST); }\n\n  get composer(): string | string[] | undefined { return this.getMetadata(COMPOSER); }\n}\n\nexport default MetadataAccessors;\n","/**\n * Represents a parser warning, currently only used by ChordProParser.\n */\nclass ParserWarning {\n  /**\n   * The warning message\n   * @member\n   * @type {string}\n   */\n  message: string;\n\n  /**\n   * The chord sheet line number on which the warning occurred\n   * @member\n   * @type {number}\n   */\n  lineNumber: number | null = null;\n\n  /**\n   * The chord sheet column on which the warning occurred\n   * @member\n   * @type {number}\n   */\n  column: number | null = null;\n\n  /**\n   * @hideconstructor\n   */\n  constructor(message: string, lineNumber: number | null, column: number | null) {\n    this.message = message;\n    this.lineNumber = lineNumber;\n    this.column = column;\n  }\n\n  /**\n   * Returns a stringified version of the warning\n   * @returns {string} The string warning\n   */\n  toString(): string {\n    return `Warning: ${this.message} on line ${this.lineNumber || '?'} column ${this.column || '?'}`;\n  }\n}\n\nexport default ParserWarning;\n","import Font from './font';\nimport FontSize from './font_size';\n\nimport Tag, {\n  CHORDCOLOUR, CHORDFONT, CHORDSIZE, TEXTCOLOUR, TEXTFONT, TEXTSIZE,\n} from './tag';\n\nclass FontStack {\n  fontAndColourStacks: Record<string, string[]> = {\n    [CHORDCOLOUR]: [],\n    [CHORDFONT]: [],\n    [TEXTCOLOUR]: [],\n    [TEXTFONT]: [],\n  };\n\n  sizeStacks: Record<string, FontSize[]> = {\n    [CHORDSIZE]: [],\n    [TEXTSIZE]: [],\n  };\n\n  textFont: Font = new Font();\n\n  chordFont: Font = new Font();\n\n  applyTag(tag: Tag) {\n    switch (tag.name) {\n      case TEXTFONT:\n        this.textFont.font = this.pushOrPopTag(tag);\n        break;\n\n      case TEXTSIZE:\n        this.textFont.size = this.pushOrPopSizeTag(tag);\n        break;\n\n      case TEXTCOLOUR:\n        this.textFont.colour = this.pushOrPopTag(tag);\n        break;\n\n      case CHORDFONT:\n        this.chordFont.font = this.pushOrPopTag(tag);\n        break;\n\n      case CHORDSIZE:\n        this.chordFont.size = this.pushOrPopSizeTag(tag);\n        break;\n\n      case CHORDCOLOUR:\n        this.chordFont.colour = this.pushOrPopTag(tag);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  private pushOrPopTag(tag: Tag): string | null {\n    let { value }: { value: string | null } = tag;\n\n    if (tag.hasValue()) {\n      this.fontAndColourStacks[tag.name].push(value);\n    } else {\n      this.fontAndColourStacks[tag.name].pop();\n      value = this.fontAndColourStacks[tag.name].slice(-1)[0] || null;\n    }\n\n    return value;\n  }\n\n  private pushOrPopSizeTag(tag: Tag): FontSize | null {\n    const { value }: { value: string | null } = tag;\n\n    if (tag.hasValue()) {\n      const parent: FontSize | null = this.sizeStacks[tag.name].slice(-1)[0] || null;\n      const parsedFontSize: FontSize = FontSize.parse(value, parent);\n      this.sizeStacks[tag.name].push(parsedFontSize);\n      return parsedFontSize;\n    }\n\n    this.sizeStacks[tag.name].pop();\n    return this.sizeStacks[tag.name].slice(-1)[0] || null;\n  }\n}\n\nexport default FontStack;\n","type Size = 'px' | '%';\n\nclass FontSize {\n  /**\n   * The size unit, either `\"px\"` or `\"%\"`\n   * @member {string}\n   */\n  unit: Size;\n\n  /**\n   * The font size\n   * @member {number}\n   */\n  fontSize: number;\n\n  constructor(fontSize: number, kind: Size) {\n    this.fontSize = fontSize;\n    this.unit = kind;\n  }\n\n  clone() {\n    return new FontSize(this.fontSize, this.unit);\n  }\n\n  multiply(percentage): FontSize {\n    return new FontSize((this.fontSize * percentage) / 100, this.unit);\n  }\n\n  /**\n   * Stringifies the font size by concatenating size and unit\n   *\n   * @example\n   * // Returns \"30px\"\n   * new FontSize(30, 'px').toString()\n   * @example\n   * // Returns \"120%\"\n   * new FontSize(120, '%').toString()\n   *\n   * @return {string} The font size\n   */\n  toString() {\n    return `${this.fontSize}${this.unit}`;\n  }\n\n  static parse(fontSize: string, parent: FontSize | null) {\n    const trimmed = fontSize.trim();\n    const parsedFontSize = parseFloat(trimmed);\n\n    if (Number.isNaN(parsedFontSize)) {\n      return this.parseNotANumber(parent);\n    }\n\n    if (trimmed.slice(-1) === '%') {\n      return this.parsePercentage(parsedFontSize, parent);\n    }\n\n    return new FontSize(parsedFontSize, 'px');\n  }\n\n  static parseNotANumber(parent: FontSize | null) {\n    if (parent) {\n      return parent.clone();\n    }\n\n    return new FontSize(100, '%');\n  }\n\n  static parsePercentage(parsedFontSize: number, parent: FontSize | null) {\n    if (parent) {\n      return parent.multiply(parsedFontSize);\n    }\n\n    return new FontSize(parsedFontSize, '%');\n  }\n}\n\nexport default FontSize;\n","\n// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )\n//\n// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs\n\n\"use strict\";\n\nexport interface FilePosition {\n  offset: number;\n  line: number;\n  column: number;\n}\n\nexport interface FileRange {\n  start: FilePosition;\n  end: FilePosition;\n  source: string;\n}\n\nexport interface LiteralExpectation {\n  type: \"literal\";\n  text: string;\n  ignoreCase: boolean;\n}\n\nexport interface ClassParts extends Array<string | ClassParts> {}\n\nexport interface ClassExpectation {\n  type: \"class\";\n  parts: ClassParts;\n  inverted: boolean;\n  ignoreCase: boolean;\n}\n\nexport interface AnyExpectation {\n  type: \"any\";\n}\n\nexport interface EndExpectation {\n  type: \"end\";\n}\n\nexport interface OtherExpectation {\n  type: \"other\";\n  description: string;\n}\n\nexport type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;\n\nfunction peg$padEnd(str: string, targetLength: number, padString: string) {\n  padString = padString || ' ';\n  if (str.length > targetLength) {\n    return str;\n  }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\nexport class PeggySyntaxError extends Error {\n  public static buildMessage(expected: Expectation[], found: string | null) {\n    function hex(ch: string): string {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\"/g,  \"\\\\\\\"\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function classEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\]/g, \"\\\\]\")\n        .replace(/\\^/g, \"\\\\^\")\n        .replace(/-/g,  \"\\\\-\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function describeExpectation(expectation: Expectation) {\n      switch (expectation.type) {\n        case \"literal\":\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        case \"class\":\n          const escapedParts = expectation.parts.map((part) => {\n            return Array.isArray(part)\n              ? classEscape(part[0] as string) + \"-\" + classEscape(part[1] as string)\n              : classEscape(part);\n          });\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        case \"any\":\n          return \"any character\";\n        case \"end\":\n          return \"end of input\";\n        case \"other\":\n          return expectation.description;\n      }\n    }\n\n    function describeExpected(expected1: Expectation[]) {\n      const descriptions = expected1.map(describeExpectation);\n      let i: number;\n      let j: number;\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found1: string | null) {\n      return found1 ? \"\\\"\" + literalEscape(found1) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  }\n\n  public message: string;\n  public expected: Expectation[];\n  public found: string | null;\n  public location: FileRange;\n  public name: string;\n\n  constructor(message: string, expected: Expectation[], found: string | null, location: FileRange) {\n    super();\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"PeggySyntaxError\";\n\n    if (typeof (Object as any).setPrototypeOf === \"function\") {\n      (Object as any).setPrototypeOf(this, PeggySyntaxError.prototype);\n    } else {\n      (this as any).__proto__ = PeggySyntaxError.prototype;\n    }\n    if (typeof (Error as any).captureStackTrace === \"function\") {\n      (Error as any).captureStackTrace(this, PeggySyntaxError);\n    }\n  }\n\n  format(sources: { grammarSource?: string; text: string }[]): string {\n    let str = 'Error: ' + this.message;\n    if (this.location) {\n      let src: string[] | null = null;\n      let k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].grammarSource === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      let s = this.location.start;\n      let loc = this.location.source + ':' + s.line + ':' + s.column;\n      if (src) {\n        let e = this.location.end;\n        let filler = peg$padEnd('', s.line.toString().length, ' ');\n        let line = src[s.line - 1];\n        let last = s.line === e.line ? e.column : line.length + 1;\n        str += '\\n --> ' + loc + '\\n' + filler + ' |\\n' + s.line + ' | ' + line + '\\n' + filler + ' | ' +\n          peg$padEnd('', s.column - 1, ' ') +\n          peg$padEnd('', last - s.column, '^');\n      } else {\n        str += '\\n at ' + loc;\n      }\n    }\n    return str;\n  }\n}\n\nfunction peg$parse(input: string, options?: ParseOptions) {\n  options = options !== undefined ? options : {};\n\n  const peg$FAILED: Readonly<any> = {};\n  const peg$source = options.grammarSource;\n\n  const peg$startRuleFunctions: {[id: string]: any} = { ChordSheet: peg$parseChordSheet };\n  let peg$startRuleFunction: () => any = peg$parseChordSheet;\n\n  const peg$c0 = function(lines: any, line: any): any {\n        return {\n          type: 'chordSheet',\n          lines: [...lines, line],\n        };\n      };\n  const peg$c1 = function(line: any): any {\n        return line;\n      };\n  const peg$c2 = function(lyrics: any, tokens: any, chords: any, comment: any): any {\n        return {\n          type: 'line',\n          items: [\n            lyrics ? { type: 'chordLyricsPair', chords: '', lyrics } : null,\n            ...tokens,\n            chords ? { type: 'chordLyricsPair', chords, lyrics: '' } : null,\n            comment ? { type: 'comment', comment } : null,\n          ].filter(x => x),\n        };\n      };\n  const peg$c3 = function(lyrics: any): any {\n        return { type: 'chordLyricsPair', chords: '', lyrics };\n      };\n  const peg$c4 = \"#\";\n  const peg$c5 = peg$literalExpectation(\"#\", false);\n  const peg$c6 = /^[^\\r\\n]/;\n  const peg$c7 = peg$classExpectation([\"\\r\", \"\\n\"], true, false);\n  const peg$c8 = function(comment: any): any {\n        return comment;\n      };\n  const peg$c9 = function(chords: any, lyrics: any, space: any): any {\n        return {\n          type: 'chordLyricsPair',\n          chords: chords || '',\n          lyrics: lyrics + (space || ''),\n        };\n      };\n  const peg$c10 = function(lyrics: any): any {\n        return lyrics.map(c => c.char || c).join('');\n      };\n  const peg$c11 = \"[\";\n  const peg$c12 = peg$literalExpectation(\"[\", false);\n  const peg$c13 = \"]\";\n  const peg$c14 = peg$literalExpectation(\"]\", false);\n  const peg$c15 = function(chords: any): any {\n        return chords.map(c => c.char || c).join('');\n      };\n  const peg$c16 = /^[^\\]\\r\\n]/;\n  const peg$c17 = peg$classExpectation([\"]\", \"\\r\", \"\\n\"], true, false);\n  const peg$c18 = \"\\\\\";\n  const peg$c19 = peg$literalExpectation(\"\\\\\", false);\n  const peg$c20 = function(): any { return { type: 'char', char: '\\\\' }; };\n  const peg$c21 = function(): any { return { type: 'char', char: ']'  }; };\n  const peg$c22 = function(sequence: any): any {\n        return sequence;\n      };\n  const peg$c23 = \"%{\";\n  const peg$c24 = peg$literalExpectation(\"%{\", false);\n  const peg$c25 = \"}\";\n  const peg$c26 = peg$literalExpectation(\"}\", false);\n  const peg$c27 = function(variableName: any, valueTest: any, expressions: any): any {\n        return {\n          type: 'ternary',\n          variable: variableName.length > 0 ? variableName : null,\n          valueTest,\n          ...expressions,\n          location: location().start,\n        };\n      };\n  const peg$c28 = \"=\";\n  const peg$c29 = peg$literalExpectation(\"=\", false);\n  const peg$c30 = function(testValue: any): any {\n        return testValue;\n      };\n  const peg$c31 = \"|\";\n  const peg$c32 = peg$literalExpectation(\"|\", false);\n  const peg$c33 = function(trueExpression: any, falseExpression: any): any {\n        return {\n          type: 'ternary',\n          trueExpression,\n          falseExpression,\n          location: location().start,\n        };\n      };\n  const peg$c34 = function(falseExpression: any): any {\n        return falseExpression;\n      };\n  const peg$c35 = /^[a-zA-Z0-9\\-_]/;\n  const peg$c36 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"-\", \"_\"], false, false);\n  const peg$c37 = function(): any { return { type: 'char', char: ']'    }; };\n  const peg$c38 = function(): any { return { type: 'char', char: '|'    }; };\n  const peg$c39 = function(): any { return { type: 'char', char: '\\x7d' }; };\n  const peg$c40 = /^[^|[\\]\\\\{}%#\\r\\n\\t ]/;\n  const peg$c41 = peg$classExpectation([\"|\", \"[\", \"]\", \"\\\\\", \"{\", \"}\", \"%\", \"#\", \"\\r\", \"\\n\", \"\\t\", \" \"], true, false);\n  const peg$c42 = function(): any { return { type: 'char', char: '\\\\'   }; };\n  const peg$c43 = function(): any { return { type: 'char', char: '['    }; };\n  const peg$c44 = \"{\";\n  const peg$c45 = peg$literalExpectation(\"{\", false);\n  const peg$c46 = function(): any { return { type: 'char', char: '\\x7b' }; };\n  const peg$c47 = \"%\";\n  const peg$c48 = peg$literalExpectation(\"%\", false);\n  const peg$c49 = function(): any { return { type: 'char', char: '%'    }; };\n  const peg$c50 = function(): any { return { type: 'char', char: '#'    }; };\n  const peg$c51 = function(tagName: any, tagColonWithValue: any): any {\n        return {\n          type: 'tag',\n          name: tagName,\n          value: tagColonWithValue,\n          location: location().start,\n        };\n      };\n  const peg$c52 = \":\";\n  const peg$c53 = peg$literalExpectation(\":\", false);\n  const peg$c54 = function(tagValue: any): any {\n        return tagValue.map(c => c.char || c).join('');\n      };\n  const peg$c55 = /^[a-zA-Z\\-_]/;\n  const peg$c56 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], \"-\", \"_\"], false, false);\n  const peg$c57 = /^[^}\\\\\\r\\n]/;\n  const peg$c58 = peg$classExpectation([\"}\", \"\\\\\", \"\\r\", \"\\n\"], true, false);\n  const peg$c59 = peg$otherExpectation(\"whitespace\");\n  const peg$c60 = /^[ \\t\\n\\r]/;\n  const peg$c61 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false);\n  const peg$c62 = peg$otherExpectation(\"space\");\n  const peg$c63 = /^[ \\t]/;\n  const peg$c64 = peg$classExpectation([\" \", \"\\t\"], false, false);\n  const peg$c65 = \"\\n\";\n  const peg$c66 = peg$literalExpectation(\"\\n\", false);\n  const peg$c67 = \"\\r\";\n  const peg$c68 = peg$literalExpectation(\"\\r\", false);\n\n  let peg$currPos = 0;\n  let peg$savedPos = 0;\n  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  let peg$maxFailPos = 0;\n  let peg$maxFailExpected: Expectation[] = [];\n  let peg$silentFails = 0;\n\n  let peg$result;\n\n  if (options.startRule !== undefined) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text(): string {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location(): FileRange {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description: string, location1?: FileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location1\n    );\n  }\n\n  function error(message: string, location1?: FileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location1);\n  }\n\n  function peg$literalExpectation(text1: string, ignoreCase: boolean): LiteralExpectation {\n    return { type: \"literal\", text: text1, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts: ClassParts, inverted: boolean, ignoreCase: boolean): ClassExpectation {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation(): AnyExpectation {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation(): EndExpectation {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description: string): OtherExpectation {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos: number) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos: number, endPos: number): FileRange {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected1: Expectation) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected1);\n  }\n\n  function peg$buildSimpleError(message: string, location1: FileRange) {\n    return new PeggySyntaxError(message, [], \"\", location1);\n  }\n\n  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: FileRange) {\n    return new PeggySyntaxError(\n      PeggySyntaxError.buildMessage(expected1, found),\n      expected1,\n      found,\n      location1\n    );\n  }\n\n  function peg$parseChordSheet(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseLineWithNewline();\n    while (s2 as any !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseLineWithNewline();\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseLine();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineWithNewline(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLine();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNewLine();\n      if (s2 as any !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLine(): any {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseLyrics();\n    if (s2 as any === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 as any !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseToken();\n      while (s3 as any !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseToken();\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseChord();\n        if (s3 as any === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseComment();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            s5 = [];\n            s6 = peg$parseSpace();\n            while (s6 as any !== peg$FAILED) {\n              s5.push(s6);\n              s6 = peg$parseSpace();\n            }\n            if (s5 as any !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c2(s1, s2, s3, s4);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseToken(): any {\n    let s0, s1;\n\n    s0 = peg$parseTag();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$parseChordLyricsPair();\n      if (s0 as any === peg$FAILED) {\n        s0 = peg$parseMetaTernary();\n        if (s0 as any === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseLyrics();\n          if (s1 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1);\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseComment(): any {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSpace();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 35) {\n        s2 = peg$c4;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        if (peg$c6.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c7); }\n        }\n        while (s5 as any !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$c6.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n        }\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c8(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordLyricsPair(): any {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChord();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = peg$parseLyricsChar();\n      while (s4 as any !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parseLyricsChar();\n      }\n      if (s3 as any !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parseSpace();\n        while (s5 as any !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parseSpace();\n        }\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c9(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLyrics(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseLyricsCharOrSpace();\n    if (s2 as any !== peg$FAILED) {\n      while (s2 as any !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseLyricsCharOrSpace();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c10(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLyricsCharOrSpace(): any {\n    let s0;\n\n    s0 = peg$parseLyricsChar();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$parseSpace();\n    }\n\n    return s0;\n  }\n\n  function peg$parseChord(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parseEscape();\n    peg$silentFails--;\n    if (s2 as any === peg$FAILED) {\n      s1 = undefined;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 as any !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s2 = peg$c11;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c12); }\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseChordChar();\n        while (s4 as any !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseChordChar();\n        }\n        if (s3 as any !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s4 = peg$c13;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c15(s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordChar(): any {\n    let s0, s1, s2, s3;\n\n    if (peg$c16.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEscape();\n      if (s1 as any !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s3 = peg$c18;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c20();\n        }\n        s2 = s3;\n        if (s2 as any === peg$FAILED) {\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c13;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n          if (s3 as any !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c21();\n          }\n          s2 = s3;\n        }\n        if (s2 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaTernary(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c23) {\n      s1 = peg$c23;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseMetaVariableName();\n        if (s4 as any === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseMetaValueTest();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            s5 = peg$parse_();\n            if (s5 as any !== peg$FAILED) {\n              s6 = peg$parseMetaTernaryTrueFalseExpressions();\n              if (s6 as any === peg$FAILED) {\n                s6 = null;\n              }\n              if (s6 as any !== peg$FAILED) {\n                s7 = peg$parse_();\n                if (s7 as any !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s8 = peg$c25;\n                    peg$currPos++;\n                  } else {\n                    s8 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c26); }\n                  }\n                  if (s8 as any !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c27(s3, s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaValueTest(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 61) {\n      s1 = peg$c28;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseMetaTestValue();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c30(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaTestValue(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseChar();\n    if (s2 as any !== peg$FAILED) {\n      while (s2 as any !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseChar();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaTernaryTrueFalseExpressions(): any {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 124) {\n      s1 = peg$c31;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c32); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseMetaExpression();\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 as any !== peg$FAILED) {\n            s5 = peg$parseMetaTernaryFalseExpression();\n            if (s5 as any === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 as any !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 as any !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c33(s3, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaTernaryFalseExpression(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 124) {\n      s1 = peg$c31;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c32); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseMetaExpression();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c34(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaVariableName(): any {\n    let s0, s1;\n\n    s0 = [];\n    if (peg$c35.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c36); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      while (s1 as any !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c35.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c36); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetaExpression(): any {\n    let s0, s1, s2, s3;\n\n    s0 = [];\n    s1 = peg$currPos;\n    s2 = [];\n    s3 = peg$parseChar();\n    if (s3 as any !== peg$FAILED) {\n      while (s3 as any !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseChar();\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 as any !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 as any === peg$FAILED) {\n      s1 = peg$parseMetaTernary();\n    }\n    if (s1 as any !== peg$FAILED) {\n      while (s1 as any !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$currPos;\n        s2 = [];\n        s3 = peg$parseChar();\n        if (s3 as any !== peg$FAILED) {\n          while (s3 as any !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseChar();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 as any !== peg$FAILED) {\n          s1 = input.substring(s1, peg$currPos);\n        } else {\n          s1 = s2;\n        }\n        if (s1 as any === peg$FAILED) {\n          s1 = peg$parseMetaTernary();\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLyricsChar(): any {\n    let s0, s1;\n\n    s0 = peg$parseWordChar();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 as any !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n      if (s0 as any === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 124) {\n          s1 = peg$c31;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s1 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c38();\n        }\n        s0 = s1;\n        if (s0 as any === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s1 = peg$c25;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c26); }\n          }\n          if (s1 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c39();\n          }\n          s0 = s1;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChar(): any {\n    let s0;\n\n    s0 = peg$parseWordChar();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$parseSpace();\n    }\n\n    return s0;\n  }\n\n  function peg$parseWordChar(): any {\n    let s0, s1, s2, s3;\n\n    if (peg$c40.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c41); }\n    }\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEscape();\n      if (s1 as any !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s3 = peg$c18;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c42();\n        }\n        s2 = s3;\n        if (s2 as any === peg$FAILED) {\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 124) {\n            s3 = peg$c31;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s3 as any !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c38();\n          }\n          s2 = s3;\n          if (s2 as any === peg$FAILED) {\n            s2 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 91) {\n              s3 = peg$c11;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c12); }\n            }\n            if (s3 as any !== peg$FAILED) {\n              peg$savedPos = s2;\n              s3 = peg$c43();\n            }\n            s2 = s3;\n            if (s2 as any === peg$FAILED) {\n              s2 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 93) {\n                s3 = peg$c13;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c14); }\n              }\n              if (s3 as any !== peg$FAILED) {\n                peg$savedPos = s2;\n                s3 = peg$c37();\n              }\n              s2 = s3;\n              if (s2 as any === peg$FAILED) {\n                s2 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 123) {\n                  s3 = peg$c44;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c45); }\n                }\n                if (s3 as any !== peg$FAILED) {\n                  peg$savedPos = s2;\n                  s3 = peg$c46();\n                }\n                s2 = s3;\n                if (s2 as any === peg$FAILED) {\n                  s2 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 125) {\n                    s3 = peg$c25;\n                    peg$currPos++;\n                  } else {\n                    s3 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c26); }\n                  }\n                  if (s3 as any !== peg$FAILED) {\n                    peg$savedPos = s2;\n                    s3 = peg$c39();\n                  }\n                  s2 = s3;\n                  if (s2 as any === peg$FAILED) {\n                    s2 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 37) {\n                      s3 = peg$c47;\n                      peg$currPos++;\n                    } else {\n                      s3 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                    }\n                    if (s3 as any !== peg$FAILED) {\n                      peg$savedPos = s2;\n                      s3 = peg$c49();\n                    }\n                    s2 = s3;\n                    if (s2 as any === peg$FAILED) {\n                      s2 = peg$currPos;\n                      if (input.charCodeAt(peg$currPos) === 35) {\n                        s3 = peg$c4;\n                        peg$currPos++;\n                      } else {\n                        s3 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n                      }\n                      if (s3 as any !== peg$FAILED) {\n                        peg$savedPos = s2;\n                        s3 = peg$c50();\n                      }\n                      s2 = s3;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (s2 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseTag(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c44;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c45); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseTagName();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 as any !== peg$FAILED) {\n            s5 = peg$parseTagColonWithValue();\n            if (s5 as any === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 as any !== peg$FAILED) {\n              s6 = peg$parse_();\n              if (s6 as any !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 125) {\n                  s7 = peg$c25;\n                  peg$currPos++;\n                } else {\n                  s7 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c26); }\n                }\n                if (s7 as any !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c51(s3, s5);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTagColonWithValue(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 58) {\n      s1 = peg$c52;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c53); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseTagValue();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c54(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTagName(): any {\n    let s0, s1;\n\n    s0 = [];\n    if (peg$c55.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c56); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      while (s1 as any !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c55.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c56); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTagValue(): any {\n    let s0, s1;\n\n    s0 = [];\n    s1 = peg$parseTagValueChar();\n    while (s1 as any !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseTagValueChar();\n    }\n\n    return s0;\n  }\n\n  function peg$parseTagValueChar(): any {\n    let s0, s1, s2, s3;\n\n    if (peg$c57.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c58); }\n    }\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseEscape();\n      if (s1 as any !== peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s3 = peg$c18;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c42();\n        }\n        s2 = s3;\n        if (s2 as any === peg$FAILED) {\n          s2 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s3 = peg$c25;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c26); }\n          }\n          if (s3 as any !== peg$FAILED) {\n            peg$savedPos = s2;\n            s3 = peg$c39();\n          }\n          s2 = s3;\n          if (s2 as any === peg$FAILED) {\n            s2 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 123) {\n              s3 = peg$c44;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c45); }\n            }\n            if (s3 as any !== peg$FAILED) {\n              peg$savedPos = s2;\n              s3 = peg$c46();\n            }\n            s2 = s3;\n          }\n        }\n        if (s2 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_(): any {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c60.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c61); }\n    }\n    while (s1 as any !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c60.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 as any === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c59); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSpace(): any {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c63.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c64); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      while (s1 as any !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c63.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c64); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 as any === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c62); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNewLine(): any {\n    let s0;\n\n    s0 = peg$parseCarriageReturn();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$parseLineFeed();\n      if (s0 as any === peg$FAILED) {\n        s0 = peg$parseCarriageReturnLineFeed();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCarriageReturnLineFeed(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCarriageReturn();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseLineFeed();\n      if (s2 as any !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineFeed(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c65;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c66); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCarriageReturn(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 13) {\n      s0 = peg$c67;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c68); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscape(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s0 = peg$c18;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePound(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s0 = peg$c4;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePercent(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 37) {\n      s0 = peg$c47;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nexport interface ParseOptions {\n  filename?: string;\n  startRule?: string;\n  tracer?: any;\n  [key: string]: any;\n}\nexport type ParseFunction = (input: string, options?: ParseOptions) => any;\nexport const parse: ParseFunction = peg$parse;\n\n","import Song from '../chord_sheet/song';\nimport Line from '../chord_sheet/line';\nimport ChordLyricsPair from '../chord_sheet/chord_lyrics_pair';\nimport { deprecate, normalizeLineEndings } from '../utilities';\n\nconst WHITE_SPACE = /\\s/;\nconst CHORD_LINE_REGEX = /^\\s*((([A-G])(#|b)?([^/\\s]*)(\\/([A-G])(#|b)?)?)(\\s|$)+)+(\\s|$)+/;\n\n/**\n * Parses a normal chord sheet\n *\n * ChordSheetParser is deprecated, please use ChordsOverWordsParser.\n *\n * ChordsOverWordsParser aims to support any kind of chord, whereas ChordSheetParser lacks\n * support for many variations. Besides that, some chordpro feature have been ported back\n * to ChordsOverWordsParser, which adds some interesting functionality.\n */\nclass ChordSheetParser {\n  processingText = true;\n\n  preserveWhitespace = true;\n\n  song: Song = new Song();\n\n  songLine: Line | null = null;\n\n  chordLyricsPair: ChordLyricsPair | null = null;\n\n  lines: string[] = [];\n\n  currentLine = 0;\n\n  lineCount = 0;\n\n  /**\n   * Instantiate a chord sheet parser\n   * ChordSheetParser is deprecated, please use ChordsOverWordsParser.\n   * @param {Object} [options={}] options\n   * @param {boolean} [options.preserveWhitespace=true] whether to preserve trailing whitespace for chords\n   * @deprecated\n   */\n  constructor({ preserveWhitespace = true }: { preserveWhitespace?: boolean } = {}) {\n    deprecate(\n      `ChordSheetParser is deprecated, please use ChordsOverWordsParser. \n\nChordsOverWordsParser aims to support any kind of chord, whereas ChordSheetParser lacks \nsupport for many variations. Besides that, some chordpro feature have been ported back \nto ChordsOverWordsParser, which adds some interesting functionality.`,\n    );\n    this.preserveWhitespace = preserveWhitespace;\n  }\n\n  /**\n   * Parses a chord sheet into a song\n   * @param {string} chordSheet The ChordPro chord sheet\n   * @param {Object} [options={}] Optional parser options\n   * @param {Song} [options.song=null] The {@link Song} to store the song data in\n   * @returns {Song} The parsed song\n   */\n  parse(chordSheet: string, { song }: { song?: Song } = {}): Song {\n    this.initialize(chordSheet, song);\n\n    while (this.hasNextLine()) {\n      const line = this.readLine();\n      this.parseLine(line);\n    }\n\n    this.endOfSong();\n    return this.song;\n  }\n\n  endOfSong() { }\n\n  parseLine(line) {\n    this.songLine = this.song.addLine();\n\n    if (line.trim().length === 0) {\n      this.chordLyricsPair = null;\n    } else {\n      this.parseNonEmptyLine(line);\n    }\n  }\n\n  parseNonEmptyLine(line) {\n    if (!this.songLine) throw new Error('Expected this.songLine to be present');\n\n    this.chordLyricsPair = this.songLine.addChordLyricsPair();\n\n    if (CHORD_LINE_REGEX.test(line) && this.hasNextLine()) {\n      const nextLine = this.readLine();\n      this.parseLyricsWithChords(line, nextLine);\n    } else {\n      this.chordLyricsPair.lyrics = `${line}`;\n    }\n  }\n\n  initialize(document, song: Song | null = null) {\n    if (song) {\n      this.song = song;\n    }\n\n    this.lines = normalizeLineEndings(document).split('\\n');\n    this.currentLine = 0;\n    this.lineCount = this.lines.length;\n    this.processingText = true;\n  }\n\n  readLine() {\n    const line = this.lines[this.currentLine];\n    this.currentLine += 1;\n    return line;\n  }\n\n  hasNextLine() {\n    return this.currentLine < this.lineCount;\n  }\n\n  parseLyricsWithChords(chordsLine, lyricsLine) {\n    this.processCharacters(chordsLine, lyricsLine);\n\n    if (!this.chordLyricsPair) throw new Error('Expected this.chordLyricsPair to be present');\n\n    this.chordLyricsPair.lyrics += lyricsLine.substring(chordsLine.length);\n    this.chordLyricsPair.chords = this.chordLyricsPair.chords.trim();\n\n    if (this.chordLyricsPair.lyrics) {\n      this.chordLyricsPair.lyrics = this.chordLyricsPair.lyrics.trim();\n    }\n\n    if (!lyricsLine.trim().length) {\n      this.songLine = this.song.addLine();\n    }\n  }\n\n  processCharacters(chordsLine, lyricsLine) {\n    for (let c = 0, charCount = chordsLine.length; c < charCount; c += 1) {\n      const chr = chordsLine[c];\n      const nextChar = chordsLine[c + 1];\n      const isWhiteSpace = WHITE_SPACE.test(chr);\n      this.addCharacter(chr, nextChar);\n\n      if (!this.chordLyricsPair) throw new Error('Expected this.chordLyricsPair to be present');\n\n      this.chordLyricsPair.lyrics += lyricsLine[c] || '';\n      this.processingText = !isWhiteSpace;\n    }\n  }\n\n  addCharacter(chr, nextChar) {\n    const isWhiteSpace = WHITE_SPACE.test(chr);\n\n    if (!isWhiteSpace) {\n      this.ensureChordLyricsPairInitialized();\n    }\n\n    if (!isWhiteSpace || this.shouldAddCharacterToChords(nextChar)) {\n      if (!this.chordLyricsPair) throw new Error('Expected this.chordLyricsPair to be present');\n      this.chordLyricsPair.chords += chr;\n    }\n  }\n\n  shouldAddCharacterToChords(nextChar) {\n    return (nextChar && WHITE_SPACE.test(nextChar) && this.preserveWhitespace);\n  }\n\n  ensureChordLyricsPairInitialized() {\n    if (!this.processingText) {\n      if (!this.songLine) throw new Error('Expected this.songLine to be present');\n      this.chordLyricsPair = this.songLine.addChordLyricsPair();\n      this.processingText = true;\n    }\n  }\n}\n\nexport default ChordSheetParser;\n","import PegBasedParser from './peg_based_parser';\nimport { parse } from './chords_over_words_peg_parser';\nimport Song from '../chord_sheet/song';\n\n/**\n * Parses a chords over words sheet into a song\n *\n * It support \"regular\" chord sheets:\n *\n *            Am         C/G        F          C\n *     Let it be, let it be, let it be, let it be\n *     C                G              F  C/E Dm C\n *     Whisper words of wisdom, let it be\n *\n * Additionally, some chordpro features have been \"ported back\". For example, you can use chordpro directives:\n *\n *     {title: Let it be}\n *     {key: C}\n *     Chorus 1:\n *            Am\n *     Let it be\n *\n * For convenience, you can leave out the brackets:\n *\n *     title: Let it be\n *     Chorus 1:\n *            Am\n *     Let it be\n *\n * You can even use a markdown style frontmatter separator to separate the header from the song:\n *\n *     title: Let it be\n *     key: C\n *     ---\n *     Chorus 1:\n *            Am         C/G        F          C\n *     Let it be, let it be, let it be, let it be\n *     C                G              F  C/E Dm C\n *     Whisper words of wisdom, let it be\n *\n * `ChordsOverWordsParser` is the better version of `ChordSheetParser`, which is deprecated.\n */\nclass ChordsOverWordsParser extends PegBasedParser {\n  /**\n   * Parses a chords over words sheet into a song\n   * @param {string} chordsOverWordsSheet the chords over words sheet\n   * @returns {Song} The parsed song\n   */\n  parse(chordsOverWordsSheet: string): Song {\n    return this.parseWithParser(chordsOverWordsSheet, parse);\n  }\n}\n\nexport default ChordsOverWordsParser;\n","\n// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )\n//\n// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs\n\n\"use strict\";\n\nexport interface FilePosition {\n  offset: number;\n  line: number;\n  column: number;\n}\n\nexport interface FileRange {\n  start: FilePosition;\n  end: FilePosition;\n  source: string;\n}\n\nexport interface LiteralExpectation {\n  type: \"literal\";\n  text: string;\n  ignoreCase: boolean;\n}\n\nexport interface ClassParts extends Array<string | ClassParts> {}\n\nexport interface ClassExpectation {\n  type: \"class\";\n  parts: ClassParts;\n  inverted: boolean;\n  ignoreCase: boolean;\n}\n\nexport interface AnyExpectation {\n  type: \"any\";\n}\n\nexport interface EndExpectation {\n  type: \"end\";\n}\n\nexport interface OtherExpectation {\n  type: \"other\";\n  description: string;\n}\n\nexport type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;\n\nfunction peg$padEnd(str: string, targetLength: number, padString: string) {\n  padString = padString || ' ';\n  if (str.length > targetLength) {\n    return str;\n  }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\nexport class PeggySyntaxError extends Error {\n  public static buildMessage(expected: Expectation[], found: string | null) {\n    function hex(ch: string): string {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\"/g,  \"\\\\\\\"\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function classEscape(s: string): string {\n      return s\n        .replace(/\\\\/g, \"\\\\\\\\\")\n        .replace(/\\]/g, \"\\\\]\")\n        .replace(/\\^/g, \"\\\\^\")\n        .replace(/-/g,  \"\\\\-\")\n        .replace(/\\0/g, \"\\\\0\")\n        .replace(/\\t/g, \"\\\\t\")\n        .replace(/\\n/g, \"\\\\n\")\n        .replace(/\\r/g, \"\\\\r\")\n        .replace(/[\\x00-\\x0F]/g,            (ch) => \"\\\\x0\" + hex(ch) )\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, (ch) => \"\\\\x\"  + hex(ch) );\n    }\n\n    function describeExpectation(expectation: Expectation) {\n      switch (expectation.type) {\n        case \"literal\":\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        case \"class\":\n          const escapedParts = expectation.parts.map((part) => {\n            return Array.isArray(part)\n              ? classEscape(part[0] as string) + \"-\" + classEscape(part[1] as string)\n              : classEscape(part);\n          });\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        case \"any\":\n          return \"any character\";\n        case \"end\":\n          return \"end of input\";\n        case \"other\":\n          return expectation.description;\n      }\n    }\n\n    function describeExpected(expected1: Expectation[]) {\n      const descriptions = expected1.map(describeExpectation);\n      let i: number;\n      let j: number;\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found1: string | null) {\n      return found1 ? \"\\\"\" + literalEscape(found1) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  }\n\n  public message: string;\n  public expected: Expectation[];\n  public found: string | null;\n  public location: FileRange;\n  public name: string;\n\n  constructor(message: string, expected: Expectation[], found: string | null, location: FileRange) {\n    super();\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"PeggySyntaxError\";\n\n    if (typeof (Object as any).setPrototypeOf === \"function\") {\n      (Object as any).setPrototypeOf(this, PeggySyntaxError.prototype);\n    } else {\n      (this as any).__proto__ = PeggySyntaxError.prototype;\n    }\n    if (typeof (Error as any).captureStackTrace === \"function\") {\n      (Error as any).captureStackTrace(this, PeggySyntaxError);\n    }\n  }\n\n  format(sources: { grammarSource?: string; text: string }[]): string {\n    let str = 'Error: ' + this.message;\n    if (this.location) {\n      let src: string[] | null = null;\n      let k;\n      for (k = 0; k < sources.length; k++) {\n        if (sources[k].grammarSource === this.location.source) {\n          src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n          break;\n        }\n      }\n      let s = this.location.start;\n      let loc = this.location.source + ':' + s.line + ':' + s.column;\n      if (src) {\n        let e = this.location.end;\n        let filler = peg$padEnd('', s.line.toString().length, ' ');\n        let line = src[s.line - 1];\n        let last = s.line === e.line ? e.column : line.length + 1;\n        str += '\\n --> ' + loc + '\\n' + filler + ' |\\n' + s.line + ' | ' + line + '\\n' + filler + ' | ' +\n          peg$padEnd('', s.column - 1, ' ') +\n          peg$padEnd('', last - s.column, '^');\n      } else {\n        str += '\\n at ' + loc;\n      }\n    }\n    return str;\n  }\n}\n\nfunction peg$parse(input: string, options?: ParseOptions) {\n  options = options !== undefined ? options : {};\n\n  const peg$FAILED: Readonly<any> = {};\n  const peg$source = options.grammarSource;\n\n  const peg$startRuleFunctions: {[id: string]: any} = { ChordSheet: peg$parseChordSheet };\n  let peg$startRuleFunction: () => any = peg$parseChordSheet;\n\n  const peg$c0 = function(metadataLines: any, lines: any): any {\n        return {\n          type: \"chordSheet\",\n          lines: [\n            ...metadataLines,\n            ...lines,\n          ]\n        };\n      };\n  const peg$c1 = function(newLine: any, items: any, trailingItem: any): any {\n      const hasEmptyLine = newLine?.length > 0;\n      const emptyLines = hasEmptyLine ? [{ type: \"line\", items: [] }] : [];\n      return [...emptyLines, ...items, trailingItem];\n    };\n  const peg$c2 = function(item: any): any {\n      return item;\n    };\n  const peg$c3 = function(item: any): any {\n      if (item.type === \"chordsLine\") {\n        return {\n          type: \"line\",\n          items: item.items.map((item) => {\n            const chordLyricsPair = {\n              type: \"chordLyricsPair\"\n            };\n\n            if (item.type === \"chord\") {\n              return {\n                ...chordLyricsPair,\n                chord: item\n              };\n            }\n\n            return {\n              ...chordLyricsPair,\n              chords: item.value\n            };\n          })\n        };\n      }\n\n      return item;\n    };\n  const peg$c4 = function(chordsLine: any, lyrics: any): any {\n        const chords = chordsLine.items;\n\n        const chordLyricsPairs = chords.map((chord, i) => {\n          const nextChord = chords[i + 1];\n          const start = chord.column - 1;\n          const end = nextChord ? nextChord.column - 1 : lyrics.length;\n          const pairLyrics = lyrics.substring(start, end);\n          const result = /(\\s+)(\\S+)/.exec(pairLyrics);\n          const secondWordPosition = result ? (result.index + result[1].length) : null;\n\n          const chordData = (chord.type === \"chord\") ? { chord } : { chords: chord.value };\n\n          if (secondWordPosition && secondWordPosition < end) {\n            return [\n              { type: \"chordLyricsPair\", ...chordData, lyrics: pairLyrics.substring(0, secondWordPosition) },\n              { type: \"chordLyricsPair\", chords: \"\", lyrics: pairLyrics.substring(secondWordPosition) },\n            ];\n          }\n\n          return { type: \"chordLyricsPair\", ...chordData, lyrics: pairLyrics };\n        }).flat();\n\n        const firstChord = chords[0];\n\n        if (firstChord && firstChord.column > 1) {\n        \tconst firstChordPosition = firstChord.column;\n\n          if (firstChordPosition > 0) {\n            chordLyricsPairs.unshift({\n              type: \"chordLyricsPair\",\n              chords: \"\",\n              lyrics: lyrics.substring(0, firstChordPosition - 1),\n            });\n          }\n        }\n\n        return { type: \"line\", items: chordLyricsPairs };\n      };\n  const peg$c5 = function(items: any): any {\n        return {\n          type: \"chordsLine\",\n          items\n        };\n      };\n  const peg$c6 = function(symbol: any): any {\n        return symbol;\n      };\n  const peg$c7 = \"/\";\n  const peg$c8 = peg$literalExpectation(\"/\", false);\n  const peg$c9 = \"|\";\n  const peg$c10 = peg$literalExpectation(\"|\", false);\n  const peg$c11 = \"-\";\n  const peg$c12 = peg$literalExpectation(\"-\", false);\n  const peg$c13 = function(symbol: any): any {\n        return {\n          type: \"symbol\",\n          value: symbol,\n          column: location().start.column\n        };\n      };\n  const peg$c14 = function(lyrics: any): any {\n    \tif (lyrics.length === 0) {\n        return { type: \"line\", items: [] };\n      }\n\n      return {\n        type: \"line\",\n        items: [\n          { type: \"chordLyricsPair\", chords: \"\", lyrics }\n        ]\n      };\n    };\n  const peg$c15 = function(chord: any): any {\n        return chord;\n      };\n  const peg$c16 = function(line: any): any {\n        return {\n          type: \"line\",\n          items: [\n            { type: \"tag\", name: \"comment\", value: line }\n          ]\n        };\n      };\n  const peg$c17 = \"verse\";\n  const peg$c18 = peg$literalExpectation(\"verse\", true);\n  const peg$c19 = \"chorus\";\n  const peg$c20 = peg$literalExpectation(\"chorus\", true);\n  const peg$c21 = \"bridge\";\n  const peg$c22 = peg$literalExpectation(\"bridge\", true);\n  const peg$c23 = \"tag\";\n  const peg$c24 = peg$literalExpectation(\"tag\", true);\n  const peg$c25 = \"interlude\";\n  const peg$c26 = peg$literalExpectation(\"interlude\", true);\n  const peg$c27 = \"instrumental\";\n  const peg$c28 = peg$literalExpectation(\"instrumental\", true);\n  const peg$c29 = \"intro\";\n  const peg$c30 = peg$literalExpectation(\"intro\", true);\n  const peg$c31 = /^[^\\n\\r]/;\n  const peg$c32 = peg$classExpectation([\"\\n\", \"\\r\"], true, false);\n  const peg$c33 = function(pairs: any, trailingPair: any): any {\n        return [...pairs, trailingPair]\n          .filter(x => x)\n          .map(([key, value]) => ({\n            type: \"line\",\n            items: [\n              { type: \"tag\", name: key, value },\n            ],\n          }));\n      };\n  const peg$c34 = function(key: any, value: any): any {\n        return {\n          type: \"line\",\n          items: [\n            { type: \"tag\", name: key, value },\n          ],\n        }\n      };\n  const peg$c35 = function(pair: any): any {\n        return pair;\n      };\n  const peg$c36 = \"{\";\n  const peg$c37 = peg$literalExpectation(\"{\", false);\n  const peg$c38 = \"}\";\n  const peg$c39 = peg$literalExpectation(\"}\", false);\n  const peg$c40 = function(pair: any): any {\n      return pair;\n    };\n  const peg$c41 = function(key: any, value: any): any {\n      return [key, value];\n    };\n  const peg$c42 = \":\";\n  const peg$c43 = peg$literalExpectation(\":\", false);\n  const peg$c44 = /^[a-zA-Z0-9\\-_]/;\n  const peg$c45 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"-\", \"_\"], false, false);\n  const peg$c46 = /^[^\\n\\r}]/;\n  const peg$c47 = peg$classExpectation([\"\\n\", \"\\r\", \"}\"], true, false);\n  const peg$c48 = \"---\";\n  const peg$c49 = peg$literalExpectation(\"---\", false);\n  const peg$c50 = peg$otherExpectation(\"whitespace\");\n  const peg$c51 = /^[ \\t]/;\n  const peg$c52 = peg$classExpectation([\" \", \"\\t\"], false, false);\n  const peg$c53 = \"\\n\";\n  const peg$c54 = peg$literalExpectation(\"\\n\", false);\n  const peg$c55 = \"\\r\";\n  const peg$c56 = peg$literalExpectation(\"\\r\", false);\n  const peg$c57 = function(chord: any): any {\n        return { type: \"chord\", ...chord, column: location().start.column };\n      };\n  const peg$c58 = \"#\";\n  const peg$c59 = peg$literalExpectation(\"#\", false);\n  const peg$c60 = \"b\";\n  const peg$c61 = peg$literalExpectation(\"b\", false);\n  const peg$c62 = /^[a-zA-Z0-9()#+]/;\n  const peg$c63 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"(\", \")\", \"#\", \"+\"], false, false);\n  const peg$c64 = function(root: any, modifier: any, suffix: any, bass: any): any {\n    \t  return { base: root, modifier, suffix, ...bass, chordType: \"symbol\" };\n      };\n  const peg$c65 = /^[A-Ga-g]/;\n  const peg$c66 = peg$classExpectation([[\"A\", \"G\"], [\"a\", \"g\"]], false, false);\n  const peg$c67 = function(root: any, modifier: any): any {\n        return { bassBase: root, bassModifier: modifier };\n      };\n  const peg$c68 = function(modifier: any, root: any, suffix: any, bass: any): any {\n        return { base: root, modifier, suffix, ...bass, chordType: \"numeral\" };\n      };\n  const peg$c69 = \"III\";\n  const peg$c70 = peg$literalExpectation(\"III\", false);\n  const peg$c71 = \"iii\";\n  const peg$c72 = peg$literalExpectation(\"iii\", false);\n  const peg$c73 = \"VII\";\n  const peg$c74 = peg$literalExpectation(\"VII\", false);\n  const peg$c75 = \"vii\";\n  const peg$c76 = peg$literalExpectation(\"vii\", false);\n  const peg$c77 = \"II\";\n  const peg$c78 = peg$literalExpectation(\"II\", false);\n  const peg$c79 = \"ii\";\n  const peg$c80 = peg$literalExpectation(\"ii\", false);\n  const peg$c81 = \"IV\";\n  const peg$c82 = peg$literalExpectation(\"IV\", false);\n  const peg$c83 = \"iv\";\n  const peg$c84 = peg$literalExpectation(\"iv\", false);\n  const peg$c85 = \"VI\";\n  const peg$c86 = peg$literalExpectation(\"VI\", false);\n  const peg$c87 = \"vi\";\n  const peg$c88 = peg$literalExpectation(\"vi\", false);\n  const peg$c89 = \"I\";\n  const peg$c90 = peg$literalExpectation(\"I\", false);\n  const peg$c91 = \"i\";\n  const peg$c92 = peg$literalExpectation(\"i\", false);\n  const peg$c93 = \"V\";\n  const peg$c94 = peg$literalExpectation(\"V\", false);\n  const peg$c95 = \"v\";\n  const peg$c96 = peg$literalExpectation(\"v\", false);\n  const peg$c97 = function(modifier: any, root: any): any {\n        return { bassBase: root, bassModifier: modifier };\n      };\n  const peg$c98 = function(modifier: any, root: any, suffix: any, bass: any): any {\n        return { base: root, modifier, suffix, ...bass, chordType: \"numeric\" };\n      };\n  const peg$c99 = /^[1-7]/;\n  const peg$c100 = peg$classExpectation([[\"1\", \"7\"]], false, false);\n\n  let peg$currPos = 0;\n  let peg$savedPos = 0;\n  const peg$posDetailsCache = [{ line: 1, column: 1 }];\n  let peg$maxFailPos = 0;\n  let peg$maxFailExpected: Expectation[] = [];\n  let peg$silentFails = 0;\n\n  let peg$result;\n\n  if (options.startRule !== undefined) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text(): string {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location(): FileRange {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description: string, location1?: FileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location1\n    );\n  }\n\n  function error(message: string, location1?: FileRange) {\n    location1 = location1 !== undefined\n      ? location1\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location1);\n  }\n\n  function peg$literalExpectation(text1: string, ignoreCase: boolean): LiteralExpectation {\n    return { type: \"literal\", text: text1, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts: ClassParts, inverted: boolean, ignoreCase: boolean): ClassExpectation {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation(): AnyExpectation {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation(): EndExpectation {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description: string): OtherExpectation {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos: number) {\n    let details = peg$posDetailsCache[pos];\n    let p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos: number, endPos: number): FileRange {\n    const startPosDetails = peg$computePosDetails(startPos);\n    const endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected1: Expectation) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected1);\n  }\n\n  function peg$buildSimpleError(message: string, location1: FileRange) {\n    return new PeggySyntaxError(message, [], \"\", location1);\n  }\n\n  function peg$buildStructuredError(expected1: Expectation[], found: string | null, location1: FileRange) {\n    return new PeggySyntaxError(\n      PeggySyntaxError.buildMessage(expected1, found),\n      expected1,\n      found,\n      location1\n    );\n  }\n\n  function peg$parseChordSheet(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseMetadata();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordSheetContents();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSheetContents(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseNewLine();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseChordSheetItemWithNewLine();\n      while (s3 as any !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseChordSheetItemWithNewLine();\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseChordSheetItem();\n        if (s3 as any === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSheetItemWithNewLine(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordSheetItem();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNewLine();\n      if (s2 as any !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c2(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSheetItem(): any {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseDirectionLine();\n    if (s1 as any === peg$FAILED) {\n      s1 = peg$parseInlineMetadata();\n      if (s1 as any === peg$FAILED) {\n        s1 = peg$parseChordLyricsLines();\n        if (s1 as any === peg$FAILED) {\n          s1 = peg$parseChordsLine();\n          if (s1 as any === peg$FAILED) {\n            s1 = peg$parseLyricsLine();\n          }\n        }\n      }\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c3(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseChordLyricsLines(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordsLine();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNewLine();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseNonEmptyLyrics();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c4(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordsLine(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseRhythmSymbolWithSpacing();\n    if (s2 as any === peg$FAILED) {\n      s2 = peg$parseChordWithSpacing();\n    }\n    if (s2 as any !== peg$FAILED) {\n      while (s2 as any !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseRhythmSymbolWithSpacing();\n        if (s2 as any === peg$FAILED) {\n          s2 = peg$parseChordWithSpacing();\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c5(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseRhythmSymbolWithSpacing(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseRhythmSymbol();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c6(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseRhythmSymbol(): any {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c7;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n    }\n    if (s1 as any === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 124) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c10); }\n      }\n      if (s1 as any === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s1 = peg$c11;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n      }\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c13(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLyricsLine(): any {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLyrics();\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c14(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLyrics(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseWordChar();\n    while (s2 as any !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseWordChar();\n    }\n    if (s1 as any !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNonEmptyLyrics(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseWordChar();\n    if (s2 as any !== peg$FAILED) {\n      while (s2 as any !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseWordChar();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordWithSpacing(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChord();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c15(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDirectionLine(): any {\n    let s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    s3 = peg$parse_();\n    if (s3 as any !== peg$FAILED) {\n      s4 = peg$parseKeyword();\n      if (s4 as any !== peg$FAILED) {\n        s5 = peg$parse_();\n        if (s5 as any !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parseWordChar();\n          while (s7 as any !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parseWordChar();\n          }\n          if (s6 as any !== peg$FAILED) {\n            s7 = peg$parse_();\n            if (s7 as any !== peg$FAILED) {\n              s3 = [s3, s4, s5, s6, s7];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 as any !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c16(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseKeyword(): any {\n    let s0;\n\n    if (input.substr(peg$currPos, 5).toLowerCase() === peg$c17) {\n      s0 = input.substr(peg$currPos, 5);\n      peg$currPos += 5;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s0 as any === peg$FAILED) {\n      if (input.substr(peg$currPos, 6).toLowerCase() === peg$c19) {\n        s0 = input.substr(peg$currPos, 6);\n        peg$currPos += 6;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c20); }\n      }\n      if (s0 as any === peg$FAILED) {\n        if (input.substr(peg$currPos, 6).toLowerCase() === peg$c21) {\n          s0 = input.substr(peg$currPos, 6);\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c22); }\n        }\n        if (s0 as any === peg$FAILED) {\n          if (input.substr(peg$currPos, 3).toLowerCase() === peg$c23) {\n            s0 = input.substr(peg$currPos, 3);\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c24); }\n          }\n          if (s0 as any === peg$FAILED) {\n            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c25) {\n              s0 = input.substr(peg$currPos, 9);\n              peg$currPos += 9;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c26); }\n            }\n            if (s0 as any === peg$FAILED) {\n              if (input.substr(peg$currPos, 12).toLowerCase() === peg$c27) {\n                s0 = input.substr(peg$currPos, 12);\n                peg$currPos += 12;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c28); }\n              }\n              if (s0 as any === peg$FAILED) {\n                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c29) {\n                  s0 = input.substr(peg$currPos, 5);\n                  peg$currPos += 5;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c30); }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseWordChar(): any {\n    let s0;\n\n    if (peg$c31.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c32); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadata(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseMetadataPairWithNewLine();\n    while (s2 as any !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseMetadataPairWithNewLine();\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseMetadataPair();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseMetadataSeparator();\n        if (s3 as any === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c33(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInlineMetadata(): any {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseMetadataKey();\n    if (s2 as any !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseColon();\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 as any !== peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = peg$parseMetadataValue();\n            if (s6 as any !== peg$FAILED) {\n              s5 = input.substring(s5, peg$currPos);\n            } else {\n              s5 = s6;\n            }\n            if (s5 as any !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c34(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataPairWithNewLine(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseMetadataPair();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNewLine();\n      if (s2 as any !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c35(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataPair(): any {\n    let s0;\n\n    s0 = peg$parseMetadataPairWithBrackets();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$parseMetadataPairWithoutBrackets();\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataPairWithBrackets(): any {\n    let s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c36;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c37); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseMetadataPairWithoutBrackets();\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 as any !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s5 = peg$c38;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c39); }\n            }\n            if (s5 as any !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c40(s3);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataPairWithoutBrackets(): any {\n    let s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parseMetadataKey();\n    if (s2 as any !== peg$FAILED) {\n      s1 = input.substring(s1, peg$currPos);\n    } else {\n      s1 = s2;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parse_();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseColon();\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parse_();\n          if (s4 as any !== peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = peg$parseMetadataValue();\n            if (s6 as any !== peg$FAILED) {\n              s5 = input.substring(s5, peg$currPos);\n            } else {\n              s5 = s6;\n            }\n            if (s5 as any !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c41(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseColon(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 58) {\n      s0 = peg$c42;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c43); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataKey(): any {\n    let s0, s1;\n\n    s0 = [];\n    if (peg$c44.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c45); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      while (s1 as any !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c44.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c45); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataValue(): any {\n    let s0, s1;\n\n    s0 = [];\n    if (peg$c46.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c47); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      while (s1 as any !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c46.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c47); }\n        }\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMetadataSeparator(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c48) {\n      s1 = peg$c48;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c49); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNewLine();\n      if (s2 as any !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse_(): any {\n    let s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    if (peg$c51.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c52); }\n    }\n    while (s1 as any !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c51.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 as any === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNewLine(): any {\n    let s0;\n\n    s0 = peg$parseCarriageReturn();\n    if (s0 as any === peg$FAILED) {\n      s0 = peg$parseLineFeed();\n      if (s0 as any === peg$FAILED) {\n        s0 = peg$parseCarriageReturnLineFeed();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCarriageReturnLineFeed(): any {\n    let s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCarriageReturn();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseLineFeed();\n      if (s2 as any !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineFeed(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c53;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c54); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCarriageReturn(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 13) {\n      s0 = peg$c55;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c56); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChord(): any {\n    let s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseNumeral();\n    if (s1 as any === peg$FAILED) {\n      s1 = peg$parseNumeric();\n      if (s1 as any === peg$FAILED) {\n        s1 = peg$parseChordSymbol();\n      }\n    }\n    if (s1 as any !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c57(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseChordModifier(): any {\n    let s0;\n\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s0 = peg$c58;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c59); }\n    }\n    if (s0 as any === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 98) {\n        s0 = peg$c60;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c61); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSuffix(): any {\n    let s0, s1;\n\n    s0 = [];\n    if (peg$c62.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c63); }\n    }\n    while (s1 as any !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c62.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSymbol(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordSymbolRoot();\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordModifier();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseChordSuffix();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseChordSymbolBass();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c64(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSymbolRoot(): any {\n    let s0;\n\n    if (peg$c65.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c66); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseChordSymbolBass(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c7;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordSymbolRoot();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseChordModifier();\n        if (s3 as any === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c67(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeral(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordModifier();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNumeralRoot();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseChordSuffix();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseNumeralBass();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c68(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeralRoot(): any {\n    let s0;\n\n    if (input.substr(peg$currPos, 3) === peg$c69) {\n      s0 = peg$c69;\n      peg$currPos += 3;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    if (s0 as any === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c71) {\n        s0 = peg$c71;\n        peg$currPos += 3;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c72); }\n      }\n      if (s0 as any === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c73) {\n          s0 = peg$c73;\n          peg$currPos += 3;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c74); }\n        }\n        if (s0 as any === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c75) {\n            s0 = peg$c75;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c76); }\n          }\n          if (s0 as any === peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c77) {\n              s0 = peg$c77;\n              peg$currPos += 2;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\n            }\n            if (s0 as any === peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c79) {\n                s0 = peg$c79;\n                peg$currPos += 2;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c80); }\n              }\n              if (s0 as any === peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c81) {\n                  s0 = peg$c81;\n                  peg$currPos += 2;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c82); }\n                }\n                if (s0 as any === peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c83) {\n                    s0 = peg$c83;\n                    peg$currPos += 2;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c84); }\n                  }\n                  if (s0 as any === peg$FAILED) {\n                    if (input.substr(peg$currPos, 2) === peg$c85) {\n                      s0 = peg$c85;\n                      peg$currPos += 2;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                    }\n                    if (s0 as any === peg$FAILED) {\n                      if (input.substr(peg$currPos, 2) === peg$c87) {\n                        s0 = peg$c87;\n                        peg$currPos += 2;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c88); }\n                      }\n                      if (s0 as any === peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 73) {\n                          s0 = peg$c89;\n                          peg$currPos++;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c90); }\n                        }\n                        if (s0 as any === peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 105) {\n                            s0 = peg$c91;\n                            peg$currPos++;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c92); }\n                          }\n                          if (s0 as any === peg$FAILED) {\n                            if (input.charCodeAt(peg$currPos) === 86) {\n                              s0 = peg$c93;\n                              peg$currPos++;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c94); }\n                            }\n                            if (s0 as any === peg$FAILED) {\n                              if (input.charCodeAt(peg$currPos) === 118) {\n                                s0 = peg$c95;\n                                peg$currPos++;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c96); }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeralBass(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c7;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordModifier();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseNumeralRoot();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c97(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumeric(): any {\n    let s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseChordModifier();\n    if (s1 as any === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseNumericRoot();\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseChordSuffix();\n        if (s4 as any !== peg$FAILED) {\n          s3 = input.substring(s3, peg$currPos);\n        } else {\n          s3 = s4;\n        }\n        if (s3 as any !== peg$FAILED) {\n          s4 = peg$parseNumericBass();\n          if (s4 as any === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 as any !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c98(s1, s2, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumericRoot(): any {\n    let s0;\n\n    if (peg$c99.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c100); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNumericBass(): any {\n    let s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 47) {\n      s1 = peg$c7;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n    }\n    if (s1 as any !== peg$FAILED) {\n      s2 = peg$parseChordModifier();\n      if (s2 as any === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 as any !== peg$FAILED) {\n        s3 = peg$parseNumericRoot();\n        if (s3 as any !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c97(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nexport interface ParseOptions {\n  filename?: string;\n  startRule?: string;\n  tracer?: any;\n  [key: string]: any;\n}\nexport type ParseFunction = (input: string, options?: ParseOptions) => any;\nexport const parse: ParseFunction = peg$parse;\n\n","import HtmlFormatter, { CSS, Template } from './html_formatter';\nimport template from './templates/html_div_formatter';\nimport { scopeCss } from '../utilities';\n\nexport const defaultCss: CSS = {\n  '.chord:not(:last-child)': {\n    paddingRight: '10px',\n  },\n\n  '.paragraph': {\n    marginBottom: '1em',\n  },\n\n  '.row': {\n    display: 'flex',\n  },\n\n  '.chord:after': {\n    content: '\\'\\\\200b\\'',\n  },\n\n  '.lyrics:after': {\n    content: '\\'\\\\200b\\'',\n  },\n};\n\n/**\n * Generates basic CSS, scoped within the provided selector, to use with output generated by {@link HtmlTableFormatter}\n * @param scope the CSS scope to use, for example `.chordSheetViewer`\n * @returns {string} the CSS string\n */\nexport function scopedCss(scope: string): string {\n  return scopeCss(defaultCss, scope);\n}\n\n/**\n * Formats a song into HTML. It uses DIVs to align lyrics with chords, which makes it useful for responsive web pages.\n */\nclass HtmlDivFormatter extends HtmlFormatter {\n  get template(): Template {\n    return template;\n  }\n\n  get defaultCss(): CSS {\n    return defaultCss;\n  }\n}\n\nexport default HtmlDivFormatter;\n","import Formatter from './formatter';\nimport Configuration from './configuration/configuration';\nimport Song from '../chord_sheet/song';\nimport { breakingChange, scopeCss } from '../utilities';\nimport Paragraph from '../chord_sheet/paragraph';\n\nexport type HtmlTemplateArgs = {\n  configuration: Configuration;\n  song: Song;\n  renderBlankLines?: boolean;\n  bodyParagraphs: Paragraph[],\n};\n\nexport type Template = (_args: HtmlTemplateArgs) => string;\nexport type CSS = Record<string, Record<string, string>>;\n\n/**\n * Acts as a base class for HTML formatters\n */\nabstract class HtmlFormatter extends Formatter {\n  /**\n   * Formats a song into HTML.\n   * @param {Song} song The song to be formatted\n   * @returns {string} The HTML string\n   */\n  format(song: Song): string {\n    const { bodyParagraphs, expandedBodyParagraphs } = song;\n\n    return this.template(\n      {\n        song,\n        configuration: this.configuration,\n        bodyParagraphs: this.configuration.expandChorusDirective ? expandedBodyParagraphs : bodyParagraphs,\n      },\n    );\n  }\n\n  /**\n   * Generates basic CSS, optionally scoped within the provided selector, to use with the HTML output\n   * @deprecated\n   */\n  static cssString(_scope = ''): void {\n    breakingChange(\n      'The class method cssString() was removed in favor of the instance PROPERTY. '\n      + 'Please use `new <Formatter>().cssString` instead.',\n    );\n  }\n\n  /**\n   * Generates basic CSS, optionally scoped within the provided selector, to use with the HTML output\n   *\n   * For example, execute cssString('.chordSheetViewer') will result in CSS like:\n   *\n   *     .chordSheetViewer .paragraph {\n   *       margin-bottom: 1em;\n   *     }\n   *\n   * @param scope the CSS scope to use, for example `.chordSheetViewer`\n   * @returns {string} the CSS string\n   */\n  cssString(scope = ''): string {\n    return scopeCss(this.defaultCss, scope);\n  }\n\n  /**\n   * Basic CSS, in object style  la useStyles, to use with the HTML output\n   * @deprecated\n   */\n  static cssObject(): void {\n    breakingChange(\n      'The class method cssObject() was removed in favor of the instance PROPERTY. '\n      + 'Please use `new <Formatter>().cssObject` instead.',\n    );\n  }\n\n  /**\n   * Basic CSS, in object style  la useStyles, to use with the HTML output\n   * For a CSS string see {@link cssString}\n   *\n   * Example:\n   *\n   *     '.paragraph': {\n   *       marginBottom: '1em'\n   *     }\n   *\n   * @return {Object.<string, Object.<string, string>>} the CSS object\n   */\n  get cssObject(): CSS {\n    return this.defaultCss;\n  }\n\n  abstract get defaultCss(): CSS;\n\n  abstract get template(): Template;\n}\n\nexport default HtmlFormatter;\n","import { HtmlTemplateArgs } from \"../html_formatter\";\nimport { renderChord } from '../../helpers';\n\nimport {\n  each,\n  evaluate, fontStyleTag,\n  isChordLyricsPair,\n  isComment,\n  isEvaluatable,\n  isTag, keep,\n  lineClasses,\n  lineHasContents,\n  paragraphClasses,\n  stripHTML,\n  when,\n} from '../../template_helpers';\n\nexport default (\n  {\n    configuration,\n    configuration: {\n      key,\n    },\n    song,\n    renderBlankLines = false,\n    song: {\n      title,\n      subtitle,\n      metadata,\n    },\n    bodyParagraphs,\n  }: HtmlTemplateArgs,\n): string => stripHTML(`\n  ${ when(title, () => `<h1>${ title }</h1>`) }\n  ${ when(subtitle, () => `<h2>${ subtitle }</h2>`) }\n  \n  <div class=\"chord-sheet\">\n    ${ each(bodyParagraphs, (paragraph) => `\n      <div class=\"${ paragraphClasses(paragraph) }\">\n        ${ each(paragraph.lines, (line) => `\n          ${ when(renderBlankLines || lineHasContents(line), () => `\n            <div class=\"${ lineClasses(line) }\">\n              ${ each(line.items, (item) => `\n                ${ when(isChordLyricsPair(item), () => `\n                  <div class=\"column\">\n                    <div class=\"chord\"${ fontStyleTag(line.chordFont) }>${ \n                      renderChord(\n                        item.chords, \n                        line, \n                        song, \n                        {\n                          renderKey: key, \n                          useUnicodeModifier: configuration.useUnicodeModifiers,\n                          normalizeChords: configuration.normalizeChords,\n                        }\n                      ) \n                    }</div>\n                    <div class=\"lyrics\"${ fontStyleTag(line.textFont) }>${ item.lyrics }</div>\n                  </div>\n                `) }\n                \n                ${ when(isTag(item), () => `\n                  ${ when(isComment(item), () => `\n                    <div class=\"comment\">${ item.value }</div>\n                  `) }\n                  \n                  ${ when(item.hasRenderableLabel(), () => `\n                    <h3 class=\"label\">${ item.value }</h3>\n                  `) }\n                `) }\n                \n                ${ when(isEvaluatable(item), () => `\n                  <div class=\"column\">\n                    <div class=\"chord\"></div>\n                    <div class=\"lyrics\"${ fontStyleTag(line.textFont) }>${ evaluate(item, metadata, configuration) }</div>\n                  </div>\n                `) }\n              `) }\n            </div>\n          `) }\n        `) }\n      </div>\n    `) }\n  </div>\n`);\n","import Chord from './chord';\nimport Key from './key';\nimport { capos, majorKeys, minorKeys } from './key_config';\nimport Song from './chord_sheet/song';\nimport { CAPO } from './chord_sheet/tag';\nimport Line from './chord_sheet/line';\n\nexport function transposeDistance(transposeKey: string, songKey: string): number {\n  if (/^\\d+$/.test(transposeKey)) {\n    return parseInt(transposeKey, 10);\n  }\n\n  return Key.distance(songKey, transposeKey);\n}\n\nfunction chordTransposeDistance(capo: number, transposeKey: string | null, songKey: string, renderKey: Key | null) {\n  let transpose = -1 * (capo || 0);\n\n  if (songKey) {\n    if (transposeKey) {\n      transpose += transposeDistance(transposeKey, songKey);\n    }\n\n    if (renderKey) {\n      transpose += Key.distance(songKey, renderKey);\n    }\n  }\n\n  return transpose;\n}\n\ninterface RenderChordOptions {\n  renderKey?: Key | null;\n  useUnicodeModifier?: boolean;\n  normalizeChords?: boolean;\n}\n\nexport function renderChord(\n  chordString: string,\n  line: Line,\n  song: Song,\n  {\n    renderKey = null,\n    useUnicodeModifier = false,\n    normalizeChords = true,\n  }: RenderChordOptions = {},\n): string {\n  const chord = Chord.parse(chordString);\n  const songKey = song.key;\n  const capo = parseInt(song.metadata.getSingle(CAPO), 10);\n\n  if (!chord) {\n    return chordString;\n  }\n\n  const effectiveTransposeDistance = chordTransposeDistance(capo, line.transposeKey, songKey, renderKey);\n  const effectiveKey = renderKey || Key.wrap(line.key || song.key)?.transpose(effectiveTransposeDistance) || null;\n  const transposedChord = chord.transpose(effectiveTransposeDistance);\n  const normalizedChord = (normalizeChords ? transposedChord.normalize(effectiveKey) : transposedChord);\n\n  return normalizedChord.toString({ useUnicodeModifier });\n}\n\n/**\n * Returns applicable capos for the provided key\n * @param {Key|string} key The key to get capos for\n * @returns {Object.<string, string>} The available capos, where the keys are capo numbers and the\n * values are the effective key for that capo.\n */\nexport function getCapos(key: Key | string): Record<string, string> {\n  return capos[Key.toString(key)];\n}\n\n/**\n * Returns applicable keys to transpose to from the provided key\n * @param {Key|string} key The key to get keys for\n * @returns {Array<string>} The available keys\n */\nexport function getKeys(key: Key | string): string[] {\n  const keyObj = Key.wrapOrFail(key);\n  return keyObj.isMinor() ? minorKeys : majorKeys;\n}\n","export const majorKeys: string[] = [\n  'A', 'Bb', 'B', 'C', 'C#', 'Db', 'D', 'Eb', 'E', 'F', 'F#', 'Gb', 'G', 'G#', 'Ab',\n];\n\nexport const minorKeys: string[] = [\n  'F#m', 'Gm', 'G#m', 'Am', 'Bbm', 'Bm', 'Cm', 'C#m', 'Dm', 'D#m', 'Ebm', 'Em', 'Fm',\n];\n\nexport const capos: Record<string, Record<string, string>> = {\n  Bb: {\n    1: 'A', 3: 'G', 6: 'E', 8: 'D', 10: 'C',\n  },\n  D: {\n    2: 'C', 5: 'A', 7: 'G', 10: 'E',\n  },\n  Eb: {\n    1: 'D', 3: 'C', 6: 'A', 8: 'G',\n  },\n  Db: {\n    1: 'C', 4: 'A', 6: 'G', 9: 'E',\n  },\n  'C#': {\n    1: 'C', 4: 'A', 6: 'G', 9: 'E',\n  },\n  E: {\n    2: 'D', 4: 'C', 7: 'A', 9: 'G',\n  },\n  F: {\n    1: 'E', 3: 'D', 5: 'C', 6: 'B', 8: 'A', 10: 'G',\n  },\n  'F#': {\n    2: 'E', 4: 'D', 6: 'C', 7: 'B', 9: 'A',\n  },\n  Gb: {\n    2: 'E', 4: 'D', 6: 'C', 7: 'B', 9: 'A',\n  },\n  G: {\n    3: 'E', 5: 'D', 7: 'C', 8: 'B', 10: 'A',\n  },\n  'G#': {\n    1: 'G', 4: 'E', 6: 'D', 8: 'C',\n  },\n  Ab: {\n    1: 'G', 4: 'E', 6: 'D', 8: 'C',\n  },\n  A: {\n    2: 'G', 5: 'E', 7: 'D', 9: 'C',\n  },\n  B: {\n    2: 'A', 4: 'G', 7: 'E', 9: 'D',\n  },\n  C: {\n    3: 'A', 5: 'G', 8: 'E', 10: 'D',\n  },\n  Am: { 3: 'F#m', 5: 'Em', 7: 'Dm' },\n  Bbm: {\n    1: 'Am', 4: 'F#m', 6: 'Em', 8: 'Dm',\n  },\n  Bm: { 2: 'Am', 5: 'F#m', 7: 'Em' },\n  Cm: {\n    1: 'Bm', 3: 'Am', 6: 'F#m', 8: 'Em',\n  },\n  'C#m': {\n    2: 'Bm', 4: 'Am', 7: 'F#m', 9: 'Em',\n  },\n  Dm: { 3: 'Bm', 5: 'Am', 8: 'F#m' },\n  Ebm: { 1: 'Dm', 4: 'Bm', 6: 'Am' },\n  'D#m': { 1: 'Dm', 4: 'Bm', 6: 'Am' },\n};\n","import ChordLyricsPair from './chord_sheet/chord_lyrics_pair';\nimport Tag from './chord_sheet/tag';\nimport { INDETERMINATE, NONE } from './constants';\nimport { isEmptyString, isEvaluatable } from './utilities';\nimport Item from './chord_sheet/item';\nimport Line from './chord_sheet/line';\nimport Paragraph from './chord_sheet/paragraph';\nimport Metadata from './chord_sheet/metadata';\nimport Configuration from './formatter/configuration/configuration';\nimport Evaluatable from './chord_sheet/chord_pro/evaluatable';\nimport Font from './chord_sheet/font';\n\ninterface EachCallback {\n  (_item: any): string;\n}\n\ninterface WhenCallback {\n  (): string;\n}\n\ninterface KeepCallback {\n  (_items: any[]): string;\n}\n\nexport { isEvaluatable } from './utilities';\n\nexport const isChordLyricsPair = (item: Item): boolean => item instanceof ChordLyricsPair;\n\nexport const lineHasContents = (line: Line): boolean => line.items.some((item: Item) => item.isRenderable());\n\nexport const isTag = (item: Item): boolean => item instanceof Tag;\n\nexport const isComment = (item: Tag): boolean => item.name === 'comment';\n\nexport function stripHTML(string: string): string {\n  return string.trim().replace(/(<\\/[a-z]+>)\\s+(<)/g, '$1$2').replace(/(\\n)\\s+/g, '');\n}\n\nexport function each(collection: any[], callback: EachCallback): string {\n  return collection.map(callback).join('');\n}\n\nexport function when(condition: any, callback: WhenCallback): string {\n  return condition ? callback() : '';\n}\n\nexport function keep(variables: any[], callback: KeepCallback): string {\n  return callback.call(null, variables);\n}\n\nexport const hasTextContents = (line: Line): boolean => (\n  line.items.some((item) => (\n    (item instanceof ChordLyricsPair && !isEmptyString(item.lyrics))\n    || (item instanceof Tag && item.isRenderable())\n    || isEvaluatable(item)\n  ))\n);\n\nexport const lineClasses = (line: Line): string => {\n  const classes = ['row'];\n\n  if (!lineHasContents(line)) {\n    classes.push('empty-line');\n  }\n\n  return classes.join(' ');\n};\n\nexport const paragraphClasses = (paragraph: Paragraph): string => {\n  const classes = ['paragraph'];\n\n  if (paragraph.type !== INDETERMINATE && paragraph.type !== NONE) {\n    classes.push(paragraph.type);\n  }\n\n  return classes.join(' ');\n};\n\nexport const evaluate = (item: Evaluatable, metadata: Metadata, configuration: Configuration): string => {\n  if (!metadata) {\n    throw new Error('cannot evaluate, metadata is null');\n  }\n\n  return item.evaluate(metadata, configuration.get('metadata.separator'));\n};\n\nexport function fontStyleTag(font: Font) {\n  const cssString = font.toCssString();\n\n  if (cssString) {\n    return ` style=\"${cssString}\"`;\n  }\n\n  return '';\n}\n","import HtmlFormatter, { Template, CSS } from './html_formatter';\nimport template from './templates/html_table_formatter';\nimport { scopeCss } from '../utilities';\n\n/**\n * Basic CSS, in object style  la useStyles, to use with output generated by {@link }HtmlTableFormatter}\n * For a CSS string see {@link scopedCss}\n * @type {Object.<string, Object.<string, string>>}\n */\nexport const defaultCss: CSS = {\n  h1: {\n    fontSize: '1.5em',\n  },\n  h2: {\n    fontSize: '1.1em',\n  },\n  table: {\n    borderSpacing: '0',\n    color: 'inherit',\n  },\n  td: {\n    padding: '3px 0',\n  },\n  '.chord:not(:last-child)': {\n    paddingRight: '10px',\n  },\n  '.paragraph': {\n    marginBottom: '1em',\n  },\n};\n\n/**\n * Generates basic CSS, scoped within the provided selector, to use with output generated by {@link HtmlTableFormatter}\n * @param scope the CSS scope to use, for example `.chordSheetViewer`\n * @returns {string} the CSS string\n */\nexport function scopedCss(scope: string): string {\n  return scopeCss(defaultCss, scope);\n}\n\n/**\n * Formats a song into HTML. It uses TABLEs to align lyrics with chords, which makes the HTML for things like\n * PDF conversion.\n */\nclass HtmlTableFormatter extends HtmlFormatter {\n  get template(): Template {\n    return template;\n  }\n\n  get defaultCss(): CSS {\n    return defaultCss;\n  }\n}\n\nexport default HtmlTableFormatter;\n","import { hasChordContents, isEvaluatable } from '../../utilities';\nimport { renderChord } from '../../helpers';\nimport { HtmlTemplateArgs } from '../html_formatter';\n\nimport {\n  each,\n  evaluate,\n  fontStyleTag,\n  hasTextContents,\n  isChordLyricsPair,\n  isComment,\n  isTag,\n  lineClasses,\n  lineHasContents,\n  paragraphClasses,\n  stripHTML,\n  when,\n} from '../../template_helpers';\n\nexport default (\n  {\n    configuration,\n    configuration: {\n      key,\n    },\n    song,\n    renderBlankLines = false,\n    song: {\n      title,\n      subtitle,\n      bodyLines,\n      metadata,\n    },\n    bodyParagraphs,\n  }: HtmlTemplateArgs,\n): string => stripHTML(`\n  ${ when(title, () => `<h1>${ title}</h1>`) }\n  ${ when(subtitle, () => `<h2>${ subtitle}</h2>`) }\n\n  ${ when(bodyLines.length > 0, () => `\n    <div class=\"chord-sheet\">\n      ${ each(bodyParagraphs, (paragraph) => `\n        <div class=\"${ paragraphClasses(paragraph)}\">\n          ${ each(paragraph.lines, (line) => `\n            ${ when(renderBlankLines || lineHasContents(line), () => `\n              <table class=\"${ lineClasses(line)}\">\n                ${ when(hasChordContents(line), () => `\n                  <tr>\n                    ${ each(line.items, (item) => `\n                      ${ when(isChordLyricsPair(item), () => `\n                        <td class=\"chord\"${fontStyleTag(line.chordFont)}>${ \n                          renderChord(\n                            item.chords, \n                            line, \n                            song, \n                            { \n                              renderKey: key, \n                              useUnicodeModifier: configuration.useUnicodeModifiers,\n                              normalizeChords: configuration.normalizeChords,\n                            },\n                          ) \n                        }</td>\n                      `)}\n                    `)}\n                  </tr>\n                `)}\n                \n                ${ when(hasTextContents(line), () => `\n                  <tr>\n                    ${ each(line.items, (item) => `\n                      ${ when(isChordLyricsPair(item), () => `\n                        <td class=\"lyrics\"${fontStyleTag(line.textFont)}>${ item.lyrics}</td>\n                      `)}\n                      \n                      ${ when(isTag(item), () => `\n                        ${ when(isComment(item), () => `\n                          <td class=\"comment\"${fontStyleTag(line.textFont)}>${ item.value }</td>\n                        `) }\n                        \n                        ${ when(item.hasRenderableLabel(), () => `\n                          <td><h3 class=\"label\"${fontStyleTag(line.textFont)}>${ item.value }</h3></td>\n                        `) }\n                      `) }\n                      \n                      ${ when(isEvaluatable(item), () => `\n                        <td class=\"lyrics\"${fontStyleTag(line.textFont)}>${ evaluate(item, metadata, configuration) }</td>\n                      `) }\n                    `)}\n                  </tr>\n                `)}\n              </table>\n            `)}\n          `)}\n        </div>\n      `)}\n    </div>\n  `)}\n`);\n","import Formatter from './formatter';\nimport ChordLyricsPair from '../chord_sheet/chord_lyrics_pair';\nimport Tag from '../chord_sheet/tag';\nimport { renderChord } from '../helpers';\nimport { hasTextContents } from '../template_helpers';\nimport Song from '../chord_sheet/song';\nimport { hasChordContents, isEmptyString, padLeft } from '../utilities';\nimport Paragraph from '../chord_sheet/paragraph';\nimport Metadata from '../chord_sheet/metadata';\nimport Line from '../chord_sheet/line';\nimport Item from '../chord_sheet/item';\n\n/**\n * Formats a song into a plain text chord sheet\n */\nclass TextFormatter extends Formatter {\n  song: Song = new Song();\n\n  /**\n   * Formats a song into a plain text chord sheet\n   * @param {Song} song The song to be formatted\n   * @returns {string} the chord sheet\n   */\n  format(song: Song): string {\n    this.song = song;\n\n    return [\n      this.formatHeader(),\n      this.formatParagraphs(),\n    ].join('');\n  }\n\n  formatHeader(): string {\n    const { title, subtitle } = this.song;\n    const separator = (title || subtitle) ? '\\n' : '';\n\n    return [\n      this.formatTitle(title),\n      this.formatSubTitle(subtitle),\n      separator,\n    ].join('');\n  }\n\n  formatParagraphs(): string {\n    const { bodyParagraphs, expandedBodyParagraphs, metadata } = this.song;\n    const { expandChorusDirective } = this.configuration;\n\n    return (expandChorusDirective ? expandedBodyParagraphs : bodyParagraphs)\n      .map((paragraph: Paragraph) => this.formatParagraph(paragraph, metadata))\n      .join('\\n\\n');\n  }\n\n  formatParagraph(paragraph: Paragraph, metadata: Metadata): string {\n    return paragraph.lines\n      .filter((line) => line.hasRenderableItems())\n      .map((line) => this.formatLine(line, metadata))\n      .join('\\n');\n  }\n\n  formatLine(line: Line, metadata: Metadata): string {\n    const parts = [\n      this.formatLineTop(line, metadata),\n      this.formatLineBottom(line, metadata),\n    ];\n\n    return parts\n      .filter((p) => !isEmptyString(p))\n      .map((part) => (part || '').trimRight())\n      .join('\\n');\n  }\n\n  formatTitle(title: string): string {\n    if (title) {\n      return `${title.toUpperCase()}\\n`;\n    }\n\n    return '';\n  }\n\n  formatSubTitle(subtitle: string): string {\n    if (subtitle) {\n      return `${subtitle}\\n`;\n    }\n\n    return '';\n  }\n\n  formatLineTop(line: Line, metadata: Metadata): string | null {\n    if (hasChordContents(line)) {\n      return this.formatLineWithFormatter(line, this.formatItemTop, metadata);\n    }\n\n    return null;\n  }\n\n  chordLyricsPairLength(chordLyricsPair: ChordLyricsPair, line: Line): number {\n    const chords = this.renderChords(chordLyricsPair, line);\n    const { lyrics } = chordLyricsPair;\n    const chordsLength = (chords || '').length;\n    const lyricsLength = (lyrics || '').length;\n\n    if (chordsLength >= lyricsLength) {\n      return chordsLength + 1;\n    }\n\n    return Math.max(chordsLength, lyricsLength);\n  }\n\n  private renderChords(chordLyricsPair: ChordLyricsPair, line: Line) {\n    const chords = renderChord(\n      chordLyricsPair.chords,\n      line,\n      this.song,\n      {\n        renderKey: this.configuration.key,\n        useUnicodeModifier: this.configuration.useUnicodeModifiers,\n        normalizeChords: this.configuration.normalizeChords,\n      },\n    );\n    return chords;\n  }\n\n  formatItemTop(item: Item, _metadata: Metadata, line: Line): string {\n    if (item instanceof Tag && item.isRenderable()) {\n      return item.value || '';\n    }\n\n    if (item instanceof ChordLyricsPair) {\n      const chords = this.renderChords(item, line);\n      return padLeft(chords, this.chordLyricsPairLength(item, line));\n    }\n\n    return '';\n  }\n\n  formatLineBottom(line: Line, metadata: Metadata): string {\n    if (hasTextContents(line)) {\n      return this.formatLineWithFormatter(line, this.formatItemBottom, metadata);\n    }\n\n    return '';\n  }\n\n  formatLineWithFormatter(\n    line: Line,\n    formatter: (_item: Item, _metadata: Metadata, _line: Line) => string,\n    metadata: Metadata,\n  ): string {\n    return line\n      .items\n      .map((item) => formatter.call(this, item, metadata, line))\n      .join('');\n  }\n\n  formatItemBottom(item: Item, metadata: Metadata, line: Line): string {\n    if (item instanceof Tag && item.isRenderable()) {\n      return item.value || '';\n    }\n\n    if (item instanceof ChordLyricsPair) {\n      return padLeft(item.lyrics || '', this.chordLyricsPairLength(item, line));\n    }\n\n    if ('evaluate' in item) {\n      return item.evaluate(metadata, this.configuration.get('metadata.separator'));\n    }\n\n    return '';\n  }\n}\n\nexport default TextFormatter;\n","import { CHORUS, NONE, VERSE } from '../constants';\nimport ChordSheetParser from './chord_sheet_parser';\n\nimport Tag, {\n  COMMENT,\n  END_OF_CHORUS,\n  END_OF_VERSE,\n  START_OF_CHORUS,\n  START_OF_VERSE,\n} from '../chord_sheet/tag';\n\nconst VERSE_LINE_REGEX = /^\\[Verse.*]/;\nconst CHORUS_LINE_REGEX = /^\\[Chorus]/;\nconst OTHER_METADATA_LINE_REGEX = /^\\[([^\\]]+)]/;\n\nconst startSectionTags = {\n  [VERSE]: START_OF_VERSE,\n  [CHORUS]: START_OF_CHORUS,\n};\n\nconst endSectionTags = {\n  [VERSE]: END_OF_VERSE,\n  [CHORUS]: END_OF_CHORUS,\n};\n\n/**\n * Parses an Ultimate Guitar chord sheet with metadata\n * Inherits from {@link ChordSheetParser}\n */\nclass UltimateGuitarParser extends ChordSheetParser {\n  currentSectionType: string | null = null;\n\n  parseLine(line): void {\n    if (this.isSectionEnd()) {\n      this.endSection();\n    }\n\n    if (VERSE_LINE_REGEX.test(line)) {\n      this.startNewLine();\n      this.startSection(VERSE);\n    } else if (CHORUS_LINE_REGEX.test(line)) {\n      this.startNewLine();\n      this.startSection(CHORUS);\n    } else if (OTHER_METADATA_LINE_REGEX.test(line)) {\n      this.parseMetadataLine(line);\n    } else {\n      super.parseLine(line);\n    }\n  }\n\n  private parseMetadataLine(line) {\n    this.startNewLine();\n    this.endSection();\n    const comment = line.match(OTHER_METADATA_LINE_REGEX)[1];\n\n    if (!this.songLine) throw new Error('Expected this.songLine to be present');\n\n    this.songLine.addTag(new Tag(COMMENT, comment));\n  }\n\n  isSectionEnd(): boolean {\n    return this.songLine !== null\n      && this.songLine.isEmpty()\n      && this.song.previousLine !== null\n      && !this.song.previousLine.isEmpty();\n  }\n\n  endOfSong() {\n    super.endOfSong();\n    if (this.currentSectionType !== null && this.currentSectionType in endSectionTags) {\n      this.startNewLine();\n    }\n    this.endSection({ addNewLine: false });\n  }\n\n  startSection(sectionType) {\n    if (this.currentSectionType) {\n      this.endSection();\n    }\n\n    this.currentSectionType = sectionType;\n    this.song.setCurrentProperties(sectionType);\n\n    if (sectionType in startSectionTags) {\n      this.song.addTag(new Tag(startSectionTags[sectionType]));\n    }\n  }\n\n  endSection({ addNewLine = true } = {}) {\n    if (this.currentSectionType !== null && this.currentSectionType in endSectionTags) {\n      this.song.addTag(new Tag(endSectionTags[this.currentSectionType]));\n\n      if (addNewLine) {\n        this.startNewLine();\n      }\n    }\n\n    this.song.setCurrentProperties(NONE);\n    this.currentSectionType = null;\n  }\n\n  startNewLine() {\n    this.songLine = this.song.addLine();\n  }\n}\n\nexport default UltimateGuitarParser;\n"],"names":[],"version":3,"file":"module.js.map"}