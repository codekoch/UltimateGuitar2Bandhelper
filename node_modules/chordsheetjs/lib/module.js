import $iPNDK$lodashget from "lodash.get";

// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs
"use strict";
function $7cb09a9be1aff7bc$var$peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
class $7cb09a9be1aff7bc$export$628c65c376ead699 extends Error {
    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch));
        }
        function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch));
        }
        function describeExpectation(expectation) {
            switch(expectation.type){
                case "literal":
                    return '"' + literalEscape(expectation.text) + '"';
                case "class":
                    const escapedParts = expectation.parts.map((part)=>{
                        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            const descriptions = expected1.map(describeExpectation);
            let i;
            let j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
                descriptions.length = j;
            }
            switch(descriptions.length){
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
    constructor(message, expected, found, location){
        super();
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "PeggySyntaxError";
        if (typeof Object.setPrototypeOf === "function") Object.setPrototypeOf(this, $7cb09a9be1aff7bc$export$628c65c376ead699.prototype);
        else this.__proto__ = $7cb09a9be1aff7bc$export$628c65c376ead699.prototype;
        if (typeof Error.captureStackTrace === "function") Error.captureStackTrace(this, $7cb09a9be1aff7bc$export$628c65c376ead699);
    }
    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            let k;
            for(k = 0; k < sources.length; k++)if (sources[k].grammarSource === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
            }
            let s = this.location.start;
            let loc = this.location.source + ":" + s.line + ":" + s.column;
            if (src) {
                let e = this.location.end;
                let filler = $7cb09a9be1aff7bc$var$peg$padEnd("", s.line.toString().length, " ");
                let line = src[s.line - 1];
                let last = s.line === e.line ? e.column : line.length + 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + s.line + " | " + line + "\n" + filler + " | " + $7cb09a9be1aff7bc$var$peg$padEnd("", s.column - 1, " ") + $7cb09a9be1aff7bc$var$peg$padEnd("", last - s.column, "^");
            } else str += "\n at " + loc;
        }
        return str;
    }
}
function $7cb09a9be1aff7bc$var$peg$parse(input, options) {
    options = options !== undefined ? options : {};
    const peg$FAILED = {};
    const peg$source = options.grammarSource;
    const peg$startRuleFunctions = {
        Chord: peg$parseChord
    };
    let peg$startRuleFunction = peg$parseChord;
    const peg$c0 = function(chord) {
        return {
            type: "chord",
            ...chord,
            column: location().start.column
        };
    };
    const peg$c1 = "#";
    const peg$c2 = peg$literalExpectation("#", false);
    const peg$c3 = "b";
    const peg$c4 = peg$literalExpectation("b", false);
    const peg$c5 = /^[a-zA-Z0-9()#+]/;
    const peg$c6 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "A",
            "Z"
        ],
        [
            "0",
            "9"
        ],
        "(",
        ")",
        "#",
        "+"
    ], false, false);
    const peg$c7 = function(root, modifier, suffix, bass) {
        return {
            base: root,
            modifier: modifier,
            suffix: suffix,
            ...bass,
            chordType: "symbol"
        };
    };
    const peg$c8 = /^[A-Ga-g]/;
    const peg$c9 = peg$classExpectation([
        [
            "A",
            "G"
        ],
        [
            "a",
            "g"
        ]
    ], false, false);
    const peg$c10 = "/";
    const peg$c11 = peg$literalExpectation("/", false);
    const peg$c12 = function(root, modifier) {
        return {
            bassBase: root,
            bassModifier: modifier
        };
    };
    const peg$c13 = function(modifier, root, suffix, bass) {
        return {
            base: root,
            modifier: modifier,
            suffix: suffix,
            ...bass,
            chordType: "numeral"
        };
    };
    const peg$c14 = "III";
    const peg$c15 = peg$literalExpectation("III", false);
    const peg$c16 = "iii";
    const peg$c17 = peg$literalExpectation("iii", false);
    const peg$c18 = "VII";
    const peg$c19 = peg$literalExpectation("VII", false);
    const peg$c20 = "vii";
    const peg$c21 = peg$literalExpectation("vii", false);
    const peg$c22 = "II";
    const peg$c23 = peg$literalExpectation("II", false);
    const peg$c24 = "ii";
    const peg$c25 = peg$literalExpectation("ii", false);
    const peg$c26 = "IV";
    const peg$c27 = peg$literalExpectation("IV", false);
    const peg$c28 = "iv";
    const peg$c29 = peg$literalExpectation("iv", false);
    const peg$c30 = "VI";
    const peg$c31 = peg$literalExpectation("VI", false);
    const peg$c32 = "vi";
    const peg$c33 = peg$literalExpectation("vi", false);
    const peg$c34 = "I";
    const peg$c35 = peg$literalExpectation("I", false);
    const peg$c36 = "i";
    const peg$c37 = peg$literalExpectation("i", false);
    const peg$c38 = "V";
    const peg$c39 = peg$literalExpectation("V", false);
    const peg$c40 = "v";
    const peg$c41 = peg$literalExpectation("v", false);
    const peg$c42 = function(modifier, root) {
        return {
            bassBase: root,
            bassModifier: modifier
        };
    };
    const peg$c43 = function(modifier, root, suffix, bass) {
        return {
            base: root,
            modifier: modifier,
            suffix: suffix,
            ...bass,
            chordType: "numeric"
        };
    };
    const peg$c44 = /^[1-7]/;
    const peg$c45 = peg$classExpectation([
        [
            "1",
            "7"
        ]
    ], false, false);
    let peg$currPos = 0;
    let peg$savedPos = 0;
    const peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    let peg$maxFailPos = 0;
    let peg$maxFailExpected = [];
    let peg$silentFails = 0;
    let peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return {
            type: "literal",
            text: text1,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);
        return {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new $7cb09a9be1aff7bc$export$628c65c376ead699(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new $7cb09a9be1aff7bc$export$628c65c376ead699($7cb09a9be1aff7bc$export$628c65c376ead699.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$parseChord() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseNumeral();
        if (s1 === peg$FAILED) {
            s1 = peg$parseNumeric();
            if (s1 === peg$FAILED) s1 = peg$parseChordSymbol();
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c0(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseChordModifier() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 35) {
            s0 = peg$c1;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c2);
        }
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 98) {
                s0 = peg$c3;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c4);
            }
        }
        return s0;
    }
    function peg$parseChordSuffix() {
        let s0, s1;
        s0 = [];
        if (peg$c5.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c6);
        }
        while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c5.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c6);
            }
        }
        return s0;
    }
    function peg$parseChordSymbol() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseChordSymbolRoot();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordModifier();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseChordSuffix();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseChordSymbolBass();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c7(s1, s2, s3, s4);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordSymbolRoot() {
        let s0;
        if (peg$c8.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c9);
        }
        return s0;
    }
    function peg$parseChordSymbolBass() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c10;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordSymbolRoot();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseChordModifier();
                if (s3 === peg$FAILED) s3 = null;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c12(s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumeral() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseChordModifier();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNumeralRoot();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseChordSuffix();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseNumeralBass();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c13(s1, s2, s3, s4);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumeralRoot() {
        let s0;
        if (input.substr(peg$currPos, 3) === peg$c14) {
            s0 = peg$c14;
            peg$currPos += 3;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c15);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c16) {
                s0 = peg$c16;
                peg$currPos += 3;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c17);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c18) {
                    s0 = peg$c18;
                    peg$currPos += 3;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c19);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c20) {
                        s0 = peg$c20;
                        peg$currPos += 3;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c21);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c22) {
                            s0 = peg$c22;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c23);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c24) {
                                s0 = peg$c24;
                                peg$currPos += 2;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c25);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c26) {
                                    s0 = peg$c26;
                                    peg$currPos += 2;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c27);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c28) {
                                        s0 = peg$c28;
                                        peg$currPos += 2;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$c29);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c30) {
                                            s0 = peg$c30;
                                            peg$currPos += 2;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$c31);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c32) {
                                                s0 = peg$c32;
                                                peg$currPos += 2;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$c33);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 73) {
                                                    s0 = peg$c34;
                                                    peg$currPos++;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$c35);
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 105) {
                                                        s0 = peg$c36;
                                                        peg$currPos++;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$c37);
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 86) {
                                                            s0 = peg$c38;
                                                            peg$currPos++;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$c39);
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                            if (input.charCodeAt(peg$currPos) === 118) {
                                                                s0 = peg$c40;
                                                                peg$currPos++;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$c41);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseNumeralBass() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c10;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordModifier();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$parseNumeralRoot();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c42(s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumeric() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseChordModifier();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNumericRoot();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseChordSuffix();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseNumericBass();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c43(s1, s2, s3, s4);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumericRoot() {
        let s0;
        if (peg$c44.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c45);
        }
        return s0;
    }
    function peg$parseNumericBass() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c10;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordModifier();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$parseNumericRoot();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c42(s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
const $7cb09a9be1aff7bc$export$98e6a39c04603d36 = $7cb09a9be1aff7bc$var$peg$parse;


/**
 * Used to mark a paragraph as verse
 * @constant
 * @type {string}
 */ const $234747a9630b4642$export$4b194284baed1659 = "verse";
const $234747a9630b4642$export$8db6c706fc9142b2 = "chorus";
const $234747a9630b4642$export$c53d0f541b41b88e = "none";
const $234747a9630b4642$export$c5a6fe907430212e = "indeterminate";
const $234747a9630b4642$export$f1c9dd0f5207dd5e = "tab";
const $234747a9630b4642$export$27c95a7104c1f7aa = "symbol";
const $234747a9630b4642$export$4d318981b5a83836 = "numeric";
const $234747a9630b4642$export$1321df9b16c30c6a = "numeral";
const $234747a9630b4642$export$6145372d252f6576 = [
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII"
];


const $172dbd369d182971$var$A = "A".charCodeAt(0);
const $172dbd369d182971$var$G = "G".charCodeAt(0);
const $172dbd369d182971$var$TRANSPOSE_DISTANCE_MAJOR = {
    1: 0,
    2: 2,
    3: 4,
    4: 5,
    5: 7,
    6: 9,
    7: 11
};
const $172dbd369d182971$var$TRANSPOSE_DISTANCE_MINOR = {
    1: 0,
    2: 2,
    3: 3,
    4: 5,
    5: 7,
    6: 8,
    7: 11
};
function $172dbd369d182971$var$keyToCharCode(key) {
    return key.toUpperCase().charCodeAt(0);
}
function $172dbd369d182971$var$clamp(note, min, max) {
    let newNote = note;
    if (newNote < min) newNote += 7;
    else if (newNote > max) newNote -= 7;
    return newNote;
}
function $172dbd369d182971$var$numeralToNumber(numeral) {
    for(let i = 0, count = (0, $234747a9630b4642$export$6145372d252f6576).length; i < count; i += 1){
        const romanNumeral = (0, $234747a9630b4642$export$6145372d252f6576)[i];
        if (romanNumeral === numeral || romanNumeral.toLowerCase() === numeral) return i + 1;
    }
    return null;
}
function $172dbd369d182971$var$numberToNumeral(number) {
    return (0, $234747a9630b4642$export$6145372d252f6576)[number - 1];
}
class $172dbd369d182971$var$Note {
    minor = false;
    constructor({ note: note , type: type , minor: minor = false  }){
        this._note = note;
        this.type = type;
        this.minor = minor;
    }
    static parse(note) {
        const noteString = note.toString();
        if (/^[A-Ga-g]$/.test(noteString)) return new $172dbd369d182971$var$Note({
            note: noteString.toUpperCase(),
            type: (0, $234747a9630b4642$export$27c95a7104c1f7aa)
        });
        if (/^[1-7]$/.test(noteString)) return new $172dbd369d182971$var$Note({
            note: parseInt(noteString, 10),
            type: (0, $234747a9630b4642$export$4d318981b5a83836)
        });
        const romanNumeralValue = $172dbd369d182971$var$numeralToNumber(noteString);
        if (romanNumeralValue) return new $172dbd369d182971$var$Note({
            note: romanNumeralValue,
            type: (0, $234747a9630b4642$export$1321df9b16c30c6a),
            minor: noteString.toLowerCase() === note
        });
        throw new Error(`Invalid note ${note}`);
    }
    toNumeral() {
        if (this.isNumeral()) return this.clone();
        if (this.isNumeric()) return this.set({
            type: (0, $234747a9630b4642$export$1321df9b16c30c6a)
        });
        throw new Error(`Converting a ${this.type} note to numeral is not supported`);
    }
    toNumeric() {
        if (this.isNumeric()) return this.clone();
        if (this.isNumeral()) return this.set({
            type: (0, $234747a9630b4642$export$4d318981b5a83836)
        });
        throw new Error(`Converting a ${this.type} note to numeric is not supported`);
    }
    isMinor() {
        return this.minor;
    }
    equals(otherNote) {
        return this._note === otherNote._note && this.type === otherNote.type && this.minor === otherNote.minor;
    }
    clone() {
        return this.set({});
    }
    up() {
        return this.change(1);
    }
    down() {
        return this.change(-1);
    }
    isOneOf(...options) {
        return options.includes(this._note);
    }
    isNumeric() {
        return this.is((0, $234747a9630b4642$export$4d318981b5a83836));
    }
    isChordSymbol() {
        return this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa));
    }
    isNumeral() {
        return this.is((0, $234747a9630b4642$export$1321df9b16c30c6a));
    }
    is(noteType) {
        return this.type === noteType;
    }
    getTransposeDistance(minor) {
        if (typeof this._note === "number") {
            if (minor && this._note in $172dbd369d182971$var$TRANSPOSE_DISTANCE_MINOR) return $172dbd369d182971$var$TRANSPOSE_DISTANCE_MINOR[this._note];
            if (this._note in $172dbd369d182971$var$TRANSPOSE_DISTANCE_MAJOR) return $172dbd369d182971$var$TRANSPOSE_DISTANCE_MAJOR[this._note];
        }
        return 0;
    }
    change(delta) {
        if (this.isChordSymbol()) {
            let charCode;
            charCode = $172dbd369d182971$var$keyToCharCode(this._note);
            charCode += delta;
            charCode = $172dbd369d182971$var$clamp(charCode, $172dbd369d182971$var$A, $172dbd369d182971$var$G);
            return this.set({
                note: String.fromCharCode(charCode)
            });
        }
        let newNote = $172dbd369d182971$var$clamp(this._note + delta, 1, 7);
        if (newNote < 1) newNote += 7;
        else if (newNote > 7) newNote -= 7;
        return this.set({
            note: newNote
        });
    }
    get note() {
        if (this.isNumeral()) {
            const numeral = $172dbd369d182971$var$numberToNumeral(this._note);
            if (this.isMinor()) return numeral.toLowerCase();
            return numeral;
        }
        return this._note;
    }
    toString() {
        const note = this.note;
        switch(this.type){
            case 0, $234747a9630b4642$export$1321df9b16c30c6a:
                return `${this.minor ? note.toLowerCase() : note.toUpperCase()}`;
            default:
                return `${this.note}`;
        }
    }
    set(properties) {
        return new $172dbd369d182971$var$Note({
            note: this._note,
            type: this.type,
            minor: this.minor,
            ...properties
        });
    }
}
var $172dbd369d182971$export$2e2bcd8739ae039 = $172dbd369d182971$var$Note;



const $a2e1bf5465822273$var$enharmonics = {
    "Ab": {
        "B": "Cb"
    },
    "Cb": {
        "B": "Cb",
        "A#": "Bb",
        "E": "Fb"
    },
    "C": {
        "C#": "Db",
        "D#": "Eb",
        "F#": "Gb",
        "G#": "Ab",
        "A#": "Bb"
    },
    "C#": {
        "Eb": "D#",
        "Bb": "A#"
    },
    "Db": {
        "B": "Cb",
        "F#": "Gb"
    },
    "D": {
        "D#": "Eb",
        "A#": "Bb",
        "Gb": "F#"
    },
    "Eb": {
        "D#": "Eb",
        "F#": "Gb",
        "G#": "Ab",
        "A#": "Bb"
    },
    "E": {
        "Ab": "G#",
        "A#": "Bb",
        "D#": "Eb",
        "Db": "C#",
        "Eb": "D#"
    },
    "F": {
        "A#": "Bb",
        "F#": "Gb",
        "C#": "Db",
        "D#": "Eb",
        "G#": "Ab"
    },
    "F#": {
        "Bb": "A#",
        "Eb": "D#"
    },
    "Gb": {
        "A#": "Bb",
        "D#": "Eb",
        "G#": "Ab",
        "B": "Cb",
        "E": "Fb"
    },
    "G": {
        "A#": "Bb",
        "D#": "Eb",
        "G#": "Ab",
        "C#": "Db"
    },
    "G#": {
        "A#": "Bb",
        "D#": "Eb",
        "Cb": "B#"
    },
    "Am": {
        "Gb": "G",
        "G#": "Ab",
        "F#": "Gb",
        "C#": "Db",
        "D#": "Eb",
        "A#": "Bb"
    },
    "Bbm": {
        "Cb": "B",
        "Gb": "F#"
    },
    "Bm": {
        "A#": "Bb",
        "D#": "Eb"
    },
    "C#m": {
        "A#": "Bb",
        "D#": "Eb",
        "Gb": "F#"
    },
    "Cm": {
        "G#": "Ab",
        "A#": "Bb",
        "D#": "Eb",
        "F#": "Gb",
        "C#": "Db"
    },
    "Dm": {
        "A#": "Bb",
        "D#": "Eb",
        "F#": "Gb",
        "G#": "Ab",
        "C#": "Db"
    },
    "Em": {
        "A#": "Bb",
        "D#": "Eb",
        "C#": "Db"
    },
    "F#m": {
        "A#": "Bb",
        "D#": "Eb",
        "Gb": "F#",
        "Ab": "G#",
        "Db": "C#"
    },
    "Fm": {
        "G#": "Ab",
        "A#": "Bb",
        "D#": "Eb",
        "F#": "Gb",
        "C#": "Db"
    },
    "Gm": {
        "G#": "Ab",
        "A#": "Bb",
        "D#": "Eb",
        "C#": "Db",
        "F#": "Gb"
    },
    "G#m": {
        "A#": "Bb",
        "D#": "Eb"
    },
    "B": {
        "Eb": "D#"
    }
};
var $a2e1bf5465822273$export$2e2bcd8739ae039 = $a2e1bf5465822273$var$enharmonics;



const $974bd1d260bb1d53$export$d332d76d125f0cbe = (line)=>line.items.some((item)=>item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039) && !!item.chords);
const $974bd1d260bb1d53$export$e3f63561d52b936d = (item)=>"evaluate" in item && typeof item.evaluate === "function";
const $974bd1d260bb1d53$export$bc3bea8325045070 = (string, length)=>{
    let paddedString = string;
    for(let l = string.length; l < length; l += 1, paddedString += " ");
    return paddedString;
};
const $974bd1d260bb1d53$export$ee27c052bca048fb = (object)=>!!object && object.length > 0;
const $974bd1d260bb1d53$export$844ec244b1367d54 = (obj)=>typeof obj === "string";
function $974bd1d260bb1d53$var$dasherize(string) {
    return string.replace(/[A-Z]/g, (match)=>`-${match.toLowerCase()}`);
}
function $974bd1d260bb1d53$export$59d377d2a2e0150a(css, scope = "") {
    return Object.entries(css).map(([selector, styles])=>{
        const rules = Object.entries(styles).map(([property, value])=>`${$974bd1d260bb1d53$var$dasherize(property)}: ${value};`).join("\n  ");
        const scopedSelector = `${scope} ${selector}`.trim();
        return `
${scopedSelector} {
  ${rules}
}`.substring(1);
    }).join("\n\n");
}
function $974bd1d260bb1d53$export$b680e6b2c82f8c2f(message) {
    try {
        throw new Error(`DEPRECATION: ${message}`);
    } catch (e) {
        const error = e;
        const proc = globalThis.process;
        if (typeof proc === "object" && typeof proc.emitWarning === "function") proc.emitWarning(`${message}\n${error.stack}`);
        else console.warn(`${message}\n${error.stack}`);
    }
}
function $974bd1d260bb1d53$export$c73e2a74b163f89e(message) {
    throw new Error(`BREAKING CHANGE: ${message}`);
}
function $974bd1d260bb1d53$export$78d1711480f95c3e(string) {
    return string === null || string === undefined || string === "";
}
function $974bd1d260bb1d53$export$51fabfbeed747719(suffix) {
    if (typeof suffix !== "string") return false;
    return suffix[0] === "m" && suffix.substring(0, 3).toLowerCase() !== "maj";
}
function $974bd1d260bb1d53$export$ba13e0e2f19e61a1(string) {
    return string.replace(/\r\n?/g, "\n");
}


const $918eb2016ac61e41$var$FLAT = "b";
const $918eb2016ac61e41$var$SHARP = "#";
const $918eb2016ac61e41$var$symbolKeyRegex = /^(?<note>[A-G])(?<modifier>#|b)?(?<minor>m)?$/i;
const $918eb2016ac61e41$var$numericKeyRegex = /^(?<modifier>#|b)?(?<note>[1-7])(?<minor>m)?$/;
const $918eb2016ac61e41$var$numeralKeyRegex = /^(?<modifier>#|b)?(?<note>I{1,3}|IV|VI{0,2}|i{1,3}|iv|vi{0,2})$/;
const $918eb2016ac61e41$var$regexes = [
    $918eb2016ac61e41$var$symbolKeyRegex,
    $918eb2016ac61e41$var$numericKeyRegex,
    $918eb2016ac61e41$var$numeralKeyRegex
];
function $918eb2016ac61e41$var$modifierTransposition(modifier) {
    switch(modifier){
        case $918eb2016ac61e41$var$SHARP:
            return 1;
        case $918eb2016ac61e41$var$FLAT:
            return -1;
        default:
            return 0;
    }
}
/**
 * Represents a key, such as Eb (symbol), #3 (numeric) or VII (numeral).
 *
 * The only function considered public API is `Key.distance`
 */ class $918eb2016ac61e41$var$Key {
    modifier = null;
    get unicodeModifier() {
        switch(this.modifier){
            case $918eb2016ac61e41$var$FLAT:
                return "♭";
            case $918eb2016ac61e41$var$SHARP:
                return "♯";
            default:
                return null;
        }
    }
    minor = false;
    static parse(keyString) {
        if (!keyString || (0, $974bd1d260bb1d53$export$78d1711480f95c3e)(keyString)) return null;
        for(let i = 0, count = $918eb2016ac61e41$var$regexes.length; i < count; i += 1){
            const match = keyString.match($918eb2016ac61e41$var$regexes[i]);
            if (match) {
                const { note: note , modifier: modifier , minor: minor  } = match.groups;
                return new $918eb2016ac61e41$var$Key({
                    note: note,
                    modifier: modifier,
                    minor: !!minor
                });
            }
        }
        return null;
    }
    static parseOrFail(keyString) {
        const parsed = this.parse(keyString);
        if (!parsed) throw new Error(`Failed to parse ${keyString}`);
        return parsed;
    }
    static wrap(keyStringOrObject) {
        if (keyStringOrObject instanceof $918eb2016ac61e41$var$Key) return keyStringOrObject;
        return this.parse(keyStringOrObject);
    }
    static wrapOrFail(keyStringOrObject = null) {
        if (keyStringOrObject === null) throw new Error("Unexpected null key");
        const wrapped = this.wrap(keyStringOrObject);
        if (wrapped === null) throw new Error(`Failed: invalid key ${keyStringOrObject}`);
        return wrapped;
    }
    static toString(keyStringOrObject) {
        return `${$918eb2016ac61e41$var$Key.wrapOrFail(keyStringOrObject)}`;
    }
    /**
   * Calculates the distance in semitones between one key and another.
   * @param {Key | string} oneKey the key
   * @param {Key | string} otherKey the other key
   * @return {number} the distance in semitones
   */ static distance(oneKey, otherKey) {
        return this.wrapOrFail(oneKey).distanceTo(otherKey);
    }
    distanceTo(otherKey) {
        const otherKeyObj = $918eb2016ac61e41$var$Key.wrapOrFail(otherKey);
        let key = this.useModifier(otherKeyObj.modifier);
        let delta = 0;
        while(!key.equals(otherKeyObj) && delta < 20){
            key = key.transposeUp().useModifier(otherKeyObj.modifier);
            delta += 1;
        }
        return delta;
    }
    constructor({ note: note , modifier: modifier = null , minor: minor = false  }){
        this.note = note instanceof (0, $172dbd369d182971$export$2e2bcd8739ae039) ? note : (0, $172dbd369d182971$export$2e2bcd8739ae039).parse(note);
        this.modifier = modifier || null;
        this.minor = minor || false;
        if (this.minor) this.note.minor = true;
    }
    isMinor() {
        return this.minor || this.note.isMinor();
    }
    clone() {
        return this.set({});
    }
    toChordSymbol(key) {
        if (this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa))) return this.clone();
        const transposeDistance = this.note.getTransposeDistance(key.minor) + $918eb2016ac61e41$var$modifierTransposition(this.modifier);
        return key.transpose(transposeDistance).normalize().useModifier(key.modifier);
    }
    toChordSymbolString(key) {
        return this.toChordSymbol(key).toString();
    }
    is(type) {
        return this.note.is(type);
    }
    isNumeric() {
        return this.is((0, $234747a9630b4642$export$4d318981b5a83836));
    }
    isChordSymbol() {
        return this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa));
    }
    isNumeral() {
        return this.is((0, $234747a9630b4642$export$1321df9b16c30c6a));
    }
    equals(otherKey) {
        return this.note.equals(otherKey.note) && this.modifier === otherKey.modifier;
    }
    toNumeric(key = null) {
        if (this.isNumeric()) return this.clone();
        if (this.isNumeral()) return this.set({
            note: this.note.toNumeric()
        });
        if (!key) throw new Error("key is required");
        return this.transposeNoteUpToKey(1, key);
    }
    toNumericString(key = null) {
        return this.toNumeric(key).toString();
    }
    toNumeral(key = null) {
        if (this.isNumeral()) return this.clone();
        if (this.isNumeric()) return this.set({
            note: this.note.toNumeral()
        });
        if (key) return this.transposeNoteUpToKey("I", key);
        return this.clone();
    }
    toNumeralString(key = null) {
        return this.toNumeral(key).toString();
    }
    toString({ showMinor: showMinor = true , useUnicodeModifier: useUnicodeModifier = false  } = {}) {
        switch(this.note.type){
            case 0, $234747a9630b4642$export$27c95a7104c1f7aa:
                return this.formatChordSymbolString(showMinor, useUnicodeModifier);
            case 0, $234747a9630b4642$export$4d318981b5a83836:
                return this.formatNumericString(showMinor);
            case 0, $234747a9630b4642$export$1321df9b16c30c6a:
                return this.formatNumeralString();
            default:
                throw new Error(`Unexpected note type ${this.note.type}`);
        }
    }
    formatChordSymbolString(showMinor, unicodeModifier) {
        const modifier = unicodeModifier ? this.unicodeModifier : this.modifier;
        return `${this.note}${modifier || ""}${this.minor && showMinor ? "m" : ""}`;
    }
    formatNumericString(showMinor) {
        return `${this.modifier || ""}${this.note}${this.minor && showMinor ? "m" : ""}`;
    }
    formatNumeralString() {
        return `${this.modifier || ""}${this.note}`;
    }
    transpose(delta) {
        if (delta === 0) return this;
        const originalModifier = this.modifier;
        let transposedKey = this.clone();
        const func = delta < 0 ? "transposeDown" : "transposeUp";
        for(let i = 0, count = Math.abs(delta); i < count; i += 1)transposedKey = transposedKey[func]();
        return transposedKey.useModifier(originalModifier);
    }
    transposeUp() {
        if (this.modifier === $918eb2016ac61e41$var$FLAT) return this.set({
            modifier: null
        });
        if (this.note.isOneOf(3, 7, "E", "B")) return this.set({
            note: this.note.up()
        });
        if (this.modifier === $918eb2016ac61e41$var$SHARP) return this.set({
            note: this.note.up(),
            modifier: null
        });
        return this.set({
            modifier: $918eb2016ac61e41$var$SHARP
        });
    }
    transposeDown() {
        if (this.modifier === $918eb2016ac61e41$var$SHARP) return this.set({
            modifier: null
        });
        if (this.note.isOneOf(1, 4, "C", "F")) return this.set({
            note: this.note.down()
        });
        if (this.modifier === $918eb2016ac61e41$var$FLAT) return this.set({
            note: this.note.down(),
            modifier: null
        });
        return this.set({
            modifier: $918eb2016ac61e41$var$FLAT
        });
    }
    useModifier(newModifier) {
        if (this.modifier === $918eb2016ac61e41$var$FLAT && newModifier === $918eb2016ac61e41$var$SHARP) return this.set({
            note: this.note.down(),
            modifier: $918eb2016ac61e41$var$SHARP
        });
        if (this.modifier === $918eb2016ac61e41$var$SHARP && newModifier === $918eb2016ac61e41$var$FLAT) return this.set({
            note: this.note.up(),
            modifier: $918eb2016ac61e41$var$FLAT
        });
        return this.clone();
    }
    normalize() {
        if (this.modifier === $918eb2016ac61e41$var$SHARP && this.note.isOneOf(3, 7, "E", "B")) return this.set({
            note: this.note.up(),
            modifier: null
        });
        if (this.modifier === $918eb2016ac61e41$var$FLAT && this.note.isOneOf(1, 4, "C", "F")) return this.set({
            note: this.note.down(),
            modifier: null
        });
        return this.clone();
    }
    removeMinor() {
        return this.set({
            minor: false
        });
    }
    normalizeEnharmonics(key) {
        if (key) {
            const rootKeyString = $918eb2016ac61e41$var$Key.wrapOrFail(key).toString({
                showMinor: true
            });
            const enharmonics = (0, $a2e1bf5465822273$export$2e2bcd8739ae039)[rootKeyString];
            const thisKeyString = this.toString({
                showMinor: false
            });
            if (enharmonics && enharmonics[thisKeyString]) return $918eb2016ac61e41$var$Key.parseOrFail(enharmonics[thisKeyString]);
        }
        return this.clone();
    }
    set(attributes) {
        return new $918eb2016ac61e41$var$Key({
            note: this.note.clone(),
            modifier: this.modifier,
            minor: this.minor,
            ...attributes
        });
    }
    transposeNoteUpToKey(note, key) {
        let numericKey = new $918eb2016ac61e41$var$Key({
            note: note
        });
        let symbolKey = key.clone();
        const reference = this.clone().normalize().useModifier(key.modifier).normalizeEnharmonics(key);
        while(!symbolKey.equals(reference)){
            numericKey = numericKey.transposeUp().useModifier(key.modifier);
            symbolKey = symbolKey.transposeUp().normalize().useModifier(key.modifier).normalizeEnharmonics(key);
        }
        return numericKey;
    }
}
var $918eb2016ac61e41$export$2e2bcd8739ae039 = $918eb2016ac61e41$var$Key;


const $7ec1df4bbc0938c9$var$mapping = {
    "2": "2",
    "4": "sus",
    "5": "5",
    "6": "6",
    "7": "7",
    "9": "9",
    "11": "11",
    "13": "13",
    "42": "4(2)",
    "69": "6(9)",
    "(#4)": "(#4)",
    "#4": "(#4)",
    "+4": "(#4)",
    "(+4)": "(#4)",
    "(11)": "(11)",
    "add11": "(11)",
    "(add11)": "(11)",
    "(13)": "(13)",
    "add13": "(13)",
    "(add13)": "(13)",
    "(2)": "(2)",
    "add2": "(2)",
    "(add2)": "(2)",
    "(4)": "(4)",
    "add4": "(4)",
    "(add4)": "(4)",
    "sus(4)": "(4)",
    "(6)": "(6)",
    "add6": "(6)",
    "(add6)": "(6)",
    "(7)": "(7)",
    "(9)": "(9)",
    "add9": "(9)",
    "(add9)": "(9)",
    "(b5)": "(b5)",
    "-5": "(b5)",
    "(-5)": "(b5)",
    "b5": "(b5)",
    "2(6)": "2(6)",
    "(b6)": "(b6)",
    "(unis)": "(unis)",
    "unis": "(unis)",
    "[blank]": "[blank]",
    "maj": "[blank]",
    "major": "[blank]",
    "M": "[blank]",
    "ma": "[blank]",
    "Ma": "[blank]",
    "Majj": "[blank]",
    "+": "+",
    "aug": "+",
    "(#5)": "+",
    "#5": "+",
    "+5": "+",
    "(+5)": "+",
    "x": "+",
    "dom11": "11",
    "dom 11": "11",
    "11(#5)": "11(#5)",
    "11#5": "11(#5)",
    "11+5": "11(#5)",
    "11(+5)": "11(#5)",
    "11(#9)": "11(#9)",
    "11#9": "11(#9)",
    "11+9": "11(#9)",
    "11(+9)": "11(#9)",
    "11(b13)": "11(b13)",
    "11b13": "11(b13)",
    "11-13": "11(b13)",
    "11(-13)": "11(b13)",
    "11(b5)": "11(b5)",
    "11b5": "11(b5)",
    "11-5": "11(b5)",
    "11(-5)": "11(b5)",
    "11(b9)": "11(b9)",
    "11b9": "11(b9)",
    "11-9": "11(b9)",
    "11(-9)": "11(b9)",
    "11sus4": "11sus4",
    "11sus": "11sus4",
    "m11sus4": "11sus4",
    "m11sus": "11sus4",
    "dom13": "13",
    "dom 13": "13",
    "13(#11)": "13(#11)",
    "13#11": "13(#11)",
    "13+11": "13(#11)",
    "13(+11)": "13(#11)",
    "13(#5)": "13(#5)",
    "13#5": "13(#5)",
    "13+5": "13(#5)",
    "13(+5)": "13(#5)",
    "13(#9)": "13(#9)",
    "13#9": "13(#9)",
    "13(+9)": "13(#9)",
    "13+9": "13(#9)",
    "13(#9#5)": "13(#9#5)",
    "13#9#5": "13(#9#5)",
    "13(+9+5)": "13(#9#5)",
    "13+9+5": "13(#9#5)",
    "13(#9b5)": "13(#9b5)",
    "13#9b5": "13(#9b5)",
    "13(+9-5)": "13(#9b5)",
    "13+9-5": "13(#9b5)",
    "13(add4)": "13(add4)",
    "13(b5)": "13(b5)",
    "13b5": "13(b5)",
    "13-5": "13(b5)",
    "13(-5)": "13(b5)",
    "13(b9)": "13(b9)",
    "13b9": "13(b9)",
    "13-9": "13(b9)",
    "13(-9)": "13(b9)",
    "13(b9#5)": "13(b9#5)",
    "13b9#5": "13(b9#5)",
    "13-9+5": "13(b9#5)",
    "13(-9+5)": "13(b9#5)",
    "13(b9b5)": "13(b9b5)",
    "13b9b5": "13(b9b5)",
    "13-9-5": "13(b9b5)",
    "13(-9-5)": "13(b9b5)",
    "13sus4": "13sus4",
    "13sus": "13sus4",
    "m13sus4": "13sus4",
    "m13sus": "13sus4",
    "sus2": "2",
    "add9(no3)": "2",
    "2(#11)": "2(#11)",
    "2(#4)": "2(#4)",
    "2+4": "2(#4)",
    "2#4": "2(#4)",
    "2(+4)": "2(#4)",
    "(#4)2": "2(#4)",
    "2(#4)(#42)(2#4)": "2(#4)(#42)(2#4)",
    "2(+7)": "2(+7)",
    "2(4)": "2(4)",
    "sus2(4)": "2(4)",
    "2(ma7)": "2(ma7)",
    "2(no3)": "2(no3)",
    "4(2)": "4(2)",
    "sus42": "4(2)",
    "no3": "5",
    "(no3)": "5",
    "(no 3)": "5",
    "(no 3rd)": "5",
    "5(no3)": "5",
    "6(2)": "6(2)",
    "6(b9)": "6(b9)",
    "6(no3)": "6(no3)",
    "6(9)": "6(9)",
    "6(add9)": "6(9)",
    "dom7": "7",
    "dom 7": "7",
    "dom 7th": "7",
    "7(#11)": "7(#11)",
    "7#11": "7(#11)",
    "7+11": "7(#11)",
    "7(+11)": "7(#11)",
    "7(#5)": "7(#5)",
    "aug7": "7(#5)",
    "7#5": "7(#5)",
    "7+5": "7(#5)",
    "7(+5)": "7(#5)",
    "x7": "7(#5)",
    "aug 7": "7(#5)",
    "aug 7th": "7(#5)",
    "7(#5#11)": "7(#5#11)",
    "7#5#11": "7(#5#11)",
    "7+5+11": "7(#5#11)",
    "7(+5+11)": "7(#5#11)",
    "7(#9)": "7(#9)",
    "7#9": "7(#9)",
    "7+9": "7(#9)",
    "7(+9)": "7(#9)",
    "7(#9#5)": "7(#9#5)",
    "7(#5#9)": "7(#9#5)",
    "7#5#9": "7(#9#5)",
    "7+5+9": "7(#9#5)",
    "7(+5+9)": "7(#9#5)",
    "7(#9b13)": "7(#9b13)",
    "7#9b13": "7(#9b13)",
    "7(+9-13)": "7(#9b13)",
    "7+9-13": "7(#9b13)",
    "7(b13#9)": "7(#9b13)",
    "7b13#9": "7(#9b13)",
    "7-13+9": "7(#9b13)",
    "7(-13+9)": "7(#9b13)",
    "7(#9b5)": "7(#9b5)",
    "7(6)": "7(6)",
    "7(b13)": "7(b13)",
    "7b13": "7(b13)",
    "7-13": "7(b13)",
    "7(-13)": "7(b13)",
    "7(b5)": "7(b5)",
    "7b5": "7(b5)",
    "7-5": "7(b5)",
    "7(-5)": "7(b5)",
    "7(b5#11)": "7(b5#11)",
    "7b5#11": "7(b5#11)",
    "7-5+11": "7(b5#11)",
    "7(-5+11)": "7(b5#11)",
    "7(b5#9)": "7(b5#9)",
    "7b5#9": "7(b5#9)",
    "7-5+9": "7(b5#9)",
    "7(-5+9)": "7(b5#9)",
    "7(b5b9)": "7(b5b9)",
    "7b5b9": "7(b5b9)",
    "7-5-9": "7(b5b9)",
    "7(-5-9)": "7(b5b9)",
    "7(b9)": "7(b9)",
    "7b9": "7(b9)",
    "7-9": "7(b9)",
    "7(-9)": "7(b9)",
    "7(b9#5)": "7(b9#5)",
    "7(#5b9)": "7(b9#5)",
    "7#5b9": "7(b9#5)",
    "7+5-9": "7(b9#5)",
    "7(+5-9)": "7(b9#5)",
    "7(b9b13)": "7(b9b13)",
    "7b9b13": "7(b9b13)",
    "7-9-13": "7(b9b13)",
    "7(-9-13)": "7(b9b13)",
    "7(b13b9)": "7(b9b13)",
    "7b13b9": "7(b9b13)",
    "7-13-9": "7(b9b13)",
    "7(-13-9)": "7(b9b13)",
    "7(b9b5)": "7(b9b5)",
    "7(no3)": "7(no3)",
    "7aug5": "7aug5",
    "7b9sus4": "7b9sus4",
    "7sus(6)": "7sus(6)",
    "7sus(b9)": "7sus(b9)",
    "7sus4": "7sus4",
    "7sus": "7sus4",
    "dom9": "9",
    "dom 9": "9",
    "9(#11)": "9(#11)",
    "9#11": "9(#11)",
    "9+11": "9(#11)",
    "9(+11)": "9(#11)",
    "9(#5)": "9(#5)",
    "9#5": "9(#5)",
    "9+5": "9(#5)",
    "9(+5)": "9(#5)",
    "aug9": "9(#5)",
    "x9": "9(#5)",
    "9(b13)": "9(b13)",
    "9b13": "9(b13)",
    "9-13": "9(b13)",
    "9(-13)": "9(b13)",
    "9(b5)": "9(b5)",
    "9b5": "9(b5)",
    "9-5": "9(b5)",
    "9(-5)": "9(b5)",
    "9aug": "9aug",
    "9sus4": "9sus4",
    "9sus": "9sus4",
    "m9sus4": "9sus4",
    "m9sus": "9sus4",
    "b69(#11)": "b69(#11)",
    "b69sus": "b69sus",
    "b9sus": "b9sus",
    "dim": "dim",
    "m(b5)": "dim",
    "mb5": "dim",
    "m-5": "dim",
    "m(-5)": "dim",
    "-(b5)": "dim",
    "-b5": "dim",
    "dim7": "dim7",
    "o7": "dim7",
    "dim 7": "dim7",
    "dim 7th": "dim7",
    "m": "m",
    "mi": "m",
    "min": "m",
    "minor": "m",
    "-": "m",
    "m(11)": "m(11)",
    "m(add11)": "m(11)",
    "m(4)": "m(4)",
    "m(add4)": "m(4)",
    "m(9)": "m(9)",
    "m(add9)": "m(9)",
    "m(ma7)": "m(ma7)",
    "m(M7)": "m(ma7)",
    "mi(maj7)": "m(ma7)",
    "min(maj7)": "m(ma7)",
    "m(maj7)": "m(ma7)",
    "m(+7)": "m(ma7)",
    "m+7": "m(ma7)",
    "m(ma9)": "m(ma9)",
    "m(M9)": "m(ma9)",
    "mi(maj9)": "m(ma9)",
    "min(maj9)": "m(ma9)",
    "m(maj9)": "m(ma9)",
    "m(+9)": "m(ma9)",
    "m+9": "m(ma9)",
    "m(no5)": "m(no5)",
    "m11": "m11",
    "mi11": "m11",
    "min11": "m11",
    "-11": "m11",
    "m11(#5)": "m11(#5)",
    "m11#5": "m11(#5)",
    "m11+5": "m11(#5)",
    "m11(+5)": "m11(#5)",
    "-11(#5)": "m11(#5)",
    "-11#5": "m11(#5)",
    "m9+5": "m9(#5)",
    "-11(+5)": "m11(#5)",
    "m11(#9)": "m11(#9)",
    "m11#9": "m11(#9)",
    "m11+9": "m11(#9)",
    "m11(+9)": "m11(#9)",
    "-11(#9)": "m11(#9)",
    "-11#9": "m11(#9)",
    "-11+9": "m11(#9)",
    "-11(+9)": "m11(#9)",
    "m11(#9#5)": "m11(#9#5)",
    "m11(#5#9)": "m11(#9#5)",
    "m11#5#9": "m11(#9#5)",
    "m11+5+9": "m11(#9#5)",
    "m11(+5+9)": "m11(#9#5)",
    "-11(#5#9)": "m11(#9#5)",
    "-11#5#9": "m11(#9#5)",
    "m9+5+9": "m11(#9#5)",
    "-11(+5+9)": "m11(#9#5)",
    "m11(#9b13)": "m11(#9b13)",
    "m11#9b13": "m11(#9b13)",
    "m11+9-13": "m11(#9b13)",
    "m11(+9-13)": "m11(#9b13)",
    "-11(#9b13)": "m11(#9b13)",
    "-11#9b13": "m11(#9b13)",
    "-11+9-13": "m11(#9b13)",
    "-11(+9-13)": "m11(#9b13)",
    "m11(b13)": "m11(b13)",
    "m11b13": "m11(b13)",
    "m11-13": "m11(b13)",
    "m11(-13)": "m11(b13)",
    "-11(b13)": "m11(b13)",
    "-11b13": "m11(b13)",
    "-11-13": "m11(b13)",
    "-11(-13)": "m11(b13)",
    "m11(b13#5)": "m11(b13#5)",
    "m11(#5b13)": "m11(b13#5)",
    "m11#5b13": "m11(b13#5)",
    "m11+5-13": "m11(b13#5)",
    "m11(+5-13)": "m11(b13#5)",
    "-11(#5b13)": "m11(b13#5)",
    "-11#5b13": "m11(b13#5)",
    "-11+5-13": "m11(b13#5)",
    "-11(+5-13)": "m11(b13#5)",
    "m11(b5)": "m11(b5)",
    "m11b5": "m11(b5)",
    "m11-5": "m11(b5)",
    "m11(-5)": "m11(b5)",
    "-11(b5)": "m11(b5)",
    "-11b5": "m11(b5)",
    "-9-5": "m9(b5)",
    "-11(-5)": "m11(b5)",
    "m11(b5#9)": "m11(b5#9)",
    "m11b5#9": "m11(b5#9)",
    "m11-5+9": "m11(b5#9)",
    "m11(-5+9)": "m11(b5#9)",
    "-11(b5#9)": "m11(b5#9)",
    "-11b5#9": "m11(b5#9)",
    "-11-5+9": "m11(b5#9)",
    "-11(-5+9)": "m11(b5#9)",
    "m11(b5b13)": "m11(b5b13)",
    "m11b5b13": "m11(b5b13)",
    "m11(-5-13)": "m11(b5b13)",
    "m11-5-13": "m11(b5b13)",
    "-11(b5b13)": "m11(b5b13)",
    "-11b5b13": "m11(b5b13)",
    "-11(-5-13)": "m11(b5b13)",
    "-11-5-13": "m11(b5b13)",
    "m11(b5b9)": "m11(b5b9)",
    "m11b5b9": "m11(b5b9)",
    "m11-5-9": "m11(b5b9)",
    "m11(-5-9)": "m11(b5b9)",
    "-11(b5b9)": "m11(b5b9)",
    "-11b5b9": "m11(b5b9)",
    "-11-5-9": "m11(b5b9)",
    "-11(-5-9)": "m11(b5b9)",
    "m11(b9)": "m11(b9)",
    "m11b9": "m11(b9)",
    "m11(-9)": "m11(b9)",
    "m11-9": "m11(b9)",
    "-11(b9)": "m11(b9)",
    "-11b9": "m11(b9)",
    "-11(-9)": "m11(b9)",
    "-11-9": "m11(b9)",
    "m11(b9#5)": "m11(b9#5)",
    "m11(#5b9)": "m11(b9#5)",
    "m11#5b9": "m11(b9#5)",
    "m11+5-9": "m11(b9#5)",
    "m11(+5-9)": "m11(b9#5)",
    "-11(#5b9)": "m11(b9#5)",
    "-11#5b9": "m11(b9#5)",
    "m9+5-9": "m11(b9#5)",
    "-11(+5-9)": "m11(b9#5)",
    "m11(b9b13)": "m11(b9b13)",
    "m11b9b13": "m11(b9b13)",
    "m11(-9-13)": "m11(b9b13)",
    "m11-9-13": "m11(b9b13)",
    "-11(b9b13)": "m11(b9b13)",
    "-11b9b13": "m11(b9b13)",
    "-11(-9-13)": "m11(b9b13)",
    "-11-9-13": "m11(b9b13)",
    "m13": "m13",
    "mi13": "m13",
    "min13": "m13",
    "-13": "m13",
    "m13(#11)": "m13(#11)",
    "m13#11": "m13(#11)",
    "m13+11": "m13(#11)",
    "m13(+11)": "m13(#11)",
    "-13(#11)": "m13(#11)",
    "-13#11": "m13(#11)",
    "-13+11": "m13(#11)",
    "-13(+11)": "m13(#11)",
    "m13(#5)": "m13(#5)",
    "m13#5": "m13(#5)",
    "m13+5": "m13(#5)",
    "m13(+5)": "m13(#5)",
    "-13(#5)": "m13(#5)",
    "-13#5": "m13(#5)",
    "-13(+5)": "m13(#5)",
    "m13(#9)": "m13(#9)",
    "m13#9": "m13(#9)",
    "m13(+9)": "m13(#9)",
    "m13+9": "m13(#9)",
    "-13(#9)": "m13(#9)",
    "-13#9": "m13(#9)",
    "-13(+9)": "m13(#9)",
    "-13+9": "m13(#9)",
    "m13(b5)": "m13(b5)",
    "m13b5": "m13(b5)",
    "m13-5": "m13(b5)",
    "m13(-5)": "m13(b5)",
    "-13(b5)": "m13(b5)",
    "-13b5": "m13(b5)",
    "-13-5": "m13(b5)",
    "-13(-5)": "m13(b5)",
    "m13(b9)": "m13(b9)",
    "m13b9": "m13(b9)",
    "m13-9": "m13(b9)",
    "m13(-9)": "m13(b9)",
    "-13(b13)": "m13(b9)",
    "-13b13": "m13(b9)",
    "-13-13": "m13(b9)",
    "-13(-13)": "m13(b9)",
    "m2": "m2",
    "mi2": "m2",
    "min2": "m2",
    "m(add2)": "m2",
    "madd2": "m2",
    "m4": "m4",
    "m6": "m6",
    "mi6": "m6",
    "min6": "m6",
    "-6": "m6",
    "m6(#5)": "m6(#5)",
    "m6(9)": "m6(9)",
    "m6add9": "m6(9)",
    "m6(add9)": "m6(9)",
    "m69": "m6(9)",
    "m6(ma7)": "m6(ma7)",
    "m6(M7)": "m6(ma7)",
    "m6(+7)": "m6(ma7)",
    "m6M7": "m6(ma7)",
    "m6+7": "m6(ma7)",
    "m7": "m7",
    "mi7": "m7",
    "min7": "m7",
    "-7": "m7",
    "m7(#11)": "m7(#11)",
    "m7#11": "m7(#11)",
    "m7+11": "m7(#11)",
    "m7(+11)": "m7(#11)",
    "-7(#11)": "m7(#11)",
    "-7#11": "m7(#11)",
    "-7+11": "m7(#11)",
    "-7(+11)": "m7(#11)",
    "m7(#5)": "m7(#5)",
    "m7#5": "m7(#5)",
    "m7+5": "m7(#5)",
    "m7(+5)": "m7(#5)",
    "-7(#5)": "m7(#5)",
    "-7#5": "m7(#5)",
    "-7(+5)": "m7(#5)",
    "m7(#9)": "m7(#9)",
    "m7#9": "m7(#9)",
    "m7+9": "m7(#9)",
    "m7(+9)": "m7(#9)",
    "-7(#9)": "m7(#9)",
    "-7#9": "m7(#9)",
    "-7(+9)": "m7(#9)",
    "m7(11)": "m7(11)",
    "m7(4)": "m7(4)",
    "m7(add4)": "m7(4)",
    "m7(add11)": "m7(4)",
    "m74": "m7(4)",
    "m7(6)": "m7(6)",
    "m7(add6)": "m7(add6)",
    "m7(b13)": "m7(b13)",
    "m7b13": "m7(b13)",
    "m7-13": "m7(b13)",
    "m7(-13)": "m7(b13)",
    "-7(b13)": "m7(b13)",
    "-7b13": "m7(b13)",
    "-7-13": "m7(b13)",
    "-7(-13)": "m7(b13)",
    "m7(b5)": "m7(b5)",
    "m7b5": "m7(b5)",
    "m7-5": "m7(b5)",
    "m7(-5)": "m7(b5)",
    "-7(b5)": "m7(b5)",
    "-7b5": "m7(b5)",
    "-7(-5)": "m7(b5)",
    "m7(b9)": "m7(b9)",
    "m7b9": "m7(b9)",
    "m7-9": "m7(b9)",
    "m7(-9)": "m7(b9)",
    "-7(b9)": "m7(b9)",
    "-7b9": "m7(b9)",
    "-7(-9)": "m7(b9)",
    "m7(no3)": "m7(no3)",
    "min7(no3)": "m7(no3)",
    "m7sus4": "m7sus4",
    "m7sus": "m7sus4",
    "m9": "m9",
    "mi9": "m9",
    "min9": "m9",
    "-9": "m9",
    "m9(#11)": "m9(#11)",
    "m9#11": "m9(#11)",
    "m9+11": "m9(#11)",
    "m9(+11)": "m9(#11)",
    "-9(#11)": "m9(#11)",
    "-9#11": "m9(#11)",
    "-9+11": "m9(#11)",
    "-9(+11)": "m9(#11)",
    "m9(#5)": "m9(#5)",
    "m9#5": "m9(#5)",
    "m9(+5)": "m9(#5)",
    "-9(#5)": "m9(#5)",
    "-9#5": "m9(#5)",
    "-9(+5)": "m9(#5)",
    "m9(#7)": "m9(#7)",
    "m9(b13)": "m9(b13)",
    "m9b13": "m9(b13)",
    "m9-13": "m9(b13)",
    "m9(-13)": "m9(b13)",
    "-9(b13)": "m9(b13)",
    "-9b13": "m9(b13)",
    "-9-13": "m9(b13)",
    "-9(-13)": "m9(b13)",
    "m9(b5)": "m9(b5)",
    "m9b5": "m9(b5)",
    "m9-5": "m9(b5)",
    "m9(-5)": "m9(b5)",
    "-9(b5)": "m9(b5)",
    "-9b5": "m9(b5)",
    "-9(-5)": "m9(b5)",
    "m9(ma7)": "m9(ma7)",
    "m9(maj7)": "m9(ma7)",
    "m9(+7)": "m9(ma7)",
    "m9(M7)": "m9(ma7)",
    "m9M7": "m9(ma7)",
    "ma9": "ma9",
    "maj9": "ma9",
    "ma11": "ma11",
    "11(#7)": "ma11",
    "11#7": "ma11",
    "11+7": "ma11",
    "11(+7)": "ma11",
    "+11": "ma11",
    "M11": "ma11",
    "ma11(#5)": "ma11(#5)",
    "maj11#5": "ma11(#5)",
    "maj11+5": "ma11(#5)",
    "maj11(+5)": "ma11(#5)",
    "+11(#5)": "ma11(#5)",
    "+11#5": "ma11(#5)",
    "M11+5": "ma11(#5)",
    "+11(+5)": "ma11(#5)",
    "maj11(#5)": "ma11(#5)",
    "ma11#5": "ma11(#5)",
    "ma11+5": "ma11(#5)",
    "ma11(+5)": "ma11(#5)",
    "ma11(#9)": "ma11(#9)",
    "maj11#9": "ma11(#9)",
    "maj11+9": "ma11(#9)",
    "maj11(+9)": "ma11(#9)",
    "+11(#9)": "ma11(#9)",
    "+11#9": "ma11(#9)",
    "M11+9": "ma11(#9)",
    "+11(+9)": "ma11(#9)",
    "maj11(#9)": "ma11(#9)",
    "ma11#9": "ma11(#9)",
    "ma11+9": "ma11(#9)",
    "ma11(+9)": "ma11(#9)",
    "ma11(b13)": "ma11(b13)",
    "maj11b13": "ma11(b13)",
    "maj11-13": "ma11(b13)",
    "maj11(-13)": "ma11(b13)",
    "+11(b13)": "ma11(b13)",
    "+11b13": "ma11(b13)",
    "M11-13": "ma11(b13)",
    "+11(-13)": "ma11(b13)",
    "maj11(b13)": "ma11(b13)",
    "ma11b13": "ma11(b13)",
    "ma11-13": "ma11(b13)",
    "ma11(-13)": "ma11(b13)",
    "ma11(b5)": "ma11(b5)",
    "maj11b5": "ma11(b5)",
    "maj11-5": "ma11(b5)",
    "maj11(-5)": "ma11(b5)",
    "+11(b5)": "ma11(b5)",
    "+11b5": "ma11(b5)",
    "M11-5": "ma11(b5)",
    "+11(-5)": "ma11(b5)",
    "maj11(b5)": "ma11(b5)",
    "ma11b5": "ma11(b5)",
    "ma11-5": "ma11(b5)",
    "ma11(-5)": "ma11(b5)",
    "ma11(b9)": "ma11(b9)",
    "maj11b9": "ma11(b9)",
    "maj11(-9)": "ma11(b9)",
    "maj11-9": "ma11(b9)",
    "+11(b9)": "ma11(b9)",
    "+11b9": "ma11(b9)",
    "M11(-9)": "ma11(b9)",
    "+11-9": "ma11(b9)",
    "maj11(b9)": "ma11(b9)",
    "ma11b9": "ma11(b9)",
    "ma11(-9)": "ma11(b9)",
    "ma11-9": "ma11(b9)",
    "ma13": "ma13",
    "13(#7)": "ma13",
    "+13": "ma13",
    "M13": "ma13",
    "ma13(#11)": "ma13(#11)",
    "maj13#11": "ma13(#11)",
    "maj13+11": "ma13(#11)",
    "maj13(+11)": "ma13(#11)",
    "+13(#11)": "ma13(#11)",
    "+13#11": "ma13(#11)",
    "M13+11": "ma13(#11)",
    "+13(+11)": "ma13(#11)",
    "maj13(#11)": "ma13(#11)",
    "ma7#11": "ma9(#11)",
    "ma13+11": "ma13(#11)",
    "ma13(+11)": "ma13(#11)",
    "ma13(#11#5)": "ma13(#11#5)",
    "maj13#11#5": "ma13(#11#5)",
    "maj13+11+5": "ma13(#11#5)",
    "maj13(+11+5)": "ma13(#11#5)",
    "+13(#11#5)": "ma13(#11#5)",
    "+13#11#5": "ma13(#11#5)",
    "M13+11+5": "ma13(#11#5)",
    "+13(+11+5)": "ma13(#11#5)",
    "maj13(#11#5)": "ma13(#11#5)",
    "ma7#11#5": "ma9(#11#5)",
    "ma13+11+5": "ma13(#11#5)",
    "ma13(+11+5)": "ma13(#11#5)",
    "ma13(#5)": "ma13(#5)",
    "maj13#5": "ma13(#5)",
    "maj13+5": "ma13(#5)",
    "maj13(+5)": "ma13(#5)",
    "+13(#5)": "ma13(#5)",
    "+13#5": "ma13(#5)",
    "M13+5": "ma13(#5)",
    "+13(+5)": "ma13(#5)",
    "maj13(#5)": "ma13(#5)",
    "ma13#5": "ma13(#5)",
    "ma13+5": "ma13(#5)",
    "ma13(+5)": "ma13(#5)",
    "ma13(#9)": "ma13(#9)",
    "maj13#9": "ma13(#9)",
    "maj13(+9)": "ma13(#9)",
    "maj13+9": "ma13(#9)",
    "+13(#9)": "ma13(#9)",
    "+13#9": "ma13(#9)",
    "M13(+9)": "ma13(#9)",
    "+13+9": "ma13(#9)",
    "maj13(#9)": "ma13(#9)",
    "ma13#9": "ma13(#9)",
    "ma13(+9)": "ma13(#9)",
    "ma13+9": "ma13(#9)",
    "ma13(#9#5)": "ma13(#9#5)",
    "maj13#9#5": "ma13(#9#5)",
    "maj13(+9+5)": "ma13(#9#5)",
    "maj13+9+5": "ma13(#9#5)",
    "+13(#9#5)": "ma13(#9#5)",
    "+13#9#5": "ma13(#9#5)",
    "M13(+9+5)": "ma13(#9#5)",
    "+13+9+5": "ma13(#9#5)",
    "maj13(#9#5)": "ma13(#9#5)",
    "ma7#9#5": "ma13(#9#5)",
    "ma13(+9+5)": "ma13(#9#5)",
    "ma13+9+5": "ma13(#9#5)",
    "ma13(b5)": "ma13(b5)",
    "maj13b5": "ma13(b5)",
    "maj13-5": "ma13(b5)",
    "maj13(-5)": "ma13(b5)",
    "+13(b5)": "ma13(b5)",
    "+13b5": "ma13(b5)",
    "M13-5": "ma13(b5)",
    "+13(-5)": "ma13(b5)",
    "maj13(b5)": "ma13(b5)",
    "ma13b5": "ma13(b5)",
    "ma13-5": "ma13(b5)",
    "ma13(-5)": "ma13(b5)",
    "ma13(b9)": "ma13(b9)",
    "maj13b9": "ma13(b9)",
    "maj13-9": "ma13(b9)",
    "maj13(-9)": "ma13(b9)",
    "+13(b9)": "ma13(b9)",
    "+13b9": "ma13(b9)",
    "M13-9": "ma13(b9)",
    "+13(-9)": "ma13(b9)",
    "maj13(b9)": "ma13(b9)",
    "ma13b9": "ma13(b9)",
    "ma13-9": "ma13(b9)",
    "ma13(-9)": "ma13(b9)",
    "ma13(b9#5)": "ma13(b9#5)",
    "maj13b9#5": "ma13(b9#5)",
    "maj13-9+5": "ma13(b9#5)",
    "maj13(-9+5)": "ma13(b9#5)",
    "+13(b9#5)": "ma13(b9#5)",
    "+13b9#5": "ma13(b9#5)",
    "M13-9+5": "ma13(b9#5)",
    "+13(-9+5)": "ma13(b9#5)",
    "maj13(b9#5)": "ma13(b9#5)",
    "ma7b9#5": "ma13(b9#5)",
    "ma13-9+5": "ma13(b9#5)",
    "ma13(-9+5)": "ma13(b9#5)",
    "ma6": "ma6",
    "ma6(9)": "ma6(9)",
    "ma69": "ma6(9)",
    "ma7": "ma7",
    "+7": "ma7",
    "#7": "ma7",
    "M7": "ma7",
    "Maj7": "ma7",
    "maj7": "ma7",
    "(triangle)": "ma7",
    "ma7(#11)": "ma7(#11)",
    "maj7#11": "ma7(#11)",
    "maj7+11": "ma7(#11)",
    "maj7(+11)": "ma7(#11)",
    "+7(#11)": "ma7(#11)",
    "+7#11": "ma7(#11)",
    "M7+11": "ma7(#11)",
    "+7(+11)": "ma7(#11)",
    "maj7(#11)": "ma7(#11)",
    "ma7+11": "ma7(#11)",
    "ma7(+11)": "ma7(#11)",
    "ma7(#4)": "ma7(#4)",
    "ma7(#5)": "ma7(#5)",
    "maj7#5": "ma7(#5)",
    "maj7+5": "ma7(#5)",
    "maj7(+5)": "ma7(#5)",
    "+7(#5)": "ma7(#5)",
    "+7#5": "ma7(#5)",
    "M7+5": "ma7(#5)",
    "+7(+5)": "ma7(#5)",
    "maj7(#5)": "ma7(#5)",
    "ma7#5": "ma7(#5)",
    "ma7+5": "ma7(#5)",
    "ma7(+5)": "ma7(#5)",
    "aug(M7)": "ma7(#5)",
    "aug(+7)": "ma7(#5)",
    "aug(ma7)": "ma7(#5)",
    "aug(maj7)": "ma7(#5)",
    "ma7(#9)": "ma7(#9)",
    "maj7#9": "ma7(#9)",
    "maj7+9": "ma7(#9)",
    "maj7(+9)": "ma7(#9)",
    "+7(#9)": "ma7(#9)",
    "+7#9": "ma7(#9)",
    "M7+9": "ma7(#9)",
    "+7(+9)": "ma7(#9)",
    "maj7(#9)": "ma7(#9)",
    "ma7#9": "ma7(#9)",
    "ma7+9": "ma7(#9)",
    "ma7(+9)": "ma7(#9)",
    "ma7(b13)": "ma7(b13)",
    "maj7b13": "ma7(b13)",
    "maj7-13": "ma7(b13)",
    "maj7(-13)": "ma7(b13)",
    "+7(b13)": "ma7(b13)",
    "+7b13": "ma7(b13)",
    "M7-13": "ma7(b13)",
    "+7(-13)": "ma7(b13)",
    "maj7(b13)": "ma7(b13)",
    "ma7b13": "ma9(b13)",
    "ma7-13": "ma7(b13)",
    "ma7(-13)": "ma7(b13)",
    "ma7(b5)": "ma7(b5)",
    "maj7b5": "ma7(b5)",
    "maj7-5": "ma7(b5)",
    "maj7(-5)": "ma7(b5)",
    "+7(b5)": "ma7(b5)",
    "+7b5": "ma7(b5)",
    "M7-5": "ma7(b5)",
    "+7(-5)": "ma7(b5)",
    "maj7(b5)": "ma7(b5)",
    "ma7b5": "ma7(b5)",
    "ma7-5": "ma7(b5)",
    "ma7(-5)": "ma7(b5)",
    "ma7(b9)": "ma7(b9)",
    "maj7b9": "ma7(b9)",
    "maj7-9": "ma7(b9)",
    "maj7(-9)": "ma7(b9)",
    "+7(b9)": "ma7(b9)",
    "+7b9": "ma7(b9)",
    "M7-9": "ma7(b9)",
    "+7(-9)": "ma7(b9)",
    "maj7(b9)": "ma7(b9)",
    "ma7b9": "ma7(b9)",
    "ma7-9": "ma7(b9)",
    "ma7(-9)": "ma7(b9)",
    "ma7(no3)": "ma7(no3)",
    "9(#7)": "ma9",
    "+9": "ma9",
    "M9": "ma9",
    "ma9(#11)": "ma9(#11)",
    "maj9#11": "ma9(#11)",
    "maj9+11": "ma9(#11)",
    "maj9(+11)": "ma9(#11)",
    "+9(#11)": "ma9(#11)",
    "+9#11": "ma9(#11)",
    "M9+11": "ma9(#11)",
    "+9(+11)": "ma9(#11)",
    "maj9(#11)": "ma9(#11)",
    "ma9+11": "ma9(#11)",
    "ma9(+11)": "ma9(#11)",
    "ma9(#11#5)": "ma9(#11#5)",
    "maj9#11#5": "ma9(#11#5)",
    "maj9+11+5": "ma9(#11#5)",
    "maj9(+11+5)": "ma9(#11#5)",
    "+9(#11#5)": "ma9(#11#5)",
    "+9#11#5": "ma9(#11#5)",
    "M9+11+5": "ma9(#11#5)",
    "+9(+11+5)": "ma9(#11#5)",
    "maj9(#11#5)": "ma9(#11#5)",
    "ma9+11+5": "ma9(#11#5)",
    "ma9(+11+5)": "ma9(#11#5)",
    "ma9(#4)": "ma9(#4)",
    "ma9(#5)": "ma9(#5)",
    "maj9#5": "ma9(#5)",
    "maj9+5": "ma9(#5)",
    "maj9(+5)": "ma9(#5)",
    "+9(#5)": "ma9(#5)",
    "+9#5": "ma9(#5)",
    "M9+5": "ma9(#5)",
    "+9(+5)": "ma9(#5)",
    "maj9(#5)": "ma9(#5)",
    "ma9#5": "ma9(#5)",
    "ma9+5": "ma9(#5)",
    "ma9(+5)": "ma9(#5)",
    "ma9(13)": "ma9(13)",
    "ma9(b13)": "ma9(b13)",
    "maj9b13": "ma9(b13)",
    "maj9-13": "ma9(b13)",
    "maj9(-13)": "ma9(b13)",
    "+9(b13)": "ma9(b13)",
    "+9b13": "ma9(b13)",
    "M9-13": "ma9(b13)",
    "+9(-13)": "ma9(b13)",
    "maj9(b13)": "ma9(b13)",
    "ma9-13": "ma9(b13)",
    "ma9(-13)": "ma9(b13)",
    "ma9(b13#5)": "ma9(b13#5)",
    "maj9b13#5": "ma9(b13#5)",
    "maj9-13+5": "ma9(b13#5)",
    "maj9(-13+5)": "ma9(b13#5)",
    "+9(b13#5)": "ma9(b13#5)",
    "+9b13#5": "ma9(b13#5)",
    "M9-13+5": "ma9(b13#5)",
    "+9(-13+5)": "ma9(b13#5)",
    "maj9(b13#5)": "ma9(b13#5)",
    "ma7b13#5": "ma9(b13#5)",
    "ma9-13+5": "ma9(b13#5)",
    "ma9(-13+5)": "ma9(b13#5)",
    "ma9(b5)": "ma9(b5)",
    "maj9b5": "ma9(b5)",
    "maj9-5": "ma9(b5)",
    "maj9(-5)": "ma9(b5)",
    "+9(b5)": "ma9(b5)",
    "+9b5": "ma9(b5)",
    "M9-5": "ma9(b5)",
    "+9(-5)": "ma9(b5)",
    "maj9(b5)": "ma9(b5)",
    "ma9b5": "ma9(b5)",
    "ma9-5": "ma9(b5)",
    "ma9(-5)": "ma9(b5)",
    "sus": "sus",
    "sus4": "sus",
    "sus(no5)": "sus(no5)",
    "sus#42": "sus#42"
};
var $7ec1df4bbc0938c9$export$2e2bcd8739ae039 = $7ec1df4bbc0938c9$var$mapping;




function $5e3a0c5a6197f95b$var$normalizeChordSuffix(suffix) {
    if (suffix === null) return null;
    if ((0, $7ec1df4bbc0938c9$export$2e2bcd8739ae039)[suffix] === "[blank]") return null;
    return (0, $7ec1df4bbc0938c9$export$2e2bcd8739ae039)[suffix] || suffix;
}
/**
 * Represents a Chord, consisting of a root, suffix (quality) and bass
 */ class $5e3a0c5a6197f95b$var$Chord {
    /**
   * Tries to parse a chord string into a chord
   * Any leading or trailing whitespace is removed first, so a chord like `  \n  E/G# \r ` is valid.
   * @param chordString the chord string, eg `Esus4/G#` or `1sus4/#3`.
   * @returns {Chord|null}
   */ static parse(chordString) {
        try {
            return this.parseOrFail(chordString);
        } catch (_error) {
            return null;
        }
    }
    static parseOrFail(chordString) {
        const ast = (0, $7cb09a9be1aff7bc$export$98e6a39c04603d36)(chordString.trim());
        return new $5e3a0c5a6197f95b$var$Chord(ast);
    }
    /**
   * Returns a deep copy of the chord
   * @returns {Chord}
   */ clone() {
        return this.set({});
    }
    /**
   * Converts the chord to a chord symbol, using the supplied key as a reference.
   * For example, a numeric chord `#4` with reference key `E` will return the chord symbol `A#`.
   * When the chord is already a chord symbol, it will return a clone of the object.
   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a
   * numeric or numeral.
   * @returns {Chord} the chord symbol
   */ toChordSymbol(referenceKey = null) {
        if (this.isChordSymbol()) return this.clone();
        const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(referenceKey);
        let chordSymbolChord = new $5e3a0c5a6197f95b$var$Chord({
            suffix: this.suffix ? $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix) : null,
            root: this.root.toChordSymbol(keyObj),
            bass: this.bass?.toChordSymbol(keyObj) || null
        });
        if (this.root.isMinor()) chordSymbolChord = chordSymbolChord.makeMinor();
        chordSymbolChord = chordSymbolChord.normalize(referenceKey);
        return chordSymbolChord;
    }
    /**
   * Converts the chord to a chord symbol string, using the supplied key as a reference.
   * For example, a numeric chord `#4` with reference key `E` will return the chord symbol `A#`.
   * When the chord is already a chord symbol, it will return a string version of the chord.
   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a
   * numeric or numeral.
   * @returns {string} the chord symbol string
   * @see {toChordSymbol}
   */ toChordSymbolString(referenceKey = null) {
        return this.toChordSymbol(referenceKey).toString();
    }
    /**
   * Determines whether the chord is a chord symbol
   * @returns {boolean}
   */ isChordSymbol() {
        return this.is((0, $234747a9630b4642$export$27c95a7104c1f7aa));
    }
    /**
   * Converts the chord to a numeric chord, using the supplied key as a reference.
   * For example, a chord symbol A# with reference key E will return the numeric chord #4.
   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol
   * @returns {Chord} the numeric chord
   */ toNumeric(referenceKey = null) {
        if (this.isNumeric()) return this.clone();
        if (this.isNumeral()) return this.transform((key)=>key.toNumeric());
        const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(referenceKey);
        return new $5e3a0c5a6197f95b$var$Chord({
            suffix: $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix),
            root: this.root.toNumeric(keyObj),
            bass: this.bass?.toNumeric(keyObj) || null
        });
    }
    /**
   * Converts the chord to a numeral chord, using the supplied key as a reference.
   * For example, a chord symbol A# with reference key E will return the numeral chord #IV.
   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol
   * @returns {Chord} the numeral chord
   */ toNumeral(referenceKey = null) {
        if (this.isNumeral()) return this.clone();
        if (this.isNumeric()) return this.transform((key)=>key.toNumeral());
        const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(referenceKey);
        return new $5e3a0c5a6197f95b$var$Chord({
            suffix: $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix),
            root: keyObj ? this.root.toNumeral(keyObj) : null,
            bass: this.bass?.toNumeral(keyObj) || null
        });
    }
    /**
   * Converts the chord to a numeral chord string, using the supplied kye as a reference.
   * For example, a chord symbol A# with reference key E will return the numeral chord #4.
   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol
   * @returns {string} the numeral chord string
   * @see {toNumeral}
   */ toNumeralString(referenceKey = null) {
        return this.toNumeral(referenceKey).toString();
    }
    /**
   * Determines whether the chord is numeric
   * @returns {boolean}
   */ isNumeric() {
        return this.is((0, $234747a9630b4642$export$4d318981b5a83836));
    }
    /**
   * Converts the chord to a numeric chord string, using the supplied kye as a reference.
   * For example, a chord symbol A# with reference key E will return the numeric chord #4.
   * @param {Key|string|null} [referenceKey=null] the reference key. The key is required when converting a chord symbol
   * @returns {string} the numeric chord string
   * @see {toNumeric}
   */ toNumericString(referenceKey = null) {
        return this.toNumeric(referenceKey).toString();
    }
    /**
   * Determines whether the chord is a numeral
   * @returns {boolean}
   */ isNumeral() {
        return this.is((0, $234747a9630b4642$export$1321df9b16c30c6a));
    }
    /**
   * Converts the chord to a string, eg `Esus4/G#` or `1sus4/#3`
   * @param {Object} [configuration={}] options
   * @param {boolean} [configuration.useUnicodeModifier=false] Whether or not to use unicode modifiers.
   * This will make `#` (sharp) look like `♯` and `b` (flat) look like `♭`
   * @returns {string} the chord string
   */ toString({ useUnicodeModifier: useUnicodeModifier = false  } = {}) {
        const chordString = this.root.toString({
            showMinor: false,
            useUnicodeModifier: useUnicodeModifier
        }) + (this.suffix || "");
        if (this.bass) return `${chordString}/${this.bass.toString({
            useUnicodeModifier: useUnicodeModifier
        })}`;
        return chordString;
    }
    /**
   * Normalizes the chord root and bass notes:
   * - Fb becomes E
   * - Cb becomes B
   * - B# becomes C
   * - E# becomes F
   * - 4b becomes 3
   * - 1b becomes 7
   * - 7# becomes 1
   * - 3# becomes 4
   *
   * Besides that it normalizes the suffix if `normalizeSuffix` is `true`.
   * For example, `sus2` becomes `2`, `sus4` becomes `sus`.
   * All suffix normalizations can be found in `src/normalize_mappings/suffix-mapping.txt`.
   *
   * When the chord is minor, bass notes are normalized off of the relative major
   * of the root note. For example, `Em/A#` becomes `Em/Bb`.
   * @param {Key|string} [key=null] the key to normalize to
   * @param {Object} [options={}] options
   * @param {boolean} [options.normalizeSuffix=true] whether to normalize the chord suffix after transposing
   * @returns {Chord} the normalized chord
   */ normalize(key = null, { normalizeSuffix: normalizeSuffix = true  } = {}) {
        const suffix = normalizeSuffix ? $5e3a0c5a6197f95b$var$normalizeChordSuffix(this.suffix) : this.suffix;
        let bassRootKey = this.root.normalize().normalizeEnharmonics(key);
        if (this.root.isMinor() && this.bass) bassRootKey = this.root.transpose(3).removeMinor().normalize();
        return this.set({
            suffix: suffix,
            root: this.root.normalize().normalizeEnharmonics(key),
            bass: this.bass ? this.bass.normalize().normalizeEnharmonics(bassRootKey) : null
        });
    }
    /**
   * Switches to the specified modifier
   * @param newModifier the modifier to use: `'#'` or `'b'`
   * @returns {Chord} the new, changed chord
   */ useModifier(newModifier) {
        return this.transform((key)=>key.useModifier(newModifier));
    }
    /**
   * Transposes the chord up by 1 semitone. Eg. A becomes A#, Eb becomes E
   * @returns {Chord} the new, transposed chord
   */ transposeUp() {
        return this.transform((key)=>key.transposeUp());
    }
    /**
   * Transposes the chord down by 1 semitone. Eg. A# becomes A, E becomes Eb
   * @returns {Chord} the new, transposed chord
   */ transposeDown() {
        return this.transform((key)=>key.transposeDown());
    }
    /**
   * Transposes the chord by the specified number of semitones
   * @param delta de number of semitones
   * @returns {Chord} the new, transposed chord
   */ transpose(delta) {
        return this.transform((key)=>key.transpose(delta));
    }
    constructor({ base: base = null , modifier: modifier = null , suffix: suffix = null , bassBase: bassBase = null , bassModifier: bassModifier = null , root: root = null , bass: bass = null  }){
        this.suffix = suffix || null;
        this.root = this.determineRoot(root, base, modifier, suffix);
        this.bass = this.determineBass(bass, bassBase, bassModifier);
    }
    determineRoot(root, base, modifier, suffix) {
        if (root) return root;
        if (!base) throw new Error("Expected base");
        return new (0, $918eb2016ac61e41$export$2e2bcd8739ae039)({
            note: base,
            modifier: modifier,
            minor: (0, $974bd1d260bb1d53$export$51fabfbeed747719)(suffix)
        });
    }
    determineBass(bass, bassBase, bassModifier) {
        if (bass) return bass;
        if (bassBase) return new (0, $918eb2016ac61e41$export$2e2bcd8739ae039)({
            note: bassBase,
            modifier: bassModifier || null,
            minor: false
        });
        return null;
    }
    makeMinor() {
        if (!this.suffix || this.suffix[0] !== "m") return this.set({
            suffix: `m${this.suffix || ""}`
        });
        return this.clone();
    }
    set(properties) {
        return new $5e3a0c5a6197f95b$var$Chord({
            root: this.root.clone(),
            suffix: this.suffix,
            bass: this.bass?.clone() || null,
            ...properties
        });
    }
    is(type) {
        return this.root.is(type) && (!this.bass || this.bass.is(type));
    }
    transform(transformFunc) {
        return this.set({
            root: transformFunc(this.root),
            bass: this.bass ? transformFunc(this.bass) : null
        });
    }
}
function $5e3a0c5a6197f95b$export$621b8187b24d90c6(chordString) {
    (0, $974bd1d260bb1d53$export$b680e6b2c82f8c2f)("parseChord() is deprecated, please use Chord.parse() instead");
    return $5e3a0c5a6197f95b$var$Chord.parse(chordString);
}
var $5e3a0c5a6197f95b$export$2e2bcd8739ae039 = $5e3a0c5a6197f95b$var$Chord;


/**
 * Represents a chord with the corresponding (partial) lyrics
 */ class $f7a904d05353aafa$var$ChordLyricsPair {
    /**
   * Initialises a ChordLyricsPair
   * @param {string} chords The chords
   * @param {string} lyrics The lyrics
   */ constructor(chords = "", lyrics = null){
        /**
     * The chords
     * @member
     * @type {string}
     */ this.chords = chords || "";
        /**
     * The lyrics
     * @member
     * @type {string}
     */ this.lyrics = lyrics || "";
    }
    /**
   * Indicates whether a ChordLyricsPair should be visible in a formatted chord sheet (except for ChordPro sheets)
   * @returns {boolean}
   */ isRenderable() {
        return true;
    }
    /**
   * Returns a deep copy of the ChordLyricsPair, useful when programmatically transforming a song
   * @returns {ChordLyricsPair}
   */ clone() {
        return new $f7a904d05353aafa$var$ChordLyricsPair(this.chords, this.lyrics);
    }
    toString() {
        return `ChordLyricsPair(chords=${this.chords}, lyrics=${this.lyrics})`;
    }
    set({ chords: chords , lyrics: lyrics  }) {
        return new $f7a904d05353aafa$var$ChordLyricsPair(chords || this.chords, lyrics || this.lyrics);
    }
    setLyrics(lyrics) {
        return this.set({
            lyrics: lyrics
        });
    }
    transpose(delta, key = null, { normalizeChordSuffix: normalizeChordSuffix  } = {
        normalizeChordSuffix: false
    }) {
        const chordObj = (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039).parse(this.chords.trim());
        if (chordObj) {
            let transposedChord = chordObj.transpose(delta);
            if (key) transposedChord = transposedChord.normalize(key, {
                normalizeSuffix: normalizeChordSuffix
            });
            return this.set({
                chords: transposedChord.toString()
            });
        }
        return this.clone();
    }
}
var $f7a904d05353aafa$export$2e2bcd8739ae039 = $f7a904d05353aafa$var$ChordLyricsPair;



const $b40d86206d859ced$export$a014e67b549cbef4 = {
    separator: ","
};
class $b40d86206d859ced$var$MetadataConfiguration {
    constructor(metadataConfiguration = $b40d86206d859ced$export$a014e67b549cbef4){
        this.separator = metadataConfiguration.separator;
    }
}
var $b40d86206d859ced$export$2e2bcd8739ae039 = $b40d86206d859ced$var$MetadataConfiguration;



const $b83980a5d9482be8$export$78c0028a34264234 = {
    evaluate: false,
    metadata: {
        separator: ","
    },
    key: null,
    expandChorusDirective: false,
    useUnicodeModifiers: false,
    normalizeChords: true
};
class $b83980a5d9482be8$var$Configuration {
    constructor(configuration = $b83980a5d9482be8$export$78c0028a34264234){
        const mergedConfig = {
            ...$b83980a5d9482be8$export$78c0028a34264234,
            ...configuration
        };
        this.evaluate = !!mergedConfig.evaluate;
        this.expandChorusDirective = !!mergedConfig.expandChorusDirective;
        this.useUnicodeModifiers = !!mergedConfig.useUnicodeModifiers;
        this.normalizeChords = !!mergedConfig.normalizeChords;
        this.metadata = new (0, $b40d86206d859ced$export$2e2bcd8739ae039)(configuration.metadata);
        this.key = configuration.key ? (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(configuration.key) : null;
        this.configuration = configuration;
    }
    get(key) {
        return (0, $iPNDK$lodashget)(this, key);
    }
}
var $b83980a5d9482be8$export$2e2bcd8739ae039 = $b83980a5d9482be8$var$Configuration;


/**
 * Base class for all formatters, taking care of receiving a configuration wrapping that inside a Configuration object
 */ class $2dfa852662754780$var$Formatter {
    /**
     * Instantiate
     * @param {Object} [configuration={}] options
     * @param {boolean} [configuration.evaluate=false] Whether or not to evaluate meta expressions.
     * For more info about meta expressions, see: https://bit.ly/2SC9c2u
     * @param {object} [configuration.metadata={}]
     * @param {string} [configuration.metadata.separator=", "] The separator to be used when rendering a
     * metadata value that has multiple values. See: https://bit.ly/2SC9c2u
     * @param {Key|string} [configuration.key=null] The key to use for rendering. The chord sheet will be
     * transposed from the song's original key (as indicated by the `{key}` directive) to the specified key.
     * Note that transposing will only work if the original song key is set.
     * @param {boolean} [configuration.expandChorusDirective=false] Whether or not to expand `{chorus}` directives
     * by rendering the last defined chorus inline after the directive.
     * @param {boolean} [configuration.useUnicodeModifiers=false] Whether or not to use unicode flat and sharp
     * symbols.
     * @param {boolean} [configuration.normalizeChords=true] Whether or not to automatically normalize chords
     */ constructor(configuration = null){
        this.configuration = new (0, $b83980a5d9482be8$export$2e2bcd8739ae039)(configuration || {});
    }
}
var $2dfa852662754780$export$2e2bcd8739ae039 = $2dfa852662754780$var$Formatter;


/**
 * Album meta directive. See https://www.chordpro.org/chordpro/directives-album/
 * @type {string}
 */ class $33b2f875bada793c$var$AstComponent {
    line = null;
    column = null;
    offset = null;
    constructor(traceInfo = null){
        if (traceInfo) {
            this.line = traceInfo.line || null;
            this.column = traceInfo.column || null;
            this.offset = traceInfo.offset || null;
        }
    }
}
var $33b2f875bada793c$export$2e2bcd8739ae039 = $33b2f875bada793c$var$AstComponent;


const $b3836272a1374d85$export$10227cb086d1770c = "album";
const $b3836272a1374d85$export$17d8dfb3db842bf = "artist";
const $b3836272a1374d85$export$866f445d49bad88e = "capo";
const $b3836272a1374d85$export$a29989082612d0d9 = "comment";
const $b3836272a1374d85$export$98424633dc8c377f = "composer";
const $b3836272a1374d85$export$4ab8c75045d12480 = "copyright";
const $b3836272a1374d85$export$bacc88974c736870 = "duration";
const $b3836272a1374d85$export$1c874e9780385ecd = "end_of_bridge";
const $b3836272a1374d85$export$473c1a4819e5180b = "end_of_chorus";
const $b3836272a1374d85$export$66a0ef3ffeab32b7 = "end_of_tab";
const $b3836272a1374d85$export$640d294ab83f9040 = "end_of_verse";
const $b3836272a1374d85$export$7167c830cefcb6b5 = "key";
const $b3836272a1374d85$export$430b1920f5feeae = "_key";
const $b3836272a1374d85$export$a6901bd008617c61 = "lyricist";
const $b3836272a1374d85$export$3550cc87694d54e0 = "start_of_bridge";
const $b3836272a1374d85$export$4f5168acae064e01 = "start_of_chorus";
const $b3836272a1374d85$export$8dd1111100e0e88d = "start_of_tab";
const $b3836272a1374d85$export$deca399f8cd9b7dc = "start_of_verse";
const $b3836272a1374d85$export$5895c693c74b9cf4 = "subtitle";
const $b3836272a1374d85$export$bd8d57d0bc5a8478 = "tempo";
const $b3836272a1374d85$export$a9905336c0111a3a = "time";
const $b3836272a1374d85$export$f1e53f710478ceb4 = "title";
const $b3836272a1374d85$export$ae60ab9b4739fc3d = "transpose";
const $b3836272a1374d85$export$b7627374a6424f68 = "new_key";
const $b3836272a1374d85$export$90b88dc425a06a95 = "year";
const $b3836272a1374d85$export$2b0cbe6e95114098 = "chordfont";
const $b3836272a1374d85$export$1f62a95bf5703cac = "chordsize";
const $b3836272a1374d85$export$f7227d9f34d97bec = "chordcolour";
const $b3836272a1374d85$export$14fe4ba6e94df04d = "textfont";
const $b3836272a1374d85$export$f0dee7f48597f09a = "textsize";
const $b3836272a1374d85$export$d2ed2b49c006eb23 = "textcolour";
const $b3836272a1374d85$export$7e71e3df83ac1c9b = "titlefont";
const $b3836272a1374d85$export$6adbad8fc3f3d0e2 = "titlesize";
const $b3836272a1374d85$export$964db987ba9b8470 = "titlecolour";
const $b3836272a1374d85$export$8db6c706fc9142b2 = "chorus";
const $b3836272a1374d85$var$TITLE_SHORT = "t";
const $b3836272a1374d85$var$SUBTITLE_SHORT = "st";
const $b3836272a1374d85$var$COMMENT_SHORT = "c";
const $b3836272a1374d85$var$START_OF_CHORUS_SHORT = "soc";
const $b3836272a1374d85$var$END_OF_CHORUS_SHORT = "eoc";
const $b3836272a1374d85$var$START_OF_TAB_SHORT = "sot";
const $b3836272a1374d85$var$END_OF_TAB_SHORT = "eot";
const $b3836272a1374d85$var$NEW_KEY_SHORT = "nk";
const $b3836272a1374d85$var$CHORDFONT_SHORT = "cf";
const $b3836272a1374d85$var$CHORDSIZE_SHORT = "cs";
const $b3836272a1374d85$var$TEXTFONT_SHORT = "tf";
const $b3836272a1374d85$var$TEXTSIZE_SHORT = "ts";
const $b3836272a1374d85$var$RENDERABLE_TAGS = [
    $b3836272a1374d85$export$a29989082612d0d9
];
const $b3836272a1374d85$export$57ecf0dc09effb3 = [
    $b3836272a1374d85$export$10227cb086d1770c,
    $b3836272a1374d85$export$17d8dfb3db842bf,
    $b3836272a1374d85$export$866f445d49bad88e,
    $b3836272a1374d85$export$98424633dc8c377f,
    $b3836272a1374d85$export$4ab8c75045d12480,
    $b3836272a1374d85$export$bacc88974c736870,
    $b3836272a1374d85$export$7167c830cefcb6b5,
    $b3836272a1374d85$export$a6901bd008617c61,
    $b3836272a1374d85$export$bd8d57d0bc5a8478,
    $b3836272a1374d85$export$a9905336c0111a3a,
    $b3836272a1374d85$export$f1e53f710478ceb4,
    $b3836272a1374d85$export$5895c693c74b9cf4,
    $b3836272a1374d85$export$90b88dc425a06a95
];
const $b3836272a1374d85$export$75d737e15c3fab80 = [
    $b3836272a1374d85$export$430b1920f5feeae
];
const $b3836272a1374d85$var$SECTION_DELIMITERS = [
    $b3836272a1374d85$export$4f5168acae064e01,
    $b3836272a1374d85$export$473c1a4819e5180b,
    $b3836272a1374d85$export$8dd1111100e0e88d,
    $b3836272a1374d85$export$66a0ef3ffeab32b7,
    $b3836272a1374d85$export$deca399f8cd9b7dc,
    $b3836272a1374d85$export$640d294ab83f9040
];
const $b3836272a1374d85$var$INLINE_FONT_TAGS = [
    $b3836272a1374d85$export$2b0cbe6e95114098,
    $b3836272a1374d85$export$1f62a95bf5703cac,
    $b3836272a1374d85$export$f7227d9f34d97bec,
    $b3836272a1374d85$export$14fe4ba6e94df04d,
    $b3836272a1374d85$export$f0dee7f48597f09a,
    $b3836272a1374d85$export$d2ed2b49c006eb23
];
const $b3836272a1374d85$var$DIRECTIVES_WITH_RENDERABLE_LABEL = [
    $b3836272a1374d85$export$deca399f8cd9b7dc,
    $b3836272a1374d85$export$4f5168acae064e01,
    $b3836272a1374d85$export$3550cc87694d54e0,
    $b3836272a1374d85$export$8dd1111100e0e88d,
    $b3836272a1374d85$export$8db6c706fc9142b2
];
const $b3836272a1374d85$var$ALIASES = {
    [$b3836272a1374d85$var$TITLE_SHORT]: $b3836272a1374d85$export$f1e53f710478ceb4,
    [$b3836272a1374d85$var$SUBTITLE_SHORT]: $b3836272a1374d85$export$5895c693c74b9cf4,
    [$b3836272a1374d85$var$COMMENT_SHORT]: $b3836272a1374d85$export$a29989082612d0d9,
    [$b3836272a1374d85$var$START_OF_CHORUS_SHORT]: $b3836272a1374d85$export$4f5168acae064e01,
    [$b3836272a1374d85$var$END_OF_CHORUS_SHORT]: $b3836272a1374d85$export$473c1a4819e5180b,
    [$b3836272a1374d85$var$START_OF_TAB_SHORT]: $b3836272a1374d85$export$8dd1111100e0e88d,
    [$b3836272a1374d85$var$END_OF_TAB_SHORT]: $b3836272a1374d85$export$66a0ef3ffeab32b7,
    [$b3836272a1374d85$var$NEW_KEY_SHORT]: $b3836272a1374d85$export$b7627374a6424f68,
    [$b3836272a1374d85$var$CHORDFONT_SHORT]: $b3836272a1374d85$export$2b0cbe6e95114098,
    [$b3836272a1374d85$var$CHORDSIZE_SHORT]: $b3836272a1374d85$export$1f62a95bf5703cac,
    [$b3836272a1374d85$var$TEXTFONT_SHORT]: $b3836272a1374d85$export$14fe4ba6e94df04d,
    [$b3836272a1374d85$var$TEXTSIZE_SHORT]: $b3836272a1374d85$export$f0dee7f48597f09a
};
const $b3836272a1374d85$var$TAG_REGEX = /^([^:\s]+)(:?\s*(.+))?$/;
const $b3836272a1374d85$var$CUSTOM_META_TAG_NAME_REGEX = /^x_(.+)$/;
function $b3836272a1374d85$export$3ef04055cb4a269a(tagName) {
    return $b3836272a1374d85$export$75d737e15c3fab80.includes(tagName);
}
const $b3836272a1374d85$var$translateTagNameAlias = (name)=>{
    if (!name) return name;
    const sanitizedName = name.trim();
    if (sanitizedName in $b3836272a1374d85$var$ALIASES) return $b3836272a1374d85$var$ALIASES[sanitizedName];
    return sanitizedName;
};
/**
 * Represents a tag/directive. See https://www.chordpro.org/chordpro/chordpro-directives/
 */ class $b3836272a1374d85$var$Tag extends (0, $33b2f875bada793c$export$2e2bcd8739ae039) {
    _originalName = "";
    _name = "";
    _value = "";
    _isMetaTag = false;
    constructor(name, value = null, traceInfo = null){
        super(traceInfo);
        this.parseNameValue(name, value);
    }
    parseNameValue(name, value) {
        if (name === "meta") this.parseMetaTag(value);
        else {
            this.name = name;
            this.value = value || "";
        }
    }
    parseMetaTag(value) {
        if (!value) throw new Error("Expected value");
        const [metaName, metaValue] = value.split(/\s(.+)/);
        this.name = metaName;
        this.value = metaValue || "";
        this._isMetaTag = true;
    }
    static parse(tag) {
        if (tag instanceof $b3836272a1374d85$var$Tag) return tag;
        return this.parseWithRegex(tag, $b3836272a1374d85$var$TAG_REGEX);
    }
    static parseWithRegex(tag, regex) {
        const matches = tag.match(regex);
        if (matches !== null) return new $b3836272a1374d85$var$Tag(matches[1], matches[3] || null);
        return null;
    }
    static parseOrFail(tag) {
        const parsed = this.parse(tag);
        if (!parsed) throw new Error(`Failed to parse ${tag}`);
        return parsed;
    }
    isSectionDelimiter() {
        return $b3836272a1374d85$var$SECTION_DELIMITERS.includes(this.name);
    }
    isInlineFontTag() {
        return $b3836272a1374d85$var$INLINE_FONT_TAGS.includes(this.name);
    }
    set name(name) {
        this._name = $b3836272a1374d85$var$translateTagNameAlias(name);
        this._originalName = name;
    }
    /**
   * The tag full name. When the original tag used the short name, `name` will return the full name.
   * @member
   * @type {string}
   */ get name() {
        return this._name.trim();
    }
    /**
   * The original tag name that was used to construct the tag.
   * @member
   * @type {string}
   */ get originalName() {
        return this._originalName.trim();
    }
    set value(value) {
        this._value = value || "";
    }
    /**
   * The tag value
   * @member
   * @type {string}
   */ get value() {
        return `${this._value}`.trim();
    }
    /**
   * Checks whether the tag value is a non-empty string.
   * @returns {boolean}
   */ hasValue() {
        return this.value.length > 0;
    }
    /**
   * Checks whether the tag is usually rendered inline. It currently only applies to comment tags.
   * @returns {boolean}
   */ isRenderable() {
        return $b3836272a1374d85$var$RENDERABLE_TAGS.includes(this.name) || this.hasRenderableLabel();
    }
    /**
   * Check whether this tag's label (if any) should be rendered, as applicable to tags like
   * `start_of_verse` and `start_of_chorus`.
   * See https://chordpro.org/chordpro/directives-env_chorus/, https://chordpro.org/chordpro/directives-env_verse/,
   * https://chordpro.org/chordpro/directives-env_bridge/, https://chordpro.org/chordpro/directives-env_tab/
   */ hasRenderableLabel() {
        return $b3836272a1374d85$var$DIRECTIVES_WITH_RENDERABLE_LABEL.includes(this.name) && this.hasValue();
    }
    /**
   * Checks whether the tag is either a standard meta tag or a custom meta directive (`{x_some_name}`)
   * @returns {boolean}
   */ isMetaTag() {
        return this._isMetaTag || $b3836272a1374d85$var$CUSTOM_META_TAG_NAME_REGEX.test(this.name) || $b3836272a1374d85$export$57ecf0dc09effb3.indexOf(this.name) !== -1;
    }
    /**
   * Returns a clone of the tag.
   * @returns {Tag} The cloned tag
   */ clone() {
        return new $b3836272a1374d85$var$Tag(this._originalName, this.value);
    }
    toString() {
        return `Tag(name=${this.name}, value=${this.value})`;
    }
    set({ value: value  }) {
        return new $b3836272a1374d85$var$Tag(this._originalName, value);
    }
}
var $b3836272a1374d85$export$2e2bcd8739ae039 = $b3836272a1374d85$var$Tag;



class $3fb187494df71568$var$EvaluationError extends Error {
    line = null;
    column = null;
    offset = null;
    constructor(message, line = null, column = null, offset = null){
        super(`${message} on line ${line} column ${column}`);
        this.name = "ExpressionError";
        this.line = line;
        this.column = column;
        this.offset = offset;
    }
}
var $3fb187494df71568$export$2e2bcd8739ae039 = $3fb187494df71568$var$EvaluationError;




class $b5c6143e2fff9a4c$var$Evaluatable extends (0, $33b2f875bada793c$export$2e2bcd8739ae039) {
}
var $b5c6143e2fff9a4c$export$2e2bcd8739ae039 = $b5c6143e2fff9a4c$var$Evaluatable;


class $ba84a02c63f26e83$var$Composite extends (0, $b5c6143e2fff9a4c$export$2e2bcd8739ae039) {
    expressions = [];
    constructor(expressions, variable = null){
        super();
        this.expressions = expressions;
        this.variable = variable;
    }
    evaluate(metadata, metadataSeparator) {
        return this.expressions.map((expression)=>expression.evaluate(metadata, metadataSeparator, this.variable)).join("");
    }
    isRenderable() {
        return true;
    }
    clone() {
        return new $ba84a02c63f26e83$var$Composite(this.expressions.map((expression)=>expression.clone()), this.variable);
    }
}
var $ba84a02c63f26e83$export$2e2bcd8739ae039 = $ba84a02c63f26e83$var$Composite;



class $d6f43bad3b61b86a$var$Ternary extends (0, $b5c6143e2fff9a4c$export$2e2bcd8739ae039) {
    trueExpression = [];
    falseExpression = [];
    constructor({ variable: variable = null , valueTest: valueTest = null , trueExpression: trueExpression = [] , falseExpression: falseExpression = [] , line: line = null , column: column = null , offset: offset = null  }){
        super({
            line: line,
            column: column,
            offset: offset
        });
        this.variable = variable || null;
        this.valueTest = valueTest || null;
        this.trueExpression = trueExpression;
        this.falseExpression = falseExpression;
    }
    /**
   * Evaluate the meta expression
   * @param {Metadata} metadata The metadata object to use for evaluating the expression
   * @param {string} [metadataSeparator=null] The metadata separator to use if necessary
   * @returns {string} The evaluated expression
   */ evaluate(metadata, metadataSeparator, upperContext = null) {
        if (this.variable) return this.evaluateWithVariable(metadata, metadataSeparator);
        if (!upperContext) throw new (0, $3fb187494df71568$export$2e2bcd8739ae039)("Unexpected empty expression", this.line, this.column, this.offset);
        return this.evaluateToString(metadata.get(upperContext) || "", metadataSeparator);
    }
    evaluateToString(value, metadataSeparator) {
        if (Array.isArray(value)) return value.join(metadataSeparator);
        return value;
    }
    evaluateWithVariable(metadata, metadataSeparator) {
        if (!this.variable) throw new Error("Expected this.variable to be present");
        const value = metadata.get(this.variable);
        if (value && ((0, $974bd1d260bb1d53$export$78d1711480f95c3e)(this.valueTest) || value === this.valueTest)) return this.evaluateForTruthyValue(metadata, metadataSeparator, value);
        if (this.falseExpression.length) return new (0, $ba84a02c63f26e83$export$2e2bcd8739ae039)(this.falseExpression, this.variable).evaluate(metadata, metadataSeparator);
        return "";
    }
    evaluateForTruthyValue(metadata, metadataSeparator, value) {
        if (this.trueExpression.length) return new (0, $ba84a02c63f26e83$export$2e2bcd8739ae039)(this.trueExpression, this.variable).evaluate(metadata, metadataSeparator);
        return this.evaluateToString(value, metadataSeparator);
    }
    isRenderable() {
        return true;
    }
    clone() {
        return new $d6f43bad3b61b86a$var$Ternary({
            variable: this.variable,
            valueTest: this.valueTest,
            trueExpression: this.trueExpression.map((part)=>part.clone()),
            falseExpression: this.falseExpression.map((part)=>part.clone()),
            line: this.line,
            column: this.column,
            offset: this.offset
        });
    }
}
var $d6f43bad3b61b86a$export$2e2bcd8739ae039 = $d6f43bad3b61b86a$var$Ternary;



class $758385c5b662d76d$var$Literal extends (0, $b5c6143e2fff9a4c$export$2e2bcd8739ae039) {
    constructor(expression){
        super();
        this.string = expression;
    }
    evaluate() {
        return this.string;
    }
    isRenderable() {
        return true;
    }
    clone() {
        return new $758385c5b662d76d$var$Literal(this.string);
    }
}
var $758385c5b662d76d$export$2e2bcd8739ae039 = $758385c5b662d76d$var$Literal;


const $feb758e68dd351a4$var$NEW_LINE = "\n";
/**
 * Formats a song into a ChordPro chord sheet
 */ class $feb758e68dd351a4$var$ChordProFormatter extends (0, $2dfa852662754780$export$2e2bcd8739ae039) {
    /**
   * Formats a song into a ChordPro chord sheet.
   * @param {Song} song The song to be formatted
   * @returns {string} The ChordPro string
   */ format(song) {
        const { lines: lines , metadata: metadata  } = song;
        return lines.map((line)=>this.formatLine(line, metadata)).join($feb758e68dd351a4$var$NEW_LINE);
    }
    formatLine(line, metadata) {
        return line.items.map((item)=>this.formatItem(item, metadata)).join("");
    }
    formatItem(item, metadata) {
        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) return this.formatTag(item);
        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return this.formatChordLyricsPair(item);
        if ("evaluate" in item) return this.formatOrEvaluateItem(item, metadata);
        throw new Error(`Don't know how to format a ${item.constructor.name}`);
    }
    formatOrEvaluateItem(item, metadata) {
        if (this.configuration.evaluate) return item.evaluate(metadata, this.configuration.get("metadata.separator"));
        if (item instanceof (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)) return this.formatTernary(item);
        if (item instanceof (0, $758385c5b662d76d$export$2e2bcd8739ae039)) return item.evaluate();
        throw new Error(`Don't know how to format a ${item.constructor.name}`);
    }
    formatTernary(ternary) {
        const { variable: variable , valueTest: valueTest , trueExpression: trueExpression , falseExpression: falseExpression  } = ternary;
        return [
            "%{",
            variable || "",
            this.formatValueTest(valueTest),
            this.formatExpressionRange(trueExpression),
            this.formatExpressionRange(falseExpression),
            "}"
        ].join("");
    }
    formatValueTest(valueTest) {
        if (!valueTest) return "";
        return `=${valueTest}`;
    }
    formatExpressionRange(expressionRange) {
        if (!expressionRange.length) return "";
        return `|${expressionRange.map((expression)=>this.formatExpression(expression)).join("")}`;
    }
    formatExpression(expression) {
        if (expression instanceof (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)) return this.formatTernary(expression);
        if (expression instanceof (0, $758385c5b662d76d$export$2e2bcd8739ae039)) return expression.string;
        return "";
    }
    formatTag(tag) {
        if (tag.hasValue()) return `{${tag.originalName}: ${tag.value}}`;
        return `{${tag.originalName}}`;
    }
    formatChordLyricsPair(chordLyricsPair) {
        return [
            this.formatChordLyricsPairChords(chordLyricsPair),
            this.formatChordLyricsPairLyrics(chordLyricsPair)
        ].join("");
    }
    formatChordLyricsPairChords(chordLyricsPair) {
        if (chordLyricsPair.chords) return `[${chordLyricsPair.chords}]`;
        return "";
    }
    formatChordLyricsPairLyrics(chordLyricsPair) {
        return chordLyricsPair.lyrics || "";
    }
}
var $feb758e68dd351a4$export$2e2bcd8739ae039 = $feb758e68dd351a4$var$ChordProFormatter;


// eslint-disable-next-line import/no-cycle




/**
 * Represents a comment. See https://www.chordpro.org/chordpro/chordpro-file-format-specification/#overview
 */ class $df4ad73a744c94b3$var$Comment {
    constructor(content){
        this.content = content;
    }
    /**
   * Indicates whether a Comment should be visible in a formatted chord sheet (except for ChordPro sheets)
   * @returns {boolean}
   */ isRenderable() {
        return false;
    }
    /**
   * Returns a deep copy of the Comment, useful when programmatically transforming a song
   * @returns {Comment}
   */ clone() {
        return new $df4ad73a744c94b3$var$Comment(this.content);
    }
    toString() {
        return `Comment(content=${this.content})`;
    }
}
var $df4ad73a744c94b3$export$2e2bcd8739ae039 = $df4ad73a744c94b3$var$Comment;



class $6cf55d420652e2b7$var$Font {
    /**
   * The font
   * @member {string | null}
   */ font = null;
    /**
   * The font size, expressed in either pixels or percentage.
   * @member {FontSize | null}
   */ size = null;
    /**
   * The font color
   * @member {string | null}
   */ colour = null;
    constructor({ font: font , size: size , colour: colour  } = {
        font: null,
        size: null,
        colour: null
    }){
        this.font = font ? font.replace(/"/g, "'") : null;
        this.size = size || null;
        this.colour = colour || null;
    }
    clone() {
        return new $6cf55d420652e2b7$var$Font({
            font: this.font,
            size: this.size,
            colour: this.colour
        });
    }
    /**
   * Converts the font, size and color to a CSS string.
   * If possible, font and size are combined to the `font` shorthand.
   * If `font` contains double quotes (`"`) those will be converted to single quotes (`'`).
   *
   * @example
   * // Returns "font-family: 'Times New Roman'"
   * new Font({ font: '"Times New Roman"' }).toCssString()
   * @example
   * // Returns "color: red; font-family: Verdana"
   * new Font({ font: 'Verdana', colour: 'red' }).toCssString()
   * @example
   * // Returns "font: 30px Verdana"
   * new Font({ font: 'Verdana', size: '30' }).toCssString()
   * @example
   * // Returns "color: blue; font: 30% Verdana"
   * new Font({ font: 'Verdana', size: '30%', colour: 'blue' }).toCssString()
   *
   * @return {string} The CSS string
   */ toCssString() {
        const properties = {};
        if (this.colour) properties.color = this.colour;
        if (this.font && this.size) properties.font = `${this.size} ${this.font}`;
        else if (this.font) properties["font-family"] = this.font;
        else if (this.size) properties["font-size"] = `${this.size}`;
        return Object.keys(properties).map((key)=>`${key}: ${properties[key]}`).join("; ");
    }
}
var $6cf55d420652e2b7$export$2e2bcd8739ae039 = $6cf55d420652e2b7$var$Font;


/**
 * Represents a line in a chord sheet, consisting of items of type ChordLyricsPair or Tag
 */ class $06eb272065540fc1$var$Line {
    /**
   * The items ({@link ChordLyricsPair} or {@link Tag} or {@link Comment}) of which the line consists
   * @type {Array.<(ChordLyricsPair|Tag|Comment)>}
   */ items = [];
    /**
   * The line type, This is set by the ChordProParser when it read tags like {start_of_chorus} or {start_of_verse}
   * Values can be {@link VERSE}, {@link CHORUS} or {@link NONE}
   * @type {string}
   */ type = (0, $234747a9630b4642$export$c53d0f541b41b88e);
    currentChordLyricsPair = new (0, $f7a904d05353aafa$export$2e2bcd8739ae039)();
    key = null;
    transposeKey = null;
    lineNumber = null;
    /**
   * The text font that applies to this line. Is derived from the directives:
   * `textfont`, `textsize` and `textcolour`
   * See: https://www.chordpro.org/chordpro/directives-props_text_legacy/
   * @type {Font}
   */ textFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();
    /**
   * The chord font that applies to this line. Is derived from the directives:
   * `chordfont`, `chordsize` and `chordcolour`
   * See: https://www.chordpro.org/chordpro/directives-props_chord_legacy/
   * @type {Font}
   */ chordFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();
    constructor({ type: type , items: items  } = {
        type: (0, $234747a9630b4642$export$c53d0f541b41b88e),
        items: []
    }){
        this.type = type;
        this.items = items;
    }
    /**
   * Indicates whether the line contains any items
   * @returns {boolean}
   */ isEmpty() {
        return this.items.length === 0;
    }
    isNotEmpty() {
        return !this.isEmpty();
    }
    /**
   * Adds an item ({@link ChordLyricsPair} or {@link Tag}) to the line
   * @param {ChordLyricsPair|Tag} item The item to be added
   */ addItem(item) {
        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) this.addTag(item);
        else if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) this.addChordLyricsPair(item);
        else if (item instanceof (0, $df4ad73a744c94b3$export$2e2bcd8739ae039)) this.addComment(item);
        else this.items.push(item);
    }
    /**
   * Indicates whether the line contains items that are renderable
   * @returns {boolean}
   */ hasRenderableItems() {
        return this.items.some((item)=>item.isRenderable());
    }
    /**
   * Returns a deep copy of the line and all of its items
   * @returns {Line}
   */ clone() {
        return this.mapItems(null);
    }
    mapItems(func) {
        const clonedLine = new $06eb272065540fc1$var$Line();
        clonedLine.items = this.items.map((item)=>{
            const clonedItem = item.clone();
            return func ? func(clonedItem) : clonedItem;
        }).filter((item)=>item !== null);
        clonedLine.type = this.type;
        return clonedLine;
    }
    /**
   * Indicates whether the line type is {@link VERSE}
   * @returns {boolean}
   */ isVerse() {
        return this.type === (0, $234747a9630b4642$export$4b194284baed1659);
    }
    /**
   * Indicates whether the line type is {@link CHORUS}
   * @returns {boolean}
   */ isChorus() {
        return this.type === (0, $234747a9630b4642$export$8db6c706fc9142b2);
    }
    /**
   * Indicates whether the line contains items that are renderable. Please use {@link hasRenderableItems}
   * @deprecated
   * @returns {boolean}
   */ hasContent() {
        return this.hasRenderableItems();
    }
    addChordLyricsPair(chords = null, lyrics = null) {
        if (chords instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) this.currentChordLyricsPair = chords;
        else this.currentChordLyricsPair = new (0, $f7a904d05353aafa$export$2e2bcd8739ae039)(chords || "", lyrics || "");
        this.items.push(this.currentChordLyricsPair);
        return this.currentChordLyricsPair;
    }
    ensureChordLyricsPair() {
        if (!this.currentChordLyricsPair) this.addChordLyricsPair();
    }
    chords(chr) {
        this.ensureChordLyricsPair();
        this.currentChordLyricsPair.chords += chr;
    }
    lyrics(chr) {
        this.ensureChordLyricsPair();
        this.currentChordLyricsPair.lyrics += chr;
    }
    addTag(nameOrTag, value = null) {
        const tag = nameOrTag instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) ? nameOrTag : new (0, $b3836272a1374d85$export$2e2bcd8739ae039)(nameOrTag, value);
        this.items.push(tag);
        return tag;
    }
    addComment(content) {
        const comment = content instanceof (0, $df4ad73a744c94b3$export$2e2bcd8739ae039) ? content : new (0, $df4ad73a744c94b3$export$2e2bcd8739ae039)(content);
        this.items.push(comment);
        return comment;
    }
    set(properties) {
        return new $06eb272065540fc1$var$Line({
            type: this.type,
            items: this.items,
            ...properties
        });
    }
}
var $06eb272065540fc1$export$2e2bcd8739ae039 = $06eb272065540fc1$var$Line;



/**
 * Represents a paragraph of lines in a chord sheet
 */ class $55861b6d10167265$var$Paragraph {
    /**
   * The {@link Line} items of which the paragraph consists
   * @member
   * @type {Line[]}
   */ lines = [];
    addLine(line) {
        this.lines.push(line);
    }
    /**
   * Tries to determine the common type for all lines. If the types for all lines are equal, it returns that type.
   * If not, it returns {@link INDETERMINATE}
   * @returns {string}
   */ get type() {
        const types = this.lines.map((line)=>line.type);
        const uniqueTypes = [
            ...new Set(types)
        ];
        if (uniqueTypes.length === 1) return uniqueTypes[0];
        return 0, $234747a9630b4642$export$c5a6fe907430212e;
    }
    /**
   * Indicates whether the paragraph contains lines with renderable items.
   * @see {@link Line.hasRenderableItems}
   * @returns {boolean}
   */ hasRenderableItems() {
        return this.lines.some((line)=>line.hasRenderableItems());
    }
}
var $55861b6d10167265$export$2e2bcd8739ae039 = $55861b6d10167265$var$Paragraph;







class $328bfb8696ee6244$var$MetadataAccessors {
    get key() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$7167c830cefcb6b5));
    }
    get title() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$f1e53f710478ceb4));
    }
    get subtitle() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$5895c693c74b9cf4));
    }
    get capo() {
        return this.getMetadata((0, $b3836272a1374d85$export$866f445d49bad88e));
    }
    get duration() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$bacc88974c736870));
    }
    get tempo() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$bd8d57d0bc5a8478));
    }
    get time() {
        return this.getMetadata((0, $b3836272a1374d85$export$a9905336c0111a3a));
    }
    get year() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$90b88dc425a06a95));
    }
    get album() {
        return this.getMetadata((0, $b3836272a1374d85$export$10227cb086d1770c));
    }
    get copyright() {
        return this.getSingleMetadata((0, $b3836272a1374d85$export$4ab8c75045d12480));
    }
    get lyricist() {
        return this.getMetadata((0, $b3836272a1374d85$export$a6901bd008617c61));
    }
    get artist() {
        return this.getMetadata((0, $b3836272a1374d85$export$17d8dfb3db842bf));
    }
    get composer() {
        return this.getMetadata((0, $b3836272a1374d85$export$98424633dc8c377f));
    }
}
var $328bfb8696ee6244$export$2e2bcd8739ae039 = $328bfb8696ee6244$var$MetadataAccessors;



function $fdb42fd3b59812d4$var$appendValue(array, value) {
    if (!array.includes(value)) array.push(value);
}
/**
 * Stores song metadata. Properties can be accessed using the get() method:
 *
 * const metadata = new Metadata({ author: 'John' });
 * metadata.get('author')   // => 'John'
 *
 * See {@link Metadata#get}
 */ class $fdb42fd3b59812d4$var$Metadata extends (0, $328bfb8696ee6244$export$2e2bcd8739ae039) {
    metadata = {};
    constructor(metadata = {}){
        super();
        if (metadata) this.assign(metadata);
    }
    merge(metadata) {
        const clone = this.clone();
        clone.assign(metadata);
        return clone;
    }
    contains(key) {
        return key in this.metadata;
    }
    add(key, value) {
        if ((0, $b3836272a1374d85$export$3ef04055cb4a269a)(key)) return;
        if (!(key in this.metadata)) {
            this.metadata[key] = value;
            return;
        }
        const currentValue = this.metadata[key];
        if (currentValue === value) return;
        if (currentValue instanceof Array) {
            $fdb42fd3b59812d4$var$appendValue(currentValue, value);
            return;
        }
        this.metadata[key] = [
            currentValue,
            value
        ];
    }
    set(key, value) {
        if (value) this.metadata[key] = value;
        else delete this.metadata[key];
    }
    getMetadata(name) {
        return this.get(name);
    }
    getSingleMetadata(name) {
        return this.getSingle(name);
    }
    /**
   * Reads a metadata value by key. This method supports simple value lookup, as well as fetching single array values.
   *
   * This method deprecates direct property access, eg: metadata['author']
   *
   * Examples:
   *
   * const metadata = new Metadata({ lyricist: 'Pete', author: ['John', 'Mary'] });
   * metadata.get('lyricist') // => 'Pete'
   * metadata.get('author')   // => ['John', 'Mary']
   * metadata.get('author.1') // => 'John'
   * metadata.get('author.2') // => 'Mary'
   *
   * Using a negative index will start counting at the end of the list:
   *
   * const metadata = new Metadata({ lyricist: 'Pete', author: ['John', 'Mary'] });
   * metadata.get('author.-1') // => 'Mary'
   * metadata.get('author.-2') // => 'John'
   *
   * @param prop the property name
   * @returns {Array<String>|String} the metadata value(s). If there is only one value, it will return a String,
   * else it returns an array of strings.
   */ get(prop) {
        if (prop === (0, $b3836272a1374d85$export$430b1920f5feeae)) return this.calculateKeyFromCapo();
        if (prop in this.metadata) return this.metadata[prop];
        return this.getArrayItem(prop);
    }
    /**
   * Returns a single metadata value. If the actual value is an array, it returns the first value. Else, it returns
   * the value.
   * @ignore
   * @param {string} prop the property name
   * @returns {String} The metadata value
   */ getSingle(prop) {
        const value = this.get(prop);
        if (Array.isArray(value)) return value[0];
        return value;
    }
    parseArrayKey(prop) {
        const match = prop.match(/(.+)\.(-?\d+)$/);
        if (!match) return null;
        const key = match[1];
        const index = parseInt(match[2], 10);
        return [
            key,
            index
        ];
    }
    getArrayItem(prop) {
        const parsedKey = this.parseArrayKey(prop);
        if (parsedKey === null) return undefined;
        const [key, index] = parsedKey;
        const arrayValue = this.metadata[key] || [];
        let itemIndex = index;
        if (itemIndex < 0) itemIndex = arrayValue.length + itemIndex;
        else if (itemIndex > 0) itemIndex -= 1;
        return arrayValue[itemIndex];
    }
    /**
   * Returns a deep clone of this Metadata object
   * @returns {Metadata} the cloned Metadata object
   */ clone() {
        return new $fdb42fd3b59812d4$var$Metadata(this.metadata);
    }
    calculateKeyFromCapo() {
        const capo = this.getSingle((0, $b3836272a1374d85$export$866f445d49bad88e));
        const key = this.getSingle((0, $b3836272a1374d85$export$7167c830cefcb6b5));
        if (capo && key) {
            const chord = (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039).parse(key);
            if (!chord) throw new Error(`Could not parse ${key}`);
            return chord.transpose(parseInt(capo, 10)).toString();
        }
        return undefined;
    }
    assign(metadata) {
        Object.keys(metadata).filter((key)=>!(0, $b3836272a1374d85$export$3ef04055cb4a269a)(key)).forEach((key)=>{
            const value = metadata[key];
            if (value instanceof Array) this.metadata[key] = [
                ...value
            ];
            else this.metadata[key] = value;
        });
    }
}
var $fdb42fd3b59812d4$export$2e2bcd8739ae039 = $fdb42fd3b59812d4$var$Metadata;


/**
 * Represents a parser warning, currently only used by ChordProParser.
 */ class $8a1166616d2a7987$var$ParserWarning {
    /**
   * The chord sheet line number on which the warning occurred
   * @member
   * @type {number}
   */ lineNumber = null;
    /**
   * The chord sheet column on which the warning occurred
   * @member
   * @type {number}
   */ column = null;
    /**
   * @hideconstructor
   */ constructor(message, lineNumber, column){
        this.message = message;
        this.lineNumber = lineNumber;
        this.column = column;
    }
    /**
   * Returns a stringified version of the warning
   * @returns {string} The string warning
   */ toString() {
        return `Warning: ${this.message} on line ${this.lineNumber || "?"} column ${this.column || "?"}`;
    }
}
var $8a1166616d2a7987$export$2e2bcd8739ae039 = $8a1166616d2a7987$var$ParserWarning;




class $b039d61fa8aab1e4$var$FontSize {
    constructor(fontSize, kind){
        this.fontSize = fontSize;
        this.unit = kind;
    }
    clone() {
        return new $b039d61fa8aab1e4$var$FontSize(this.fontSize, this.unit);
    }
    multiply(percentage) {
        return new $b039d61fa8aab1e4$var$FontSize(this.fontSize * percentage / 100, this.unit);
    }
    /**
   * Stringifies the font size by concatenating size and unit
   *
   * @example
   * // Returns "30px"
   * new FontSize(30, 'px').toString()
   * @example
   * // Returns "120%"
   * new FontSize(120, '%').toString()
   *
   * @return {string} The font size
   */ toString() {
        return `${this.fontSize}${this.unit}`;
    }
    static parse(fontSize, parent) {
        const trimmed = fontSize.trim();
        const parsedFontSize = parseFloat(trimmed);
        if (Number.isNaN(parsedFontSize)) return this.parseNotANumber(parent);
        if (trimmed.slice(-1) === "%") return this.parsePercentage(parsedFontSize, parent);
        return new $b039d61fa8aab1e4$var$FontSize(parsedFontSize, "px");
    }
    static parseNotANumber(parent) {
        if (parent) return parent.clone();
        return new $b039d61fa8aab1e4$var$FontSize(100, "%");
    }
    static parsePercentage(parsedFontSize, parent) {
        if (parent) return parent.multiply(parsedFontSize);
        return new $b039d61fa8aab1e4$var$FontSize(parsedFontSize, "%");
    }
}
var $b039d61fa8aab1e4$export$2e2bcd8739ae039 = $b039d61fa8aab1e4$var$FontSize;



class $4ddcb30f99cdcc6a$var$FontStack {
    fontAndColourStacks = {
        [(0, $b3836272a1374d85$export$f7227d9f34d97bec)]: [],
        [(0, $b3836272a1374d85$export$2b0cbe6e95114098)]: [],
        [(0, $b3836272a1374d85$export$d2ed2b49c006eb23)]: [],
        [(0, $b3836272a1374d85$export$14fe4ba6e94df04d)]: []
    };
    sizeStacks = {
        [(0, $b3836272a1374d85$export$1f62a95bf5703cac)]: [],
        [(0, $b3836272a1374d85$export$f0dee7f48597f09a)]: []
    };
    textFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();
    chordFont = new (0, $6cf55d420652e2b7$export$2e2bcd8739ae039)();
    applyTag(tag) {
        switch(tag.name){
            case 0, $b3836272a1374d85$export$14fe4ba6e94df04d:
                this.textFont.font = this.pushOrPopTag(tag);
                break;
            case 0, $b3836272a1374d85$export$f0dee7f48597f09a:
                this.textFont.size = this.pushOrPopSizeTag(tag);
                break;
            case 0, $b3836272a1374d85$export$d2ed2b49c006eb23:
                this.textFont.colour = this.pushOrPopTag(tag);
                break;
            case 0, $b3836272a1374d85$export$2b0cbe6e95114098:
                this.chordFont.font = this.pushOrPopTag(tag);
                break;
            case 0, $b3836272a1374d85$export$1f62a95bf5703cac:
                this.chordFont.size = this.pushOrPopSizeTag(tag);
                break;
            case 0, $b3836272a1374d85$export$f7227d9f34d97bec:
                this.chordFont.colour = this.pushOrPopTag(tag);
                break;
            default:
                break;
        }
    }
    pushOrPopTag(tag) {
        let { value: value  } = tag;
        if (tag.hasValue()) this.fontAndColourStacks[tag.name].push(value);
        else {
            this.fontAndColourStacks[tag.name].pop();
            value = this.fontAndColourStacks[tag.name].slice(-1)[0] || null;
        }
        return value;
    }
    pushOrPopSizeTag(tag) {
        const { value: value  } = tag;
        if (tag.hasValue()) {
            const parent = this.sizeStacks[tag.name].slice(-1)[0] || null;
            const parsedFontSize = (0, $b039d61fa8aab1e4$export$2e2bcd8739ae039).parse(value, parent);
            this.sizeStacks[tag.name].push(parsedFontSize);
            return parsedFontSize;
        }
        this.sizeStacks[tag.name].pop();
        return this.sizeStacks[tag.name].slice(-1)[0] || null;
    }
}
var $4ddcb30f99cdcc6a$export$2e2bcd8739ae039 = $4ddcb30f99cdcc6a$var$FontStack;




/**
 * Represents a song in a chord sheet. Currently a chord sheet can only have one song.
 */ class $7860c26c4d50915f$var$Song extends (0, $328bfb8696ee6244$export$2e2bcd8739ae039) {
    /**
   * The {@link Line} items of which the song consists
   * @member {Line[]}
   */ lines = [];
    currentLine = null;
    warnings = [];
    sectionType = (0, $234747a9630b4642$export$c53d0f541b41b88e);
    fontStack = new (0, $4ddcb30f99cdcc6a$export$2e2bcd8739ae039)();
    currentKey = null;
    transposeKey = null;
    _bodyParagraphs = null;
    _bodyLines = null;
    /**
   * Creates a new {Song} instance
   * @param metadata {Object|Metadata} predefined metadata
   */ constructor(metadata = {}){
        super();
        this.metadata = new (0, $fdb42fd3b59812d4$export$2e2bcd8739ae039)(metadata);
    }
    get previousLine() {
        const count = this.lines.length;
        if (count >= 2) return this.lines[count - 2];
        return null;
    }
    /**
   * Returns the song lines, skipping the leading empty lines (empty as in not rendering any content). This is useful
   * if you want to skip the "header lines": the lines that only contain meta data.
   * @returns {Line[]} The song body lines
   */ get bodyLines() {
        if (!this._bodyLines) this._bodyLines = this.selectRenderableItems(this.lines);
        return this._bodyLines;
    }
    /**
   * Returns the song paragraphs, skipping the paragraphs that only contain empty lines
   * (empty as in not rendering any content)
   * @see {@link bodyLines}
   * @returns {Paragraph[]}
   */ get bodyParagraphs() {
        if (!this._bodyParagraphs) this._bodyParagraphs = this.selectRenderableItems(this.paragraphs);
        return this._bodyParagraphs;
    }
    selectRenderableItems(items) {
        const copy = [
            ...items
        ];
        while(copy.length && !copy[0].hasRenderableItems())copy.shift();
        return copy;
    }
    chords(chr) {
        if (!this.currentLine) throw new Error("Expected this.currentLine to be present");
        this.currentLine.chords(chr);
    }
    lyrics(chr) {
        this.ensureLine();
        if (!this.currentLine) throw new Error("Expected this.currentLine to be present");
        this.currentLine.lyrics(chr);
    }
    addLine(line) {
        if (line) this.currentLine = line;
        else {
            this.currentLine = new (0, $06eb272065540fc1$export$2e2bcd8739ae039)();
            this.lines.push(this.currentLine);
        }
        this.setCurrentProperties(this.sectionType);
        this.currentLine.transposeKey = this.transposeKey ?? this.currentKey;
        this.currentLine.key = this.currentKey || this.metadata.getSingle((0, $b3836272a1374d85$export$7167c830cefcb6b5));
        this.currentLine.lineNumber = this.lines.length - 1;
        return this.currentLine;
    }
    expandLine(line) {
        const expandedLines = line.items.flatMap((item)=>{
            if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === (0, $b3836272a1374d85$export$8db6c706fc9142b2)) return this.getLastChorusBefore(line.lineNumber);
            return [];
        });
        return [
            line,
            ...expandedLines
        ];
    }
    getLastChorusBefore(lineNumber) {
        const lines = [];
        if (!lineNumber) return lines;
        for(let i = lineNumber - 1; i >= 0; i -= 1){
            const line = this.lines[i];
            if (line.type === (0, $234747a9630b4642$export$8db6c706fc9142b2)) {
                const filteredLine = this.filterChorusStartEndDirectives(line);
                if (!(line.isNotEmpty() && filteredLine.isEmpty())) lines.unshift(line);
            } else if (lines.length > 0) break;
        }
        return lines;
    }
    filterChorusStartEndDirectives(line) {
        return line.mapItems((item)=>{
            if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) {
                if (item.name === (0, $b3836272a1374d85$export$4f5168acae064e01) || item.name === (0, $b3836272a1374d85$export$473c1a4819e5180b)) return null;
            }
            return item;
        });
    }
    /**
   * The {@link Paragraph} items of which the song consists
   * @member {Paragraph[]}
   */ get paragraphs() {
        return this.linesToParagraphs(this.lines);
    }
    /**
   * The body paragraphs of the song, with any `{chorus}` tag expanded into the targetted chorus
   * @type {Paragraph[]}
   */ get expandedBodyParagraphs() {
        return this.selectRenderableItems(this.linesToParagraphs(this.lines.flatMap((line)=>this.expandLine(line))));
    }
    linesToParagraphs(lines) {
        let currentParagraph = new (0, $55861b6d10167265$export$2e2bcd8739ae039)();
        const paragraphs = [
            currentParagraph
        ];
        lines.forEach((line)=>{
            if (line.isEmpty()) {
                currentParagraph = new (0, $55861b6d10167265$export$2e2bcd8739ae039)();
                paragraphs.push(currentParagraph);
            } else if (line.hasRenderableItems()) currentParagraph.addLine(line);
        });
        return paragraphs;
    }
    setCurrentProperties(sectionType) {
        if (!this.currentLine) throw new Error("Expected this.currentLine to be present");
        this.currentLine.type = sectionType;
        this.currentLine.textFont = this.fontStack.textFont.clone();
        this.currentLine.chordFont = this.fontStack.chordFont.clone();
    }
    ensureLine() {
        if (this.currentLine === null) this.addLine();
    }
    addTag(tagContents) {
        const tag = (0, $b3836272a1374d85$export$2e2bcd8739ae039).parseOrFail(tagContents);
        this.applyTagOnSong(tag);
        this.applyTagOnLine(tag);
        return tag;
    }
    applyTagOnLine(tag) {
        this.ensureLine();
        if (!this.currentLine) throw new Error("Expected this.currentLine to be present");
        this.currentLine.addTag(tag);
    }
    applyTagOnSong(tag) {
        if (tag.isMetaTag()) this.setMetadata(tag.name, tag.value || "");
        else if (tag.name === (0, $b3836272a1374d85$export$ae60ab9b4739fc3d)) this.transposeKey = tag.value;
        else if (tag.name === (0, $b3836272a1374d85$export$b7627374a6424f68)) this.currentKey = tag.value;
        else if (tag.isSectionDelimiter()) this.setSectionTypeFromTag(tag);
        else if (tag.isInlineFontTag()) this.fontStack.applyTag(tag);
    }
    setSectionTypeFromTag(tag) {
        switch(tag.name){
            case 0, $b3836272a1374d85$export$4f5168acae064e01:
                this.startSection((0, $234747a9630b4642$export$8db6c706fc9142b2), tag);
                break;
            case 0, $b3836272a1374d85$export$473c1a4819e5180b:
                this.endSection((0, $234747a9630b4642$export$8db6c706fc9142b2), tag);
                break;
            case 0, $b3836272a1374d85$export$8dd1111100e0e88d:
                this.startSection((0, $234747a9630b4642$export$f1c9dd0f5207dd5e), tag);
                break;
            case 0, $b3836272a1374d85$export$66a0ef3ffeab32b7:
                this.endSection((0, $234747a9630b4642$export$f1c9dd0f5207dd5e), tag);
                break;
            case 0, $b3836272a1374d85$export$deca399f8cd9b7dc:
                this.startSection((0, $234747a9630b4642$export$4b194284baed1659), tag);
                break;
            case 0, $b3836272a1374d85$export$640d294ab83f9040:
                this.endSection((0, $234747a9630b4642$export$4b194284baed1659), tag);
                break;
            default:
                break;
        }
    }
    startSection(sectionType, tag) {
        this.checkCurrentSectionType((0, $234747a9630b4642$export$c53d0f541b41b88e), tag);
        this.sectionType = sectionType;
        this.setCurrentProperties(sectionType);
    }
    endSection(sectionType, tag) {
        this.checkCurrentSectionType(sectionType, tag);
        this.sectionType = (0, $234747a9630b4642$export$c53d0f541b41b88e);
    }
    checkCurrentSectionType(sectionType, tag) {
        if (this.sectionType !== sectionType) this.addWarning(`Unexpected tag {${tag.originalName}, current section is: ${this.sectionType}`, tag);
    }
    addWarning(message, { line: line , column: column  }) {
        const warning = new (0, $8a1166616d2a7987$export$2e2bcd8739ae039)(message, line || null, column || null);
        this.warnings.push(warning);
    }
    addItem(item) {
        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) this.addTag(item);
        else {
            this.ensureLine();
            if (!this.currentLine) throw new Error("Expected this.currentLine to be present");
            this.currentLine.addItem(item);
        }
    }
    /**
   * Returns a deep clone of the song
   * @returns {Song} The cloned song
   */ clone() {
        return this.mapItems((item)=>item);
    }
    setMetadata(name, value) {
        this.metadata.add(name, value);
    }
    /**
   * The song's metadata. Please use {@link metadata} instead.
   * @deprecated
   * @returns {@link Metadata} The metadata
   */ get metaData() {
        (0, $974bd1d260bb1d53$export$b680e6b2c82f8c2f)('metaData has been deprecated, please use metadata instead (notice the lowercase "d")');
        return this.metadata;
    }
    getMetadata(name) {
        return this.metadata.getMetadata(name);
    }
    getSingleMetadata(name) {
        return this.metadata.getSingleMetadata(name);
    }
    /**
   * Returns a copy of the song with the key value set to the specified key. It changes:
   * - the value for `key` in the {@link metadata} set
   * - any existing `key` directive
   * @param {number|null} key the key. Passing `null` will:
   * - remove the current key from {@link metadata}
   * - remove any `key` directive
   * @returns {Song} The changed song
   */ setKey(key) {
        const strKey = key ? key.toString() : null;
        return this.changeMetadata((0, $b3836272a1374d85$export$7167c830cefcb6b5), strKey);
    }
    /**
   * Returns a copy of the song with the key value set to the specified capo. It changes:
   * - the value for `capo` in the {@link metadata} set
   * - any existing `capo` directive
   * @param {number|null} capo the capo. Passing `null` will:
   * - remove the current key from {@link metadata}
   * - remove any `capo` directive
   * @returns {Song} The changed song
   */ setCapo(capo) {
        const strCapo = capo ? capo.toString() : null;
        return this.changeMetadata((0, $b3836272a1374d85$export$866f445d49bad88e), strCapo);
    }
    setDirective(name, value) {
        if (value === null) return this.removeItem((item)=>item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === name);
        return this.updateItem((item)=>item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === name, (item)=>"set" in item ? item.set({
                value: value
            }) : item, (song)=>song.insertDirective(name, value));
    }
    /**
   * Transposes the song by the specified delta. It will:
   * - transpose all chords, see: {@link Chord#transpose}
   * - transpose the song key in {@link metadata}
   * - update any existing `key` directive
   * @param {number} delta The number of semitones (positive or negative) to transpose with
   * @param {Object} [options={}] options
   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing
   * @returns {Song} The transposed song
   */ transpose(delta, { normalizeChordSuffix: normalizeChordSuffix = false  } = {}) {
        const wrappedKey = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(this.key);
        let transposedKey = null;
        let song = this;
        if (wrappedKey) {
            transposedKey = wrappedKey.transpose(delta);
            song = song.setKey(transposedKey.toString());
        }
        return song.mapItems((item)=>{
            if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return item.transpose(delta, transposedKey, {
                normalizeChordSuffix: normalizeChordSuffix
            });
            return item;
        });
    }
    /**
   * Transposes the song up by one semitone. It will:
   * - transpose all chords, see: {@link Chord#transpose}
   * - transpose the song key in {@link metadata}
   * - update any existing `key` directive
   * @param {Object} [options={}] options
   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing
   * @returns {Song} The transposed song
   */ transposeUp({ normalizeChordSuffix: normalizeChordSuffix = false  } = {}) {
        return this.transpose(1, {
            normalizeChordSuffix: normalizeChordSuffix
        });
    }
    /**
   * Transposes the song down by one semitone. It will:
   * - transpose all chords, see: {@link Chord#transpose}
   * - transpose the song key in {@link metadata}
   * - update any existing `key` directive
   * @param {Object} [options={}] options
   * @param {boolean} [options.normalizeChordSuffix=false] whether to normalize the chord suffixes after transposing
   * @returns {Song} The transposed song
   */ transposeDown({ normalizeChordSuffix: normalizeChordSuffix = false  } = {}) {
        return this.transpose(-1, {
            normalizeChordSuffix: normalizeChordSuffix
        });
    }
    /**
   * Returns a copy of the song with the key set to the specified key. It changes:
   * - the value for `key` in the {@link metadata} set
   * - any existing `key` directive
   * - all chords, those are transposed according to the distance between the current and the new key
   * @param {string} newKey The new key.
   * @returns {Song} The changed song
   */ changeKey(newKey) {
        const transpose = this.getTransposeDistance(newKey);
        const updatedSong = this.mapItems((item)=>{
            if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === (0, $b3836272a1374d85$export$7167c830cefcb6b5)) return item.set({
                value: newKey.toString()
            });
            if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return item.transpose(transpose, newKey);
            return item;
        });
        this.setKey(newKey.toString());
        return updatedSong;
    }
    getTransposeDistance(newKey) {
        const wrappedKey = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(this.key);
        if (!wrappedKey) throw new Error(`
Cannot change song key, the original key is unknown.

Either ensure a key directive is present in the song (when using chordpro):
  \`{key: C}\`

Or set the song key before changing key:
  \`song.setKey('C');\``.substring(1));
        return wrappedKey.distanceTo(newKey);
    }
    /**
   * Returns a copy of the song with the directive value set to the specified value.
   * - when there is a matching directive in the song, it will update the directive
   * - when there is no matching directive, it will be inserted
   * If `value` is `null` it will act as a delete, any directive matching `name` will be removed.
   * @param {string} name The directive name
   * @param {string | null} value The value to set, or `null` to remove the directive
   */ changeMetadata(name, value) {
        const updatedSong = this.setDirective(name, value);
        updatedSong.metadata.set(name, value);
        return updatedSong;
    }
    insertDirective(name, value, { after: after = null  } = {}) {
        const insertIndex = this.lines.findIndex((line)=>line.items.some((item)=>!(item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) || after && item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.name === after));
        const newLine = new (0, $06eb272065540fc1$export$2e2bcd8739ae039)();
        newLine.addTag(name, value);
        const clonedSong = this.clone();
        const { lines: lines  } = clonedSong;
        clonedSong.lines = [
            ...lines.slice(0, insertIndex),
            newLine,
            ...lines.slice(insertIndex)
        ];
        return clonedSong;
    }
    /**
   * Change the song contents inline. Return a new {@link Item} to replace it. Return `null` to remove it.
   * @example
   * // transpose all chords:
   * song.mapItems((item) => {
   *   if (item instanceof ChordLyricsPair) {
   *     return item.transpose(2, 'D');
   *   }
   *
   *   return item;
   * });
   * @param {MapItemsCallback} func the callback function
   * @returns {Song} the changed song
   */ mapItems(func) {
        const clonedSong = new $7860c26c4d50915f$var$Song();
        this.lines.forEach((line)=>{
            clonedSong.addLine();
            line.items.forEach((item)=>{
                const changedItem = func(item);
                if (changedItem) clonedSong.addItem(changedItem);
            });
        });
        return clonedSong;
    }
    /**
   * Change the song contents inline. Return a new {@link Line} to replace it. Return `null` to remove it.
   * @example
   * // remove lines with only Tags:
   * song.mapLines((line) => {
   *   if (line.items.every(item => item instanceof Tag)) {
   *     return null;
   *   }
   *
   *   return line;
   * });
   * @param {MapLinesCallback} func the callback function
   * @returns {Song} the changed song
   */ mapLines(func) {
        const clonedSong = new $7860c26c4d50915f$var$Song();
        this.lines.forEach((line)=>{
            const changedLine = func(line);
            if (changedLine) {
                clonedSong.addLine();
                changedLine.items.forEach((item)=>clonedSong.addItem(item));
            }
        });
        return clonedSong;
    }
    updateItem(findCallback, updateCallback, notFoundCallback) {
        let found = false;
        const updatedSong = this.mapItems((item)=>{
            if (findCallback(item)) {
                found = true;
                return updateCallback(item);
            }
            return item;
        });
        if (!found) return notFoundCallback(updatedSong);
        return updatedSong;
    }
    removeItem(callback) {
        return this.mapLines((line)=>{
            const { items: items  } = line;
            const index = items.findIndex(callback);
            if (index === -1) return line;
            if (items.length === 1) return null;
            return line.set({
                items: [
                    ...items.slice(0, index),
                    ...items.slice(index + 1)
                ]
            });
        });
    }
}
var $7860c26c4d50915f$export$2e2bcd8739ae039 = $7860c26c4d50915f$var$Song;







const $2a399cf90c614489$var$CHORD_SHEET = "chordSheet";
const $2a399cf90c614489$var$CHORD_LYRICS_PAIR = "chordLyricsPair";
const $2a399cf90c614489$var$TAG = "tag";
const $2a399cf90c614489$var$COMMENT = "comment";
const $2a399cf90c614489$var$TERNARY = "ternary";
const $2a399cf90c614489$var$LINE = "line";
/**
 * Serializes a song into een plain object, and deserializes the serialized object back into a {@link Song}
 */ class $2a399cf90c614489$var$ChordSheetSerializer {
    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();
    /**
   * Serializes the chord sheet to a plain object, which can be converted to any format like JSON, XML etc
   * Can be deserialized using {@link deserialize}
   * @returns object A plain JS object containing all chord sheet data
   */ serialize(song) {
        return {
            type: $2a399cf90c614489$var$CHORD_SHEET,
            lines: song.lines.map((line)=>this.serializeLine(line))
        };
    }
    serializeLine(line) {
        return {
            type: $2a399cf90c614489$var$LINE,
            items: line.items.map((item)=>this.serializeItem(item))
        };
    }
    serializeItem(item) {
        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039)) return this.serializeTag(item);
        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return this.serializeChordLyricsPair(item);
        if (item instanceof (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)) return this.serializeTernary(item);
        if (item instanceof (0, $758385c5b662d76d$export$2e2bcd8739ae039)) return this.serializeLiteral(item);
        throw new Error(`Don't know how to serialize ${item.constructor.name}`);
    }
    serializeTag(tag) {
        return {
            type: $2a399cf90c614489$var$TAG,
            name: tag.originalName,
            value: tag.value
        };
    }
    serializeChordLyricsPair(chordLyricsPair) {
        return {
            type: $2a399cf90c614489$var$CHORD_LYRICS_PAIR,
            chords: chordLyricsPair.chords,
            chord: null,
            lyrics: chordLyricsPair.lyrics
        };
    }
    serializeTernary(ternary) {
        return {
            type: $2a399cf90c614489$var$TERNARY,
            variable: ternary.variable,
            valueTest: ternary.valueTest,
            trueExpression: this.serializeExpression(ternary.trueExpression),
            falseExpression: this.serializeExpression(ternary.falseExpression)
        };
    }
    serializeLiteral(literal) {
        return literal.string;
    }
    serializeExpression(expression) {
        return expression.map((part)=>this.serializeItem(part));
    }
    /**
   * Deserializes a song that has been serialized using {@link serialize}
   * @param {object} serializedSong The serialized song
   * @returns {Song} The deserialized song
   */ deserialize(serializedSong) {
        this.parseAstComponent(serializedSong);
        return this.song;
    }
    parseAstComponent(astComponent) {
        if (!astComponent) return null;
        if (typeof astComponent === "string") return new (0, $758385c5b662d76d$export$2e2bcd8739ae039)(astComponent);
        const { type: type  } = astComponent;
        switch(type){
            case $2a399cf90c614489$var$CHORD_SHEET:
                this.parseChordSheet(astComponent);
                break;
            case $2a399cf90c614489$var$CHORD_LYRICS_PAIR:
                return this.parseChordLyricsPair(astComponent);
            case $2a399cf90c614489$var$TAG:
                return this.parseTag(astComponent);
            case $2a399cf90c614489$var$COMMENT:
                return this.parseComment(astComponent);
            case $2a399cf90c614489$var$TERNARY:
                return this.parseTernary(astComponent);
            default:
                console.warn(`Unhandled AST component "${type}"`, astComponent);
        }
        return null;
    }
    parseChordSheet(astComponent) {
        const { lines: lines  } = astComponent;
        this.song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();
        lines.forEach((line)=>this.parseLine(line));
    }
    parseLine(astComponent) {
        const { items: items  } = astComponent;
        this.song.addLine();
        items.forEach((item)=>{
            const parsedItem = this.parseAstComponent(item);
            this.song.addItem(parsedItem);
        });
    }
    parseChordLyricsPair(astComponent) {
        const { chord: chord , chords: chords , lyrics: lyrics  } = astComponent;
        return new (0, $f7a904d05353aafa$export$2e2bcd8739ae039)(chord ? new (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039)(chord).toString() : chords, lyrics);
    }
    parseTag(astComponent) {
        const { name: name , value: value , location: { offset: offset = null , line: line = null , column: column = null  } = {}  } = astComponent;
        return new (0, $b3836272a1374d85$export$2e2bcd8739ae039)(name, value, {
            line: line,
            column: column,
            offset: offset
        });
    }
    parseComment(astComponent) {
        const { comment: comment  } = astComponent;
        return new (0, $df4ad73a744c94b3$export$2e2bcd8739ae039)(comment);
    }
    parseTernary(astComponent) {
        const { variable: variable , valueTest: valueTest , trueExpression: trueExpression , falseExpression: falseExpression , location: { offset: offset = null , line: line = null , column: column = null  } = {}  } = astComponent;
        return new (0, $d6f43bad3b61b86a$export$2e2bcd8739ae039)({
            variable: variable,
            valueTest: valueTest,
            trueExpression: this.parseExpression(trueExpression),
            falseExpression: this.parseExpression(falseExpression),
            offset: offset,
            line: line,
            column: column
        });
    }
    parseExpression(expression) {
        return (expression || []).map((part)=>this.parseAstComponent(part)).filter((part)=>part !== null);
    }
}
var $2a399cf90c614489$export$2e2bcd8739ae039 = $2a399cf90c614489$var$ChordSheetSerializer;



/**
 * Parses a chords over words sheet
 */ class $3e6b6f33997c81b2$var$PegBasedParser {
    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();
    /**
   * All warnings raised during parsing the chord sheet
   * @member
   * @type {ParserWarning[]}
   */ get warnings() {
        return this.song.warnings;
    }
    parseWithParser(chordSheet, parser) {
        const ast = parser((0, $974bd1d260bb1d53$export$ba13e0e2f19e61a1)(chordSheet));
        this.song = new (0, $2a399cf90c614489$export$2e2bcd8739ae039)().deserialize(ast);
        return this.song;
    }
}
var $3e6b6f33997c81b2$export$2e2bcd8739ae039 = $3e6b6f33997c81b2$var$PegBasedParser;


// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs
"use strict";
function $182dbf639c88db75$var$peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
class $182dbf639c88db75$export$628c65c376ead699 extends Error {
    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch));
        }
        function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch));
        }
        function describeExpectation(expectation) {
            switch(expectation.type){
                case "literal":
                    return '"' + literalEscape(expectation.text) + '"';
                case "class":
                    const escapedParts = expectation.parts.map((part)=>{
                        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            const descriptions = expected1.map(describeExpectation);
            let i;
            let j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
                descriptions.length = j;
            }
            switch(descriptions.length){
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
    constructor(message, expected, found, location){
        super();
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "PeggySyntaxError";
        if (typeof Object.setPrototypeOf === "function") Object.setPrototypeOf(this, $182dbf639c88db75$export$628c65c376ead699.prototype);
        else this.__proto__ = $182dbf639c88db75$export$628c65c376ead699.prototype;
        if (typeof Error.captureStackTrace === "function") Error.captureStackTrace(this, $182dbf639c88db75$export$628c65c376ead699);
    }
    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            let k;
            for(k = 0; k < sources.length; k++)if (sources[k].grammarSource === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
            }
            let s = this.location.start;
            let loc = this.location.source + ":" + s.line + ":" + s.column;
            if (src) {
                let e = this.location.end;
                let filler = $182dbf639c88db75$var$peg$padEnd("", s.line.toString().length, " ");
                let line = src[s.line - 1];
                let last = s.line === e.line ? e.column : line.length + 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + s.line + " | " + line + "\n" + filler + " | " + $182dbf639c88db75$var$peg$padEnd("", s.column - 1, " ") + $182dbf639c88db75$var$peg$padEnd("", last - s.column, "^");
            } else str += "\n at " + loc;
        }
        return str;
    }
}
function $182dbf639c88db75$var$peg$parse(input, options) {
    options = options !== undefined ? options : {};
    const peg$FAILED = {};
    const peg$source = options.grammarSource;
    const peg$startRuleFunctions = {
        ChordSheet: peg$parseChordSheet
    };
    let peg$startRuleFunction = peg$parseChordSheet;
    const peg$c0 = function(lines, line) {
        return {
            type: "chordSheet",
            lines: [
                ...lines,
                line
            ]
        };
    };
    const peg$c1 = function(line) {
        return line;
    };
    const peg$c2 = function(lyrics, tokens, chords, comment) {
        return {
            type: "line",
            items: [
                lyrics ? {
                    type: "chordLyricsPair",
                    chords: "",
                    lyrics: lyrics
                } : null,
                ...tokens,
                chords ? {
                    type: "chordLyricsPair",
                    chords: chords,
                    lyrics: ""
                } : null,
                comment ? {
                    type: "comment",
                    comment: comment
                } : null
            ].filter((x)=>x)
        };
    };
    const peg$c3 = function(lyrics) {
        return {
            type: "chordLyricsPair",
            chords: "",
            lyrics: lyrics
        };
    };
    const peg$c4 = "#";
    const peg$c5 = peg$literalExpectation("#", false);
    const peg$c6 = /^[^\r\n]/;
    const peg$c7 = peg$classExpectation([
        "\r",
        "\n"
    ], true, false);
    const peg$c8 = function(comment) {
        return comment;
    };
    const peg$c9 = function(chords, lyrics, space) {
        return {
            type: "chordLyricsPair",
            chords: chords || "",
            lyrics: lyrics + (space || "")
        };
    };
    const peg$c10 = function(lyrics) {
        return lyrics.map((c)=>c.char || c).join("");
    };
    const peg$c11 = "[";
    const peg$c12 = peg$literalExpectation("[", false);
    const peg$c13 = "]";
    const peg$c14 = peg$literalExpectation("]", false);
    const peg$c15 = function(chords) {
        return chords.map((c)=>c.char || c).join("");
    };
    const peg$c16 = /^[^\]\r\n]/;
    const peg$c17 = peg$classExpectation([
        "]",
        "\r",
        "\n"
    ], true, false);
    const peg$c18 = "\\";
    const peg$c19 = peg$literalExpectation("\\", false);
    const peg$c20 = function() {
        return {
            type: "char",
            char: "\\"
        };
    };
    const peg$c21 = function() {
        return {
            type: "char",
            char: "]"
        };
    };
    const peg$c22 = function(sequence) {
        return sequence;
    };
    const peg$c23 = "%{";
    const peg$c24 = peg$literalExpectation("%{", false);
    const peg$c25 = "}";
    const peg$c26 = peg$literalExpectation("}", false);
    const peg$c27 = function(variableName, valueTest, expressions) {
        return {
            type: "ternary",
            variable: variableName.length > 0 ? variableName : null,
            valueTest: valueTest,
            ...expressions,
            location: location().start
        };
    };
    const peg$c28 = "=";
    const peg$c29 = peg$literalExpectation("=", false);
    const peg$c30 = function(testValue) {
        return testValue;
    };
    const peg$c31 = "|";
    const peg$c32 = peg$literalExpectation("|", false);
    const peg$c33 = function(trueExpression, falseExpression) {
        return {
            type: "ternary",
            trueExpression: trueExpression,
            falseExpression: falseExpression,
            location: location().start
        };
    };
    const peg$c34 = function(falseExpression) {
        return falseExpression;
    };
    const peg$c35 = /^[a-zA-Z0-9\-_]/;
    const peg$c36 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "A",
            "Z"
        ],
        [
            "0",
            "9"
        ],
        "-",
        "_"
    ], false, false);
    const peg$c37 = function() {
        return {
            type: "char",
            char: "]"
        };
    };
    const peg$c38 = function() {
        return {
            type: "char",
            char: "|"
        };
    };
    const peg$c39 = function() {
        return {
            type: "char",
            char: "}"
        };
    };
    const peg$c40 = /^[^|[\]\\{}%#\r\n\t ]/;
    const peg$c41 = peg$classExpectation([
        "|",
        "[",
        "]",
        "\\",
        "{",
        "}",
        "%",
        "#",
        "\r",
        "\n",
        "	",
        " "
    ], true, false);
    const peg$c42 = function() {
        return {
            type: "char",
            char: "\\"
        };
    };
    const peg$c43 = function() {
        return {
            type: "char",
            char: "["
        };
    };
    const peg$c44 = "{";
    const peg$c45 = peg$literalExpectation("{", false);
    const peg$c46 = function() {
        return {
            type: "char",
            char: "{"
        };
    };
    const peg$c47 = "%";
    const peg$c48 = peg$literalExpectation("%", false);
    const peg$c49 = function() {
        return {
            type: "char",
            char: "%"
        };
    };
    const peg$c50 = function() {
        return {
            type: "char",
            char: "#"
        };
    };
    const peg$c51 = function(tagName, tagColonWithValue) {
        return {
            type: "tag",
            name: tagName,
            value: tagColonWithValue,
            location: location().start
        };
    };
    const peg$c52 = ":";
    const peg$c53 = peg$literalExpectation(":", false);
    const peg$c54 = function(tagValue) {
        return tagValue.map((c)=>c.char || c).join("");
    };
    const peg$c55 = /^[a-zA-Z\-_]/;
    const peg$c56 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "A",
            "Z"
        ],
        "-",
        "_"
    ], false, false);
    const peg$c57 = /^[^}\\\r\n]/;
    const peg$c58 = peg$classExpectation([
        "}",
        "\\",
        "\r",
        "\n"
    ], true, false);
    const peg$c59 = peg$otherExpectation("whitespace");
    const peg$c60 = /^[ \t\n\r]/;
    const peg$c61 = peg$classExpectation([
        " ",
        "	",
        "\n",
        "\r"
    ], false, false);
    const peg$c62 = peg$otherExpectation("space");
    const peg$c63 = /^[ \t]/;
    const peg$c64 = peg$classExpectation([
        " ",
        "	"
    ], false, false);
    const peg$c65 = "\n";
    const peg$c66 = peg$literalExpectation("\n", false);
    const peg$c67 = "\r";
    const peg$c68 = peg$literalExpectation("\r", false);
    let peg$currPos = 0;
    let peg$savedPos = 0;
    const peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    let peg$maxFailPos = 0;
    let peg$maxFailExpected = [];
    let peg$silentFails = 0;
    let peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return {
            type: "literal",
            text: text1,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);
        return {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new $182dbf639c88db75$export$628c65c376ead699(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new $182dbf639c88db75$export$628c65c376ead699($182dbf639c88db75$export$628c65c376ead699.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$parseChordSheet() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseLineWithNewline();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseLineWithNewline();
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseLine();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s1, s2);
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseLineWithNewline() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseLine();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNewLine();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c1(s1);
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseLine() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseLyrics();
        if (s2 === peg$FAILED) s2 = null;
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseToken();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parseToken();
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseChord();
                if (s3 === peg$FAILED) s3 = null;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseComment();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        s5 = [];
                        s6 = peg$parseSpace();
                        while(s6 !== peg$FAILED){
                            s5.push(s6);
                            s6 = peg$parseSpace();
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c2(s1, s2, s3, s4);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseToken() {
        let s0, s1;
        s0 = peg$parseTag();
        if (s0 === peg$FAILED) {
            s0 = peg$parseChordLyricsPair();
            if (s0 === peg$FAILED) {
                s0 = peg$parseMetaTernary();
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseLyrics();
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c3(s1);
                    }
                    s0 = s1;
                }
            }
        }
        return s0;
    }
    function peg$parseComment() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseSpace();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 35) {
                s2 = peg$c4;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c5);
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = [];
                if (peg$c6.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c7);
                }
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    if (peg$c6.test(input.charAt(peg$currPos))) {
                        s5 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c7);
                    }
                }
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c8(s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordLyricsPair() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseChord();
        if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = [];
            s4 = peg$parseLyricsChar();
            while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parseLyricsChar();
            }
            if (s3 !== peg$FAILED) s2 = input.substring(s2, peg$currPos);
            else s2 = s3;
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = [];
                s5 = peg$parseSpace();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parseSpace();
                }
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c9(s1, s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseLyrics() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseLyricsCharOrSpace();
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseLyricsCharOrSpace();
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c10(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseLyricsCharOrSpace() {
        let s0;
        s0 = peg$parseLyricsChar();
        if (s0 === peg$FAILED) s0 = peg$parseSpace();
        return s0;
    }
    function peg$parseChord() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$parseEscape();
        peg$silentFails--;
        if (s2 === peg$FAILED) s1 = undefined;
        else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
                s2 = peg$c11;
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c12);
            }
            if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseChordChar();
                while(s4 !== peg$FAILED){
                    s3.push(s4);
                    s4 = peg$parseChordChar();
                }
                if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                        s4 = peg$c13;
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c14);
                    }
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c15(s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordChar() {
        let s0, s1, s2, s3;
        if (peg$c16.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c17);
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEscape();
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                    s3 = peg$c18;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c19);
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c20();
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 93) {
                        s3 = peg$c13;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c14);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c21();
                    }
                    s2 = s3;
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c22(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseMetaTernary() {
        let s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c23) {
            s1 = peg$c23;
            peg$currPos += 2;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c24);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseMetaVariableName();
                if (s4 === peg$FAILED) s4 = null;
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseMetaValueTest();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parse_();
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parseMetaTernaryTrueFalseExpressions();
                            if (s6 === peg$FAILED) s6 = null;
                            if (s6 !== peg$FAILED) {
                                s7 = peg$parse_();
                                if (s7 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s8 = peg$c25;
                                        peg$currPos++;
                                    } else {
                                        s8 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$c26);
                                    }
                                    if (s8 !== peg$FAILED) {
                                        peg$savedPos = s0;
                                        s1 = peg$c27(s3, s4, s6);
                                        s0 = s1;
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaValueTest() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
            s1 = peg$c28;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c29);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseMetaTestValue();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c30(s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaTestValue() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseChar();
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseChar();
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        return s0;
    }
    function peg$parseMetaTernaryTrueFalseExpressions() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 124) {
            s1 = peg$c31;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c32);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseMetaExpression();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseMetaTernaryFalseExpression();
                        if (s5 === peg$FAILED) s5 = null;
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c33(s3, s5);
                                s0 = s1;
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaTernaryFalseExpression() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 124) {
            s1 = peg$c31;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c32);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseMetaExpression();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c34(s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetaVariableName() {
        let s0, s1;
        s0 = [];
        if (peg$c35.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c36);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c35.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c36);
            }
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parseMetaExpression() {
        let s0, s1, s2, s3;
        s0 = [];
        s1 = peg$currPos;
        s2 = [];
        s3 = peg$parseChar();
        if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
            s2.push(s3);
            s3 = peg$parseChar();
        }
        else s2 = peg$FAILED;
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 === peg$FAILED) s1 = peg$parseMetaTernary();
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parseChar();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parseChar();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
            else s1 = s2;
            if (s1 === peg$FAILED) s1 = peg$parseMetaTernary();
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parseLyricsChar() {
        let s0, s1;
        s0 = peg$parseWordChar();
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 93) {
                s1 = peg$c13;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c14);
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c37();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 124) {
                    s1 = peg$c31;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c32);
                }
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c38();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 125) {
                        s1 = peg$c25;
                        peg$currPos++;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c26);
                    }
                    if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c39();
                    }
                    s0 = s1;
                }
            }
        }
        return s0;
    }
    function peg$parseChar() {
        let s0;
        s0 = peg$parseWordChar();
        if (s0 === peg$FAILED) s0 = peg$parseSpace();
        return s0;
    }
    function peg$parseWordChar() {
        let s0, s1, s2, s3;
        if (peg$c40.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c41);
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEscape();
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                    s3 = peg$c18;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c19);
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c42();
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 124) {
                        s3 = peg$c31;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c32);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c38();
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                        s2 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 91) {
                            s3 = peg$c11;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c12);
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c43();
                        }
                        s2 = s3;
                        if (s2 === peg$FAILED) {
                            s2 = peg$currPos;
                            if (input.charCodeAt(peg$currPos) === 93) {
                                s3 = peg$c13;
                                peg$currPos++;
                            } else {
                                s3 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c14);
                            }
                            if (s3 !== peg$FAILED) {
                                peg$savedPos = s2;
                                s3 = peg$c37();
                            }
                            s2 = s3;
                            if (s2 === peg$FAILED) {
                                s2 = peg$currPos;
                                if (input.charCodeAt(peg$currPos) === 123) {
                                    s3 = peg$c44;
                                    peg$currPos++;
                                } else {
                                    s3 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c45);
                                }
                                if (s3 !== peg$FAILED) {
                                    peg$savedPos = s2;
                                    s3 = peg$c46();
                                }
                                s2 = s3;
                                if (s2 === peg$FAILED) {
                                    s2 = peg$currPos;
                                    if (input.charCodeAt(peg$currPos) === 125) {
                                        s3 = peg$c25;
                                        peg$currPos++;
                                    } else {
                                        s3 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$c26);
                                    }
                                    if (s3 !== peg$FAILED) {
                                        peg$savedPos = s2;
                                        s3 = peg$c39();
                                    }
                                    s2 = s3;
                                    if (s2 === peg$FAILED) {
                                        s2 = peg$currPos;
                                        if (input.charCodeAt(peg$currPos) === 37) {
                                            s3 = peg$c47;
                                            peg$currPos++;
                                        } else {
                                            s3 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$c48);
                                        }
                                        if (s3 !== peg$FAILED) {
                                            peg$savedPos = s2;
                                            s3 = peg$c49();
                                        }
                                        s2 = s3;
                                        if (s2 === peg$FAILED) {
                                            s2 = peg$currPos;
                                            if (input.charCodeAt(peg$currPos) === 35) {
                                                s3 = peg$c4;
                                                peg$currPos++;
                                            } else {
                                                s3 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$c5);
                                            }
                                            if (s3 !== peg$FAILED) {
                                                peg$savedPos = s2;
                                                s3 = peg$c50();
                                            }
                                            s2 = s3;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c22(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parseTag() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c44;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c45);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseTagName();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$parseTagColonWithValue();
                        if (s5 === peg$FAILED) s5 = null;
                        if (s5 !== peg$FAILED) {
                            s6 = peg$parse_();
                            if (s6 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 125) {
                                    s7 = peg$c25;
                                    peg$currPos++;
                                } else {
                                    s7 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c26);
                                }
                                if (s7 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c51(s3, s5);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTagColonWithValue() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 58) {
            s1 = peg$c52;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c53);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseTagValue();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c54(s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseTagName() {
        let s0, s1;
        s0 = [];
        if (peg$c55.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c56);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c55.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c56);
            }
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parseTagValue() {
        let s0, s1;
        s0 = [];
        s1 = peg$parseTagValueChar();
        while(s1 !== peg$FAILED){
            s0.push(s1);
            s1 = peg$parseTagValueChar();
        }
        return s0;
    }
    function peg$parseTagValueChar() {
        let s0, s1, s2, s3;
        if (peg$c57.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c58);
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseEscape();
            if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 92) {
                    s3 = peg$c18;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c19);
                }
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s3 = peg$c42();
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 125) {
                        s3 = peg$c25;
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c26);
                    }
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s3 = peg$c39();
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                        s2 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 123) {
                            s3 = peg$c44;
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c45);
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s2;
                            s3 = peg$c46();
                        }
                        s2 = s3;
                    }
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c22(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parse_() {
        let s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$c60.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c61);
        }
        while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c60.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c61);
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c59);
        }
        return s0;
    }
    function peg$parseSpace() {
        let s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$c63.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c64);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c63.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c64);
            }
        }
        else s0 = peg$FAILED;
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c62);
        }
        return s0;
    }
    function peg$parseNewLine() {
        let s0;
        s0 = peg$parseCarriageReturn();
        if (s0 === peg$FAILED) {
            s0 = peg$parseLineFeed();
            if (s0 === peg$FAILED) s0 = peg$parseCarriageReturnLineFeed();
        }
        return s0;
    }
    function peg$parseCarriageReturnLineFeed() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseCarriageReturn();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseLineFeed();
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseLineFeed() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c65;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c66);
        }
        return s0;
    }
    function peg$parseCarriageReturn() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c67;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c68);
        }
        return s0;
    }
    function peg$parseEscape() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 92) {
            s0 = peg$c18;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c19);
        }
        return s0;
    }
    function peg$parsePound() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 35) {
            s0 = peg$c4;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c5);
        }
        return s0;
    }
    function peg$parsePercent() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 37) {
            s0 = peg$c47;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c48);
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
const $182dbf639c88db75$export$98e6a39c04603d36 = $182dbf639c88db75$var$peg$parse;


/**
 * Parses a ChordPro chord sheet
 */ class $8e2b91641771a21c$var$ChordProParser extends (0, $3e6b6f33997c81b2$export$2e2bcd8739ae039) {
    /**
   * Parses a ChordPro chord sheet into a song
   * @param {string} chordProChordSheet the ChordPro chord sheet
   * @returns {Song} The parsed song
   */ parse(chordProChordSheet) {
        return this.parseWithParser(chordProChordSheet, (0, $182dbf639c88db75$export$98e6a39c04603d36));
    }
}
var $8e2b91641771a21c$export$2e2bcd8739ae039 = $8e2b91641771a21c$var$ChordProParser;




const $9c17b505581d81bb$var$WHITE_SPACE = /\s/;
const $9c17b505581d81bb$var$CHORD_LINE_REGEX = /^\s*((([A-G])(#|b)?([^/\s]*)(\/([A-G])(#|b)?)?)(\s|$)+)+(\s|$)+/;
/**
 * Parses a normal chord sheet
 *
 * ChordSheetParser is deprecated, please use ChordsOverWordsParser.
 *
 * ChordsOverWordsParser aims to support any kind of chord, whereas ChordSheetParser lacks
 * support for many variations. Besides that, some chordpro feature have been ported back
 * to ChordsOverWordsParser, which adds some interesting functionality.
 */ class $9c17b505581d81bb$var$ChordSheetParser {
    processingText = true;
    preserveWhitespace = true;
    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();
    songLine = null;
    chordLyricsPair = null;
    lines = [];
    currentLine = 0;
    lineCount = 0;
    /**
   * Instantiate a chord sheet parser
   * ChordSheetParser is deprecated, please use ChordsOverWordsParser.
   * @param {Object} [options={}] options
   * @param {boolean} [options.preserveWhitespace=true] whether to preserve trailing whitespace for chords
   * @deprecated
   */ constructor({ preserveWhitespace: preserveWhitespace = true  } = {}){
        (0, $974bd1d260bb1d53$export$b680e6b2c82f8c2f)(`ChordSheetParser is deprecated, please use ChordsOverWordsParser. 

ChordsOverWordsParser aims to support any kind of chord, whereas ChordSheetParser lacks 
support for many variations. Besides that, some chordpro feature have been ported back 
to ChordsOverWordsParser, which adds some interesting functionality.`);
        this.preserveWhitespace = preserveWhitespace;
    }
    /**
   * Parses a chord sheet into a song
   * @param {string} chordSheet The ChordPro chord sheet
   * @param {Object} [options={}] Optional parser options
   * @param {Song} [options.song=null] The {@link Song} to store the song data in
   * @returns {Song} The parsed song
   */ parse(chordSheet, { song: song  } = {}) {
        this.initialize(chordSheet, song);
        while(this.hasNextLine()){
            const line = this.readLine();
            this.parseLine(line);
        }
        this.endOfSong();
        return this.song;
    }
    endOfSong() {}
    parseLine(line) {
        this.songLine = this.song.addLine();
        if (line.trim().length === 0) this.chordLyricsPair = null;
        else this.parseNonEmptyLine(line);
    }
    parseNonEmptyLine(line) {
        if (!this.songLine) throw new Error("Expected this.songLine to be present");
        this.chordLyricsPair = this.songLine.addChordLyricsPair();
        if ($9c17b505581d81bb$var$CHORD_LINE_REGEX.test(line) && this.hasNextLine()) {
            const nextLine = this.readLine();
            this.parseLyricsWithChords(line, nextLine);
        } else this.chordLyricsPair.lyrics = `${line}`;
    }
    initialize(document, song = null) {
        if (song) this.song = song;
        this.lines = (0, $974bd1d260bb1d53$export$ba13e0e2f19e61a1)(document).split("\n");
        this.currentLine = 0;
        this.lineCount = this.lines.length;
        this.processingText = true;
    }
    readLine() {
        const line = this.lines[this.currentLine];
        this.currentLine += 1;
        return line;
    }
    hasNextLine() {
        return this.currentLine < this.lineCount;
    }
    parseLyricsWithChords(chordsLine, lyricsLine) {
        this.processCharacters(chordsLine, lyricsLine);
        if (!this.chordLyricsPair) throw new Error("Expected this.chordLyricsPair to be present");
        this.chordLyricsPair.lyrics += lyricsLine.substring(chordsLine.length);
        this.chordLyricsPair.chords = this.chordLyricsPair.chords.trim();
        if (this.chordLyricsPair.lyrics) this.chordLyricsPair.lyrics = this.chordLyricsPair.lyrics.trim();
        if (!lyricsLine.trim().length) this.songLine = this.song.addLine();
    }
    processCharacters(chordsLine, lyricsLine) {
        for(let c = 0, charCount = chordsLine.length; c < charCount; c += 1){
            const chr = chordsLine[c];
            const nextChar = chordsLine[c + 1];
            const isWhiteSpace = $9c17b505581d81bb$var$WHITE_SPACE.test(chr);
            this.addCharacter(chr, nextChar);
            if (!this.chordLyricsPair) throw new Error("Expected this.chordLyricsPair to be present");
            this.chordLyricsPair.lyrics += lyricsLine[c] || "";
            this.processingText = !isWhiteSpace;
        }
    }
    addCharacter(chr, nextChar) {
        const isWhiteSpace = $9c17b505581d81bb$var$WHITE_SPACE.test(chr);
        if (!isWhiteSpace) this.ensureChordLyricsPairInitialized();
        if (!isWhiteSpace || this.shouldAddCharacterToChords(nextChar)) {
            if (!this.chordLyricsPair) throw new Error("Expected this.chordLyricsPair to be present");
            this.chordLyricsPair.chords += chr;
        }
    }
    shouldAddCharacterToChords(nextChar) {
        return nextChar && $9c17b505581d81bb$var$WHITE_SPACE.test(nextChar) && this.preserveWhitespace;
    }
    ensureChordLyricsPairInitialized() {
        if (!this.processingText) {
            if (!this.songLine) throw new Error("Expected this.songLine to be present");
            this.chordLyricsPair = this.songLine.addChordLyricsPair();
            this.processingText = true;
        }
    }
}
var $9c17b505581d81bb$export$2e2bcd8739ae039 = $9c17b505581d81bb$var$ChordSheetParser;




// Generated by peggy v. 2.0.1 (ts-pegjs plugin v. 3.0.0 )
//
// https://peggyjs.org/   https://github.com/metadevpro/ts-pegjs
"use strict";
function $524984546aa7a02b$var$peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
class $524984546aa7a02b$export$628c65c376ead699 extends Error {
    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch));
        }
        function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, (ch)=>"\\x0" + hex(ch)).replace(/[\x10-\x1F\x7F-\x9F]/g, (ch)=>"\\x" + hex(ch));
        }
        function describeExpectation(expectation) {
            switch(expectation.type){
                case "literal":
                    return '"' + literalEscape(expectation.text) + '"';
                case "class":
                    const escapedParts = expectation.parts.map((part)=>{
                        return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            const descriptions = expected1.map(describeExpectation);
            let i;
            let j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
                descriptions.length = j;
            }
            switch(descriptions.length){
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
    constructor(message, expected, found, location){
        super();
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "PeggySyntaxError";
        if (typeof Object.setPrototypeOf === "function") Object.setPrototypeOf(this, $524984546aa7a02b$export$628c65c376ead699.prototype);
        else this.__proto__ = $524984546aa7a02b$export$628c65c376ead699.prototype;
        if (typeof Error.captureStackTrace === "function") Error.captureStackTrace(this, $524984546aa7a02b$export$628c65c376ead699);
    }
    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            let k;
            for(k = 0; k < sources.length; k++)if (sources[k].grammarSource === this.location.source) {
                src = sources[k].text.split(/\r\n|\n|\r/g);
                break;
            }
            let s = this.location.start;
            let loc = this.location.source + ":" + s.line + ":" + s.column;
            if (src) {
                let e = this.location.end;
                let filler = $524984546aa7a02b$var$peg$padEnd("", s.line.toString().length, " ");
                let line = src[s.line - 1];
                let last = s.line === e.line ? e.column : line.length + 1;
                str += "\n --> " + loc + "\n" + filler + " |\n" + s.line + " | " + line + "\n" + filler + " | " + $524984546aa7a02b$var$peg$padEnd("", s.column - 1, " ") + $524984546aa7a02b$var$peg$padEnd("", last - s.column, "^");
            } else str += "\n at " + loc;
        }
        return str;
    }
}
function $524984546aa7a02b$var$peg$parse(input, options) {
    options = options !== undefined ? options : {};
    const peg$FAILED = {};
    const peg$source = options.grammarSource;
    const peg$startRuleFunctions = {
        ChordSheet: peg$parseChordSheet
    };
    let peg$startRuleFunction = peg$parseChordSheet;
    const peg$c0 = function(metadataLines, lines) {
        return {
            type: "chordSheet",
            lines: [
                ...metadataLines,
                ...lines
            ]
        };
    };
    const peg$c1 = function(newLine, items, trailingItem) {
        const hasEmptyLine = newLine?.length > 0;
        const emptyLines = hasEmptyLine ? [
            {
                type: "line",
                items: []
            }
        ] : [];
        return [
            ...emptyLines,
            ...items,
            trailingItem
        ];
    };
    const peg$c2 = function(item) {
        return item;
    };
    const peg$c3 = function(item) {
        if (item.type === "chordsLine") return {
            type: "line",
            items: item.items.map((item)=>{
                const chordLyricsPair = {
                    type: "chordLyricsPair"
                };
                if (item.type === "chord") return {
                    ...chordLyricsPair,
                    chord: item
                };
                return {
                    ...chordLyricsPair,
                    chords: item.value
                };
            })
        };
        return item;
    };
    const peg$c4 = function(chordsLine, lyrics) {
        const chords = chordsLine.items;
        const chordLyricsPairs = chords.map((chord, i)=>{
            const nextChord = chords[i + 1];
            const start = chord.column - 1;
            const end = nextChord ? nextChord.column - 1 : lyrics.length;
            const pairLyrics = lyrics.substring(start, end);
            const result = /(\s+)(\S+)/.exec(pairLyrics);
            const secondWordPosition = result ? result.index + result[1].length : null;
            const chordData = chord.type === "chord" ? {
                chord: chord
            } : {
                chords: chord.value
            };
            if (secondWordPosition && secondWordPosition < end) return [
                {
                    type: "chordLyricsPair",
                    ...chordData,
                    lyrics: pairLyrics.substring(0, secondWordPosition)
                },
                {
                    type: "chordLyricsPair",
                    chords: "",
                    lyrics: pairLyrics.substring(secondWordPosition)
                }
            ];
            return {
                type: "chordLyricsPair",
                ...chordData,
                lyrics: pairLyrics
            };
        }).flat();
        const firstChord = chords[0];
        if (firstChord && firstChord.column > 1) {
            const firstChordPosition = firstChord.column;
            if (firstChordPosition > 0) chordLyricsPairs.unshift({
                type: "chordLyricsPair",
                chords: "",
                lyrics: lyrics.substring(0, firstChordPosition - 1)
            });
        }
        return {
            type: "line",
            items: chordLyricsPairs
        };
    };
    const peg$c5 = function(items) {
        return {
            type: "chordsLine",
            items: items
        };
    };
    const peg$c6 = function(symbol) {
        return symbol;
    };
    const peg$c7 = "/";
    const peg$c8 = peg$literalExpectation("/", false);
    const peg$c9 = "|";
    const peg$c10 = peg$literalExpectation("|", false);
    const peg$c11 = "-";
    const peg$c12 = peg$literalExpectation("-", false);
    const peg$c13 = function(symbol) {
        return {
            type: "symbol",
            value: symbol,
            column: location().start.column
        };
    };
    const peg$c14 = function(lyrics) {
        if (lyrics.length === 0) return {
            type: "line",
            items: []
        };
        return {
            type: "line",
            items: [
                {
                    type: "chordLyricsPair",
                    chords: "",
                    lyrics: lyrics
                }
            ]
        };
    };
    const peg$c15 = function(chord) {
        return chord;
    };
    const peg$c16 = function(line) {
        return {
            type: "line",
            items: [
                {
                    type: "tag",
                    name: "comment",
                    value: line
                }
            ]
        };
    };
    const peg$c17 = "verse";
    const peg$c18 = peg$literalExpectation("verse", true);
    const peg$c19 = "chorus";
    const peg$c20 = peg$literalExpectation("chorus", true);
    const peg$c21 = "bridge";
    const peg$c22 = peg$literalExpectation("bridge", true);
    const peg$c23 = "tag";
    const peg$c24 = peg$literalExpectation("tag", true);
    const peg$c25 = "interlude";
    const peg$c26 = peg$literalExpectation("interlude", true);
    const peg$c27 = "instrumental";
    const peg$c28 = peg$literalExpectation("instrumental", true);
    const peg$c29 = "intro";
    const peg$c30 = peg$literalExpectation("intro", true);
    const peg$c31 = /^[^\n\r]/;
    const peg$c32 = peg$classExpectation([
        "\n",
        "\r"
    ], true, false);
    const peg$c33 = function(pairs, trailingPair) {
        return [
            ...pairs,
            trailingPair
        ].filter((x)=>x).map(([key, value])=>({
                type: "line",
                items: [
                    {
                        type: "tag",
                        name: key,
                        value: value
                    }
                ]
            }));
    };
    const peg$c34 = function(key, value) {
        return {
            type: "line",
            items: [
                {
                    type: "tag",
                    name: key,
                    value: value
                }
            ]
        };
    };
    const peg$c35 = function(pair) {
        return pair;
    };
    const peg$c36 = "{";
    const peg$c37 = peg$literalExpectation("{", false);
    const peg$c38 = "}";
    const peg$c39 = peg$literalExpectation("}", false);
    const peg$c40 = function(pair) {
        return pair;
    };
    const peg$c41 = function(key, value) {
        return [
            key,
            value
        ];
    };
    const peg$c42 = ":";
    const peg$c43 = peg$literalExpectation(":", false);
    const peg$c44 = /^[a-zA-Z0-9\-_]/;
    const peg$c45 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "A",
            "Z"
        ],
        [
            "0",
            "9"
        ],
        "-",
        "_"
    ], false, false);
    const peg$c46 = /^[^\n\r}]/;
    const peg$c47 = peg$classExpectation([
        "\n",
        "\r",
        "}"
    ], true, false);
    const peg$c48 = "---";
    const peg$c49 = peg$literalExpectation("---", false);
    const peg$c50 = peg$otherExpectation("whitespace");
    const peg$c51 = /^[ \t]/;
    const peg$c52 = peg$classExpectation([
        " ",
        "	"
    ], false, false);
    const peg$c53 = "\n";
    const peg$c54 = peg$literalExpectation("\n", false);
    const peg$c55 = "\r";
    const peg$c56 = peg$literalExpectation("\r", false);
    const peg$c57 = function(chord) {
        return {
            type: "chord",
            ...chord,
            column: location().start.column
        };
    };
    const peg$c58 = "#";
    const peg$c59 = peg$literalExpectation("#", false);
    const peg$c60 = "b";
    const peg$c61 = peg$literalExpectation("b", false);
    const peg$c62 = /^[a-zA-Z0-9()#+]/;
    const peg$c63 = peg$classExpectation([
        [
            "a",
            "z"
        ],
        [
            "A",
            "Z"
        ],
        [
            "0",
            "9"
        ],
        "(",
        ")",
        "#",
        "+"
    ], false, false);
    const peg$c64 = function(root, modifier, suffix, bass) {
        return {
            base: root,
            modifier: modifier,
            suffix: suffix,
            ...bass,
            chordType: "symbol"
        };
    };
    const peg$c65 = /^[A-Ga-g]/;
    const peg$c66 = peg$classExpectation([
        [
            "A",
            "G"
        ],
        [
            "a",
            "g"
        ]
    ], false, false);
    const peg$c67 = function(root, modifier) {
        return {
            bassBase: root,
            bassModifier: modifier
        };
    };
    const peg$c68 = function(modifier, root, suffix, bass) {
        return {
            base: root,
            modifier: modifier,
            suffix: suffix,
            ...bass,
            chordType: "numeral"
        };
    };
    const peg$c69 = "III";
    const peg$c70 = peg$literalExpectation("III", false);
    const peg$c71 = "iii";
    const peg$c72 = peg$literalExpectation("iii", false);
    const peg$c73 = "VII";
    const peg$c74 = peg$literalExpectation("VII", false);
    const peg$c75 = "vii";
    const peg$c76 = peg$literalExpectation("vii", false);
    const peg$c77 = "II";
    const peg$c78 = peg$literalExpectation("II", false);
    const peg$c79 = "ii";
    const peg$c80 = peg$literalExpectation("ii", false);
    const peg$c81 = "IV";
    const peg$c82 = peg$literalExpectation("IV", false);
    const peg$c83 = "iv";
    const peg$c84 = peg$literalExpectation("iv", false);
    const peg$c85 = "VI";
    const peg$c86 = peg$literalExpectation("VI", false);
    const peg$c87 = "vi";
    const peg$c88 = peg$literalExpectation("vi", false);
    const peg$c89 = "I";
    const peg$c90 = peg$literalExpectation("I", false);
    const peg$c91 = "i";
    const peg$c92 = peg$literalExpectation("i", false);
    const peg$c93 = "V";
    const peg$c94 = peg$literalExpectation("V", false);
    const peg$c95 = "v";
    const peg$c96 = peg$literalExpectation("v", false);
    const peg$c97 = function(modifier, root) {
        return {
            bassBase: root,
            bassModifier: modifier
        };
    };
    const peg$c98 = function(modifier, root, suffix, bass) {
        return {
            base: root,
            modifier: modifier,
            suffix: suffix,
            ...bass,
            chordType: "numeric"
        };
    };
    const peg$c99 = /^[1-7]/;
    const peg$c100 = peg$classExpectation([
        [
            "1",
            "7"
        ]
    ], false, false);
    let peg$currPos = 0;
    let peg$savedPos = 0;
    const peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    let peg$maxFailPos = 0;
    let peg$maxFailExpected = [];
    let peg$silentFails = 0;
    let peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return {
            type: "literal",
            text: text1,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);
        return {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new $524984546aa7a02b$export$628c65c376ead699(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new $524984546aa7a02b$export$628c65c376ead699($524984546aa7a02b$export$628c65c376ead699.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$parseChordSheet() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseMetadata();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordSheetContents();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s1, s2);
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordSheetContents() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseNewLine();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseChordSheetItemWithNewLine();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parseChordSheetItemWithNewLine();
            }
            if (s2 !== peg$FAILED) {
                s3 = peg$parseChordSheetItem();
                if (s3 === peg$FAILED) s3 = null;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c1(s1, s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordSheetItemWithNewLine() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseChordSheetItem();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNewLine();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c2(s1);
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordSheetItem() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseDirectionLine();
        if (s1 === peg$FAILED) {
            s1 = peg$parseInlineMetadata();
            if (s1 === peg$FAILED) {
                s1 = peg$parseChordLyricsLines();
                if (s1 === peg$FAILED) {
                    s1 = peg$parseChordsLine();
                    if (s1 === peg$FAILED) s1 = peg$parseLyricsLine();
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c3(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseChordLyricsLines() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseChordsLine();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNewLine();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseNonEmptyLyrics();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c4(s1, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordsLine() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseRhythmSymbolWithSpacing();
        if (s2 === peg$FAILED) s2 = peg$parseChordWithSpacing();
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseRhythmSymbolWithSpacing();
            if (s2 === peg$FAILED) s2 = peg$parseChordWithSpacing();
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseRhythmSymbolWithSpacing() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseRhythmSymbol();
            if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c6(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseRhythmSymbol() {
        let s0, s1;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c7;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c8);
        }
        if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
                s1 = peg$c9;
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c10);
            }
            if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 45) {
                    s1 = peg$c11;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c12);
                }
            }
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c13(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseLyricsLine() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseLyrics();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c14(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseLyrics() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseWordChar();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseWordChar();
        }
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        return s0;
    }
    function peg$parseNonEmptyLyrics() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseWordChar();
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseWordChar();
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) s0 = input.substring(s0, peg$currPos);
        else s0 = s1;
        return s0;
    }
    function peg$parseChordWithSpacing() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChord();
            if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseDirectionLine() {
        let s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
            s4 = peg$parseKeyword();
            if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parseWordChar();
                    while(s7 !== peg$FAILED){
                        s6.push(s7);
                        s7 = peg$parseWordChar();
                    }
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parse_();
                        if (s7 !== peg$FAILED) {
                            s3 = [
                                s3,
                                s4,
                                s5,
                                s6,
                                s7
                            ];
                            s2 = s3;
                        } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c16(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseKeyword() {
        let s0;
        if (input.substr(peg$currPos, 5).toLowerCase() === peg$c17) {
            s0 = input.substr(peg$currPos, 5);
            peg$currPos += 5;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c18);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 6).toLowerCase() === peg$c19) {
                s0 = input.substr(peg$currPos, 6);
                peg$currPos += 6;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c20);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 6).toLowerCase() === peg$c21) {
                    s0 = input.substr(peg$currPos, 6);
                    peg$currPos += 6;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c22);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3).toLowerCase() === peg$c23) {
                        s0 = input.substr(peg$currPos, 3);
                        peg$currPos += 3;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c24);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 9).toLowerCase() === peg$c25) {
                            s0 = input.substr(peg$currPos, 9);
                            peg$currPos += 9;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c26);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 12).toLowerCase() === peg$c27) {
                                s0 = input.substr(peg$currPos, 12);
                                peg$currPos += 12;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c28);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 5).toLowerCase() === peg$c29) {
                                    s0 = input.substr(peg$currPos, 5);
                                    peg$currPos += 5;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c30);
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseWordChar() {
        let s0;
        if (peg$c31.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c32);
        }
        return s0;
    }
    function peg$parseMetadata() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parseMetadataPairWithNewLine();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parseMetadataPairWithNewLine();
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseMetadataPair();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$parseMetadataSeparator();
                if (s3 === peg$FAILED) s3 = null;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c33(s1, s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseInlineMetadata() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseMetadataKey();
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseColon();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseMetadataValue();
                        if (s6 !== peg$FAILED) s5 = input.substring(s5, peg$currPos);
                        else s5 = s6;
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c34(s1, s5);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetadataPairWithNewLine() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseMetadataPair();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNewLine();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c35(s1);
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetadataPair() {
        let s0;
        s0 = peg$parseMetadataPairWithBrackets();
        if (s0 === peg$FAILED) s0 = peg$parseMetadataPairWithoutBrackets();
        return s0;
    }
    function peg$parseMetadataPairWithBrackets() {
        let s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c36;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c37);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseMetadataPairWithoutBrackets();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                            s5 = peg$c38;
                            peg$currPos++;
                        } else {
                            s5 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c39);
                        }
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c40(s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseMetadataPairWithoutBrackets() {
        let s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseMetadataKey();
        if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
        else s1 = s2;
        if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseColon();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parse_();
                    if (s4 !== peg$FAILED) {
                        s5 = peg$currPos;
                        s6 = peg$parseMetadataValue();
                        if (s6 !== peg$FAILED) s5 = input.substring(s5, peg$currPos);
                        else s5 = s6;
                        if (s5 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c41(s1, s5);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseColon() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 58) {
            s0 = peg$c42;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c43);
        }
        return s0;
    }
    function peg$parseMetadataKey() {
        let s0, s1;
        s0 = [];
        if (peg$c44.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c45);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c44.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c45);
            }
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parseMetadataValue() {
        let s0, s1;
        s0 = [];
        if (peg$c46.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c47);
        }
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c46.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c47);
            }
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parseMetadataSeparator() {
        let s0, s1, s2;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 3) === peg$c48) {
            s1 = peg$c48;
            peg$currPos += 3;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c49);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNewLine();
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parse_() {
        let s0, s1;
        peg$silentFails++;
        s0 = [];
        if (peg$c51.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c52);
        }
        while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c51.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c52);
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c50);
        }
        return s0;
    }
    function peg$parseNewLine() {
        let s0;
        s0 = peg$parseCarriageReturn();
        if (s0 === peg$FAILED) {
            s0 = peg$parseLineFeed();
            if (s0 === peg$FAILED) s0 = peg$parseCarriageReturnLineFeed();
        }
        return s0;
    }
    function peg$parseCarriageReturnLineFeed() {
        let s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseCarriageReturn();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseLineFeed();
            if (s2 !== peg$FAILED) {
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseLineFeed() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 10) {
            s0 = peg$c53;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c54);
        }
        return s0;
    }
    function peg$parseCarriageReturn() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c55;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c56);
        }
        return s0;
    }
    function peg$parseChord() {
        let s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseNumeral();
        if (s1 === peg$FAILED) {
            s1 = peg$parseNumeric();
            if (s1 === peg$FAILED) s1 = peg$parseChordSymbol();
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c57(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parseChordModifier() {
        let s0;
        if (input.charCodeAt(peg$currPos) === 35) {
            s0 = peg$c58;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c59);
        }
        if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 98) {
                s0 = peg$c60;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c61);
            }
        }
        return s0;
    }
    function peg$parseChordSuffix() {
        let s0, s1;
        s0 = [];
        if (peg$c62.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c63);
        }
        while(s1 !== peg$FAILED){
            s0.push(s1);
            if (peg$c62.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c63);
            }
        }
        return s0;
    }
    function peg$parseChordSymbol() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseChordSymbolRoot();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordModifier();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseChordSuffix();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseChordSymbolBass();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c64(s1, s2, s3, s4);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseChordSymbolRoot() {
        let s0;
        if (peg$c65.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c66);
        }
        return s0;
    }
    function peg$parseChordSymbolBass() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c7;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c8);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordSymbolRoot();
            if (s2 !== peg$FAILED) {
                s3 = peg$parseChordModifier();
                if (s3 === peg$FAILED) s3 = null;
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c67(s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumeral() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseChordModifier();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNumeralRoot();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseChordSuffix();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseNumeralBass();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c68(s1, s2, s3, s4);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumeralRoot() {
        let s0;
        if (input.substr(peg$currPos, 3) === peg$c69) {
            s0 = peg$c69;
            peg$currPos += 3;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c70);
        }
        if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 3) === peg$c71) {
                s0 = peg$c71;
                peg$currPos += 3;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c72);
            }
            if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c73) {
                    s0 = peg$c73;
                    peg$currPos += 3;
                } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c74);
                }
                if (s0 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c75) {
                        s0 = peg$c75;
                        peg$currPos += 3;
                    } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c76);
                    }
                    if (s0 === peg$FAILED) {
                        if (input.substr(peg$currPos, 2) === peg$c77) {
                            s0 = peg$c77;
                            peg$currPos += 2;
                        } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c78);
                        }
                        if (s0 === peg$FAILED) {
                            if (input.substr(peg$currPos, 2) === peg$c79) {
                                s0 = peg$c79;
                                peg$currPos += 2;
                            } else {
                                s0 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c80);
                            }
                            if (s0 === peg$FAILED) {
                                if (input.substr(peg$currPos, 2) === peg$c81) {
                                    s0 = peg$c81;
                                    peg$currPos += 2;
                                } else {
                                    s0 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c82);
                                }
                                if (s0 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 2) === peg$c83) {
                                        s0 = peg$c83;
                                        peg$currPos += 2;
                                    } else {
                                        s0 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$c84);
                                    }
                                    if (s0 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 2) === peg$c85) {
                                            s0 = peg$c85;
                                            peg$currPos += 2;
                                        } else {
                                            s0 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$c86);
                                        }
                                        if (s0 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 2) === peg$c87) {
                                                s0 = peg$c87;
                                                peg$currPos += 2;
                                            } else {
                                                s0 = peg$FAILED;
                                                if (peg$silentFails === 0) peg$fail(peg$c88);
                                            }
                                            if (s0 === peg$FAILED) {
                                                if (input.charCodeAt(peg$currPos) === 73) {
                                                    s0 = peg$c89;
                                                    peg$currPos++;
                                                } else {
                                                    s0 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$c90);
                                                }
                                                if (s0 === peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 105) {
                                                        s0 = peg$c91;
                                                        peg$currPos++;
                                                    } else {
                                                        s0 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$c92);
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 86) {
                                                            s0 = peg$c93;
                                                            peg$currPos++;
                                                        } else {
                                                            s0 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$c94);
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                            if (input.charCodeAt(peg$currPos) === 118) {
                                                                s0 = peg$c95;
                                                                peg$currPos++;
                                                            } else {
                                                                s0 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$c96);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return s0;
    }
    function peg$parseNumeralBass() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c7;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c8);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordModifier();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$parseNumeralRoot();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c97(s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumeric() {
        let s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseChordModifier();
        if (s1 === peg$FAILED) s1 = null;
        if (s1 !== peg$FAILED) {
            s2 = peg$parseNumericRoot();
            if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$parseChordSuffix();
                if (s4 !== peg$FAILED) s3 = input.substring(s3, peg$currPos);
                else s3 = s4;
                if (s3 !== peg$FAILED) {
                    s4 = peg$parseNumericBass();
                    if (s4 === peg$FAILED) s4 = null;
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c98(s1, s2, s3, s4);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseNumericRoot() {
        let s0;
        if (peg$c99.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c100);
        }
        return s0;
    }
    function peg$parseNumericBass() {
        let s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c7;
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$c8);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parseChordModifier();
            if (s2 === peg$FAILED) s2 = null;
            if (s2 !== peg$FAILED) {
                s3 = peg$parseNumericRoot();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c97(s2, s3);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
const $524984546aa7a02b$export$98e6a39c04603d36 = $524984546aa7a02b$var$peg$parse;


/**
 * Parses a chords over words sheet into a song
 *
 * It support "regular" chord sheets:
 *
 *            Am         C/G        F          C
 *     Let it be, let it be, let it be, let it be
 *     C                G              F  C/E Dm C
 *     Whisper words of wisdom, let it be
 *
 * Additionally, some chordpro features have been "ported back". For example, you can use chordpro directives:
 *
 *     {title: Let it be}
 *     {key: C}
 *     Chorus 1:
 *            Am
 *     Let it be
 *
 * For convenience, you can leave out the brackets:
 *
 *     title: Let it be
 *     Chorus 1:
 *            Am
 *     Let it be
 *
 * You can even use a markdown style frontmatter separator to separate the header from the song:
 *
 *     title: Let it be
 *     key: C
 *     ---
 *     Chorus 1:
 *            Am         C/G        F          C
 *     Let it be, let it be, let it be, let it be
 *     C                G              F  C/E Dm C
 *     Whisper words of wisdom, let it be
 *
 * `ChordsOverWordsParser` is the better version of `ChordSheetParser`, which is deprecated.
 */ class $b72f5288e28a9b64$var$ChordsOverWordsParser extends (0, $3e6b6f33997c81b2$export$2e2bcd8739ae039) {
    /**
   * Parses a chords over words sheet into a song
   * @param {string} chordsOverWordsSheet the chords over words sheet
   * @returns {Song} The parsed song
   */ parse(chordsOverWordsSheet) {
        return this.parseWithParser(chordsOverWordsSheet, (0, $524984546aa7a02b$export$98e6a39c04603d36));
    }
}
var $b72f5288e28a9b64$export$2e2bcd8739ae039 = $b72f5288e28a9b64$var$ChordsOverWordsParser;






/**
 * Acts as a base class for HTML formatters
 */ class $9ba0fb9ec815efc8$var$HtmlFormatter extends (0, $2dfa852662754780$export$2e2bcd8739ae039) {
    /**
   * Formats a song into HTML.
   * @param {Song} song The song to be formatted
   * @returns {string} The HTML string
   */ format(song) {
        const { bodyParagraphs: bodyParagraphs , expandedBodyParagraphs: expandedBodyParagraphs  } = song;
        return this.template({
            song: song,
            configuration: this.configuration,
            bodyParagraphs: this.configuration.expandChorusDirective ? expandedBodyParagraphs : bodyParagraphs
        });
    }
    /**
   * Generates basic CSS, optionally scoped within the provided selector, to use with the HTML output
   * @deprecated
   */ static cssString(_scope = "") {
        (0, $974bd1d260bb1d53$export$c73e2a74b163f89e)("The class method cssString() was removed in favor of the instance PROPERTY. Please use `new <Formatter>().cssString` instead.");
    }
    /**
   * Generates basic CSS, optionally scoped within the provided selector, to use with the HTML output
   *
   * For example, execute cssString('.chordSheetViewer') will result in CSS like:
   *
   *     .chordSheetViewer .paragraph {
   *       margin-bottom: 1em;
   *     }
   *
   * @param scope the CSS scope to use, for example `.chordSheetViewer`
   * @returns {string} the CSS string
   */ cssString(scope = "") {
        return (0, $974bd1d260bb1d53$export$59d377d2a2e0150a)(this.defaultCss, scope);
    }
    /**
   * Basic CSS, in object style à la useStyles, to use with the HTML output
   * @deprecated
   */ static cssObject() {
        (0, $974bd1d260bb1d53$export$c73e2a74b163f89e)("The class method cssObject() was removed in favor of the instance PROPERTY. Please use `new <Formatter>().cssObject` instead.");
    }
    /**
   * Basic CSS, in object style à la useStyles, to use with the HTML output
   * For a CSS string see {@link cssString}
   *
   * Example:
   *
   *     '.paragraph': {
   *       marginBottom: '1em'
   *     }
   *
   * @return {Object.<string, Object.<string, string>>} the CSS object
   */ get cssObject() {
        return this.defaultCss;
    }
}
var $9ba0fb9ec815efc8$export$2e2bcd8739ae039 = $9ba0fb9ec815efc8$var$HtmlFormatter;




const $a181433de674b2b2$export$1e6f8e38ccd793b = [
    "A",
    "Bb",
    "B",
    "C",
    "C#",
    "Db",
    "D",
    "Eb",
    "E",
    "F",
    "F#",
    "Gb",
    "G",
    "G#",
    "Ab"
];
const $a181433de674b2b2$export$24a0bd6af7756225 = [
    "F#m",
    "Gm",
    "G#m",
    "Am",
    "Bbm",
    "Bm",
    "Cm",
    "C#m",
    "Dm",
    "D#m",
    "Ebm",
    "Em",
    "Fm"
];
const $a181433de674b2b2$export$1ba61c6fa2f892a9 = {
    Bb: {
        1: "A",
        3: "G",
        6: "E",
        8: "D",
        10: "C"
    },
    D: {
        2: "C",
        5: "A",
        7: "G",
        10: "E"
    },
    Eb: {
        1: "D",
        3: "C",
        6: "A",
        8: "G"
    },
    Db: {
        1: "C",
        4: "A",
        6: "G",
        9: "E"
    },
    "C#": {
        1: "C",
        4: "A",
        6: "G",
        9: "E"
    },
    E: {
        2: "D",
        4: "C",
        7: "A",
        9: "G"
    },
    F: {
        1: "E",
        3: "D",
        5: "C",
        6: "B",
        8: "A",
        10: "G"
    },
    "F#": {
        2: "E",
        4: "D",
        6: "C",
        7: "B",
        9: "A"
    },
    Gb: {
        2: "E",
        4: "D",
        6: "C",
        7: "B",
        9: "A"
    },
    G: {
        3: "E",
        5: "D",
        7: "C",
        8: "B",
        10: "A"
    },
    "G#": {
        1: "G",
        4: "E",
        6: "D",
        8: "C"
    },
    Ab: {
        1: "G",
        4: "E",
        6: "D",
        8: "C"
    },
    A: {
        2: "G",
        5: "E",
        7: "D",
        9: "C"
    },
    B: {
        2: "A",
        4: "G",
        7: "E",
        9: "D"
    },
    C: {
        3: "A",
        5: "G",
        8: "E",
        10: "D"
    },
    Am: {
        3: "F#m",
        5: "Em",
        7: "Dm"
    },
    Bbm: {
        1: "Am",
        4: "F#m",
        6: "Em",
        8: "Dm"
    },
    Bm: {
        2: "Am",
        5: "F#m",
        7: "Em"
    },
    Cm: {
        1: "Bm",
        3: "Am",
        6: "F#m",
        8: "Em"
    },
    "C#m": {
        2: "Bm",
        4: "Am",
        7: "F#m",
        9: "Em"
    },
    Dm: {
        3: "Bm",
        5: "Am",
        8: "F#m"
    },
    Ebm: {
        1: "Dm",
        4: "Bm",
        6: "Am"
    },
    "D#m": {
        1: "Dm",
        4: "Bm",
        6: "Am"
    }
};



function $e2e1ea6dd3b7d2e1$export$fd31a53e6281557e(transposeKey, songKey) {
    if (/^\d+$/.test(transposeKey)) return parseInt(transposeKey, 10);
    return (0, $918eb2016ac61e41$export$2e2bcd8739ae039).distance(songKey, transposeKey);
}
function $e2e1ea6dd3b7d2e1$var$chordTransposeDistance(capo, transposeKey, songKey, renderKey) {
    let transpose = -1 * (capo || 0);
    if (songKey) {
        if (transposeKey) transpose += $e2e1ea6dd3b7d2e1$export$fd31a53e6281557e(transposeKey, songKey);
        if (renderKey) transpose += (0, $918eb2016ac61e41$export$2e2bcd8739ae039).distance(songKey, renderKey);
    }
    return transpose;
}
function $e2e1ea6dd3b7d2e1$export$596ec52955da9472(chordString, line, song, { renderKey: renderKey = null , useUnicodeModifier: useUnicodeModifier = false , normalizeChords: normalizeChords = true  } = {}) {
    const chord = (0, $5e3a0c5a6197f95b$export$2e2bcd8739ae039).parse(chordString);
    const songKey = song.key;
    const capo = parseInt(song.metadata.getSingle((0, $b3836272a1374d85$export$866f445d49bad88e)), 10);
    if (!chord) return chordString;
    const effectiveTransposeDistance = $e2e1ea6dd3b7d2e1$var$chordTransposeDistance(capo, line.transposeKey, songKey, renderKey);
    const effectiveKey = renderKey || (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrap(line.key || song.key)?.transpose(effectiveTransposeDistance) || null;
    const transposedChord = chord.transpose(effectiveTransposeDistance);
    const normalizedChord = normalizeChords ? transposedChord.normalize(effectiveKey) : transposedChord;
    return normalizedChord.toString({
        useUnicodeModifier: useUnicodeModifier
    });
}
function $e2e1ea6dd3b7d2e1$export$b07b16221c14aaa(key) {
    return (0, $a181433de674b2b2$export$1ba61c6fa2f892a9)[(0, $918eb2016ac61e41$export$2e2bcd8739ae039).toString(key)];
}
function $e2e1ea6dd3b7d2e1$export$74743eda5dda3ccf(key) {
    const keyObj = (0, $918eb2016ac61e41$export$2e2bcd8739ae039).wrapOrFail(key);
    return keyObj.isMinor() ? (0, $a181433de674b2b2$export$24a0bd6af7756225) : (0, $a181433de674b2b2$export$1e6f8e38ccd793b);
}







const $a2a605be2775ff64$export$17c9e635b932873b = (item)=>item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039);
const $a2a605be2775ff64$export$3db5961874282581 = (line)=>line.items.some((item)=>item.isRenderable());
const $a2a605be2775ff64$export$3bf645f08efe3292 = (item)=>item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039);
const $a2a605be2775ff64$export$3ab01370f5e64ac8 = (item)=>item.name === "comment";
function $a2a605be2775ff64$export$6ea1b0eb82ead3f(string) {
    return string.trim().replace(/(<\/[a-z]+>)\s+(<)/g, "$1$2").replace(/(\n)\s+/g, "");
}
function $a2a605be2775ff64$export$79b2f7037acddd43(collection, callback) {
    return collection.map(callback).join("");
}
function $a2a605be2775ff64$export$a55877ca9db47377(condition, callback) {
    return condition ? callback() : "";
}
function $a2a605be2775ff64$export$fae3166c418e0471(variables, callback) {
    return callback.call(null, variables);
}
const $a2a605be2775ff64$export$b8d631d9200974fa = (line)=>line.items.some((item)=>item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039) && !(0, $974bd1d260bb1d53$export$78d1711480f95c3e)(item.lyrics) || item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.isRenderable() || (0, $974bd1d260bb1d53$export$e3f63561d52b936d)(item));
const $a2a605be2775ff64$export$8a559c16cc3576 = (line)=>{
    const classes = [
        "row"
    ];
    if (!$a2a605be2775ff64$export$3db5961874282581(line)) classes.push("empty-line");
    return classes.join(" ");
};
const $a2a605be2775ff64$export$dcd1550c9709312c = (paragraph)=>{
    const classes = [
        "paragraph"
    ];
    if (paragraph.type !== (0, $234747a9630b4642$export$c5a6fe907430212e) && paragraph.type !== (0, $234747a9630b4642$export$c53d0f541b41b88e)) classes.push(paragraph.type);
    return classes.join(" ");
};
const $a2a605be2775ff64$export$fef61f332f2c0afc = (item, metadata, configuration)=>{
    if (!metadata) throw new Error("cannot evaluate, metadata is null");
    return item.evaluate(metadata, configuration.get("metadata.separator"));
};
function $a2a605be2775ff64$export$ca030c9435779e4b(font) {
    const cssString = font.toCssString();
    if (cssString) return ` style="${cssString}"`;
    return "";
}


var $d6c38f6287712fb1$export$2e2bcd8739ae039 = ({ configuration: configuration , configuration: { key: key  } , song: song , renderBlankLines: renderBlankLines = false , song: { title: title , subtitle: subtitle , metadata: metadata  } , bodyParagraphs: bodyParagraphs  })=>(0, $a2a605be2775ff64$export$6ea1b0eb82ead3f)(`
  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(title, ()=>`<h1>${title}</h1>`)}
  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(subtitle, ()=>`<h2>${subtitle}</h2>`)}
  
  <div class="chord-sheet">
    ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(bodyParagraphs, (paragraph)=>`
      <div class="${(0, $a2a605be2775ff64$export$dcd1550c9709312c)(paragraph)}">
        ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(paragraph.lines, (line)=>`
          ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(renderBlankLines || (0, $a2a605be2775ff64$export$3db5961874282581)(line), ()=>`
            <div class="${(0, $a2a605be2775ff64$export$8a559c16cc3576)(line)}">
              ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(line.items, (item)=>`
                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$17c9e635b932873b)(item), ()=>`
                  <div class="column">
                    <div class="chord"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.chordFont)}>${(0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(item.chords, line, song, {
                            renderKey: key,
                            useUnicodeModifier: configuration.useUnicodeModifiers,
                            normalizeChords: configuration.normalizeChords
                        })}</div>
                    <div class="lyrics"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont)}>${item.lyrics}</div>
                  </div>
                `)}
                
                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3bf645f08efe3292)(item), ()=>`
                  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3ab01370f5e64ac8)(item), ()=>`
                    <div class="comment">${item.value}</div>
                  `)}
                  
                  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(item.hasRenderableLabel(), ()=>`
                    <h3 class="label">${item.value}</h3>
                  `)}
                `)}
                
                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $974bd1d260bb1d53$export$e3f63561d52b936d)(item), ()=>`
                  <div class="column">
                    <div class="chord"></div>
                    <div class="lyrics"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont)}>${(0, $a2a605be2775ff64$export$fef61f332f2c0afc)(item, metadata, configuration)}</div>
                  </div>
                `)}
              `)}
            </div>
          `)}
        `)}
      </div>
    `)}
  </div>
`);



const $de6608cf7e39dfee$export$200cf2de69532aa8 = {
    ".chord:not(:last-child)": {
        paddingRight: "10px"
    },
    ".paragraph": {
        marginBottom: "1em"
    },
    ".row": {
        display: "flex"
    },
    ".chord:after": {
        content: "'\\200b'"
    },
    ".lyrics:after": {
        content: "'\\200b'"
    }
};
function $de6608cf7e39dfee$export$aa5b6043dd05348b(scope) {
    return (0, $974bd1d260bb1d53$export$59d377d2a2e0150a)($de6608cf7e39dfee$export$200cf2de69532aa8, scope);
}
/**
 * Formats a song into HTML. It uses DIVs to align lyrics with chords, which makes it useful for responsive web pages.
 */ class $de6608cf7e39dfee$var$HtmlDivFormatter extends (0, $9ba0fb9ec815efc8$export$2e2bcd8739ae039) {
    get template() {
        return 0, $d6c38f6287712fb1$export$2e2bcd8739ae039;
    }
    get defaultCss() {
        return $de6608cf7e39dfee$export$200cf2de69532aa8;
    }
}
var $de6608cf7e39dfee$export$2e2bcd8739ae039 = $de6608cf7e39dfee$var$HtmlDivFormatter;






var $9940e2d1d4d0b0b9$export$2e2bcd8739ae039 = ({ configuration: configuration , configuration: { key: key  } , song: song , renderBlankLines: renderBlankLines = false , song: { title: title , subtitle: subtitle , bodyLines: bodyLines , metadata: metadata  } , bodyParagraphs: bodyParagraphs  })=>(0, $a2a605be2775ff64$export$6ea1b0eb82ead3f)(`
  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(title, ()=>`<h1>${title}</h1>`)}
  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(subtitle, ()=>`<h2>${subtitle}</h2>`)}

  ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(bodyLines.length > 0, ()=>`
    <div class="chord-sheet">
      ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(bodyParagraphs, (paragraph)=>`
        <div class="${(0, $a2a605be2775ff64$export$dcd1550c9709312c)(paragraph)}">
          ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(paragraph.lines, (line)=>`
            ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(renderBlankLines || (0, $a2a605be2775ff64$export$3db5961874282581)(line), ()=>`
              <table class="${(0, $a2a605be2775ff64$export$8a559c16cc3576)(line)}">
                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $974bd1d260bb1d53$export$d332d76d125f0cbe)(line), ()=>`
                  <tr>
                    ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(line.items, (item)=>`
                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$17c9e635b932873b)(item), ()=>`
                        <td class="chord"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.chordFont)}>${(0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(item.chords, line, song, {
                                    renderKey: key,
                                    useUnicodeModifier: configuration.useUnicodeModifiers,
                                    normalizeChords: configuration.normalizeChords
                                })}</td>
                      `)}
                    `)}
                  </tr>
                `)}
                
                ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$b8d631d9200974fa)(line), ()=>`
                  <tr>
                    ${(0, $a2a605be2775ff64$export$79b2f7037acddd43)(line.items, (item)=>`
                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$17c9e635b932873b)(item), ()=>`
                        <td class="lyrics"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont)}>${item.lyrics}</td>
                      `)}
                      
                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3bf645f08efe3292)(item), ()=>`
                        ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $a2a605be2775ff64$export$3ab01370f5e64ac8)(item), ()=>`
                          <td class="comment"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont)}>${item.value}</td>
                        `)}
                        
                        ${(0, $a2a605be2775ff64$export$a55877ca9db47377)(item.hasRenderableLabel(), ()=>`
                          <td><h3 class="label"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont)}>${item.value}</h3></td>
                        `)}
                      `)}
                      
                      ${(0, $a2a605be2775ff64$export$a55877ca9db47377)((0, $974bd1d260bb1d53$export$e3f63561d52b936d)(item), ()=>`
                        <td class="lyrics"${(0, $a2a605be2775ff64$export$ca030c9435779e4b)(line.textFont)}>${(0, $a2a605be2775ff64$export$fef61f332f2c0afc)(item, metadata, configuration)}</td>
                      `)}
                    `)}
                  </tr>
                `)}
              </table>
            `)}
          `)}
        </div>
      `)}
    </div>
  `)}
`);



const $fdcc84db82790d90$export$200cf2de69532aa8 = {
    h1: {
        fontSize: "1.5em"
    },
    h2: {
        fontSize: "1.1em"
    },
    table: {
        borderSpacing: "0",
        color: "inherit"
    },
    td: {
        padding: "3px 0"
    },
    ".chord:not(:last-child)": {
        paddingRight: "10px"
    },
    ".paragraph": {
        marginBottom: "1em"
    }
};
function $fdcc84db82790d90$export$aa5b6043dd05348b(scope) {
    return (0, $974bd1d260bb1d53$export$59d377d2a2e0150a)($fdcc84db82790d90$export$200cf2de69532aa8, scope);
}
/**
 * Formats a song into HTML. It uses TABLEs to align lyrics with chords, which makes the HTML for things like
 * PDF conversion.
 */ class $fdcc84db82790d90$var$HtmlTableFormatter extends (0, $9ba0fb9ec815efc8$export$2e2bcd8739ae039) {
    get template() {
        return 0, $9940e2d1d4d0b0b9$export$2e2bcd8739ae039;
    }
    get defaultCss() {
        return $fdcc84db82790d90$export$200cf2de69532aa8;
    }
}
var $fdcc84db82790d90$export$2e2bcd8739ae039 = $fdcc84db82790d90$var$HtmlTableFormatter;
















/**
 * Formats a song into a plain text chord sheet
 */ class $06a0261003eb9ba9$var$TextFormatter extends (0, $2dfa852662754780$export$2e2bcd8739ae039) {
    song = new (0, $7860c26c4d50915f$export$2e2bcd8739ae039)();
    /**
   * Formats a song into a plain text chord sheet
   * @param {Song} song The song to be formatted
   * @returns {string} the chord sheet
   */ format(song) {
        this.song = song;
        return [
            this.formatHeader(),
            this.formatParagraphs()
        ].join("");
    }
    formatHeader() {
        const { title: title , subtitle: subtitle  } = this.song;
        const separator = title || subtitle ? "\n" : "";
        return [
            this.formatTitle(title),
            this.formatSubTitle(subtitle),
            separator
        ].join("");
    }
    formatParagraphs() {
        const { bodyParagraphs: bodyParagraphs , expandedBodyParagraphs: expandedBodyParagraphs , metadata: metadata  } = this.song;
        const { expandChorusDirective: expandChorusDirective  } = this.configuration;
        return (expandChorusDirective ? expandedBodyParagraphs : bodyParagraphs).map((paragraph)=>this.formatParagraph(paragraph, metadata)).join("\n\n");
    }
    formatParagraph(paragraph, metadata) {
        return paragraph.lines.filter((line)=>line.hasRenderableItems()).map((line)=>this.formatLine(line, metadata)).join("\n");
    }
    formatLine(line, metadata) {
        const parts = [
            this.formatLineTop(line, metadata),
            this.formatLineBottom(line, metadata)
        ];
        return parts.filter((p)=>!(0, $974bd1d260bb1d53$export$78d1711480f95c3e)(p)).map((part)=>(part || "").trimRight()).join("\n");
    }
    formatTitle(title) {
        if (title) return `${title.toUpperCase()}\n`;
        return "";
    }
    formatSubTitle(subtitle) {
        if (subtitle) return `${subtitle}\n`;
        return "";
    }
    formatLineTop(line, metadata) {
        if ((0, $974bd1d260bb1d53$export$d332d76d125f0cbe)(line)) return this.formatLineWithFormatter(line, this.formatItemTop, metadata);
        return null;
    }
    chordLyricsPairLength(chordLyricsPair, line) {
        const chords = this.renderChords(chordLyricsPair, line);
        const { lyrics: lyrics  } = chordLyricsPair;
        const chordsLength = (chords || "").length;
        const lyricsLength = (lyrics || "").length;
        if (chordsLength >= lyricsLength) return chordsLength + 1;
        return Math.max(chordsLength, lyricsLength);
    }
    renderChords(chordLyricsPair, line) {
        const chords = (0, $e2e1ea6dd3b7d2e1$export$596ec52955da9472)(chordLyricsPair.chords, line, this.song, {
            renderKey: this.configuration.key,
            useUnicodeModifier: this.configuration.useUnicodeModifiers,
            normalizeChords: this.configuration.normalizeChords
        });
        return chords;
    }
    formatItemTop(item, _metadata, line) {
        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.isRenderable()) return item.value || "";
        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) {
            const chords = this.renderChords(item, line);
            return (0, $974bd1d260bb1d53$export$bc3bea8325045070)(chords, this.chordLyricsPairLength(item, line));
        }
        return "";
    }
    formatLineBottom(line, metadata) {
        if ((0, $a2a605be2775ff64$export$b8d631d9200974fa)(line)) return this.formatLineWithFormatter(line, this.formatItemBottom, metadata);
        return "";
    }
    formatLineWithFormatter(line, formatter, metadata) {
        return line.items.map((item)=>formatter.call(this, item, metadata, line)).join("");
    }
    formatItemBottom(item, metadata, line) {
        if (item instanceof (0, $b3836272a1374d85$export$2e2bcd8739ae039) && item.isRenderable()) return item.value || "";
        if (item instanceof (0, $f7a904d05353aafa$export$2e2bcd8739ae039)) return (0, $974bd1d260bb1d53$export$bc3bea8325045070)(item.lyrics || "", this.chordLyricsPairLength(item, line));
        if ("evaluate" in item) return item.evaluate(metadata, this.configuration.get("metadata.separator"));
        return "";
    }
}
var $06a0261003eb9ba9$export$2e2bcd8739ae039 = $06a0261003eb9ba9$var$TextFormatter;





const $7c59209366f6488e$var$VERSE_LINE_REGEX = /^\[Verse.*]/;
const $7c59209366f6488e$var$CHORUS_LINE_REGEX = /^\[Chorus]/;
const $7c59209366f6488e$var$OTHER_METADATA_LINE_REGEX = /^\[([^\]]+)]/;
const $7c59209366f6488e$var$startSectionTags = {
    [(0, $234747a9630b4642$export$4b194284baed1659)]: (0, $b3836272a1374d85$export$deca399f8cd9b7dc),
    [(0, $234747a9630b4642$export$8db6c706fc9142b2)]: (0, $b3836272a1374d85$export$4f5168acae064e01)
};
const $7c59209366f6488e$var$endSectionTags = {
    [(0, $234747a9630b4642$export$4b194284baed1659)]: (0, $b3836272a1374d85$export$640d294ab83f9040),
    [(0, $234747a9630b4642$export$8db6c706fc9142b2)]: (0, $b3836272a1374d85$export$473c1a4819e5180b)
};
/**
 * Parses an Ultimate Guitar chord sheet with metadata
 * Inherits from {@link ChordSheetParser}
 */ class $7c59209366f6488e$var$UltimateGuitarParser extends (0, $9c17b505581d81bb$export$2e2bcd8739ae039) {
    currentSectionType = null;
    parseLine(line) {
        if (this.isSectionEnd()) this.endSection();
        if ($7c59209366f6488e$var$VERSE_LINE_REGEX.test(line)) {
            this.startNewLine();
            this.startSection((0, $234747a9630b4642$export$4b194284baed1659));
        } else if ($7c59209366f6488e$var$CHORUS_LINE_REGEX.test(line)) {
            this.startNewLine();
            this.startSection((0, $234747a9630b4642$export$8db6c706fc9142b2));
        } else if ($7c59209366f6488e$var$OTHER_METADATA_LINE_REGEX.test(line)) this.parseMetadataLine(line);
        else super.parseLine(line);
    }
    parseMetadataLine(line) {
        this.startNewLine();
        this.endSection();
        const comment = line.match($7c59209366f6488e$var$OTHER_METADATA_LINE_REGEX)[1];
        if (!this.songLine) throw new Error("Expected this.songLine to be present");
        this.songLine.addTag(new (0, $b3836272a1374d85$export$2e2bcd8739ae039)((0, $b3836272a1374d85$export$a29989082612d0d9), comment));
    }
    isSectionEnd() {
        return this.songLine !== null && this.songLine.isEmpty() && this.song.previousLine !== null && !this.song.previousLine.isEmpty();
    }
    endOfSong() {
        super.endOfSong();
        if (this.currentSectionType !== null && this.currentSectionType in $7c59209366f6488e$var$endSectionTags) this.startNewLine();
        this.endSection({
            addNewLine: false
        });
    }
    startSection(sectionType) {
        if (this.currentSectionType) this.endSection();
        this.currentSectionType = sectionType;
        this.song.setCurrentProperties(sectionType);
        if (sectionType in $7c59209366f6488e$var$startSectionTags) this.song.addTag(new (0, $b3836272a1374d85$export$2e2bcd8739ae039)($7c59209366f6488e$var$startSectionTags[sectionType]));
    }
    endSection({ addNewLine: addNewLine = true  } = {}) {
        if (this.currentSectionType !== null && this.currentSectionType in $7c59209366f6488e$var$endSectionTags) {
            this.song.addTag(new (0, $b3836272a1374d85$export$2e2bcd8739ae039)($7c59209366f6488e$var$endSectionTags[this.currentSectionType]));
            if (addNewLine) this.startNewLine();
        }
        this.song.setCurrentProperties((0, $234747a9630b4642$export$c53d0f541b41b88e));
        this.currentSectionType = null;
    }
    startNewLine() {
        this.songLine = this.song.addLine();
    }
}
var $7c59209366f6488e$export$2e2bcd8739ae039 = $7c59209366f6488e$var$UltimateGuitarParser;



























var $149c1bd638913645$export$2e2bcd8739ae039 = {
    ChordLyricsPair: $f7a904d05353aafa$export$2e2bcd8739ae039,
    ChordProFormatter: $feb758e68dd351a4$export$2e2bcd8739ae039,
    ChordProParser: $8e2b91641771a21c$export$2e2bcd8739ae039,
    ChordSheetParser: $9c17b505581d81bb$export$2e2bcd8739ae039,
    ChordSheetSerializer: $2a399cf90c614489$export$2e2bcd8739ae039,
    ChordsOverWordsParser: $b72f5288e28a9b64$export$2e2bcd8739ae039,
    Comment: $df4ad73a744c94b3$export$2e2bcd8739ae039,
    Composite: $ba84a02c63f26e83$export$2e2bcd8739ae039,
    HtmlDivFormatter: $de6608cf7e39dfee$export$2e2bcd8739ae039,
    HtmlTableFormatter: $fdcc84db82790d90$export$2e2bcd8739ae039,
    Line: $06eb272065540fc1$export$2e2bcd8739ae039,
    Literal: $758385c5b662d76d$export$2e2bcd8739ae039,
    Metadata: $fdb42fd3b59812d4$export$2e2bcd8739ae039,
    Paragraph: $55861b6d10167265$export$2e2bcd8739ae039,
    Song: $7860c26c4d50915f$export$2e2bcd8739ae039,
    Tag: $b3836272a1374d85$export$2e2bcd8739ae039,
    Ternary: $d6f43bad3b61b86a$export$2e2bcd8739ae039,
    TextFormatter: $06a0261003eb9ba9$export$2e2bcd8739ae039,
    UltimateGuitarParser: $7c59209366f6488e$export$2e2bcd8739ae039,
    CHORUS: $234747a9630b4642$export$8db6c706fc9142b2,
    INDETERMINATE: $234747a9630b4642$export$c5a6fe907430212e,
    NONE: $234747a9630b4642$export$c53d0f541b41b88e,
    TAB: $234747a9630b4642$export$f1c9dd0f5207dd5e,
    VERSE: $234747a9630b4642$export$4b194284baed1659
};


export {$149c1bd638913645$export$2e2bcd8739ae039 as default, $5e3a0c5a6197f95b$export$2e2bcd8739ae039 as Chord, $5e3a0c5a6197f95b$export$621b8187b24d90c6 as parseChord, $f7a904d05353aafa$export$2e2bcd8739ae039 as ChordLyricsPair, $feb758e68dd351a4$export$2e2bcd8739ae039 as ChordProFormatter, $8e2b91641771a21c$export$2e2bcd8739ae039 as ChordProParser, $9c17b505581d81bb$export$2e2bcd8739ae039 as ChordSheetParser, $2a399cf90c614489$export$2e2bcd8739ae039 as ChordSheetSerializer, $b72f5288e28a9b64$export$2e2bcd8739ae039 as ChordsOverWordsParser, $df4ad73a744c94b3$export$2e2bcd8739ae039 as Comment, $ba84a02c63f26e83$export$2e2bcd8739ae039 as Composite, $2dfa852662754780$export$2e2bcd8739ae039 as Formatter, $9ba0fb9ec815efc8$export$2e2bcd8739ae039 as HtmlFormatter, $de6608cf7e39dfee$export$2e2bcd8739ae039 as HtmlDivFormatter, $fdcc84db82790d90$export$2e2bcd8739ae039 as HtmlTableFormatter, $918eb2016ac61e41$export$2e2bcd8739ae039 as Key, $06eb272065540fc1$export$2e2bcd8739ae039 as Line, $758385c5b662d76d$export$2e2bcd8739ae039 as Literal, $fdb42fd3b59812d4$export$2e2bcd8739ae039 as Metadata, $55861b6d10167265$export$2e2bcd8739ae039 as Paragraph, $7860c26c4d50915f$export$2e2bcd8739ae039 as Song, $b3836272a1374d85$export$2e2bcd8739ae039 as Tag, $d6f43bad3b61b86a$export$2e2bcd8739ae039 as Ternary, $06a0261003eb9ba9$export$2e2bcd8739ae039 as TextFormatter, $7c59209366f6488e$export$2e2bcd8739ae039 as UltimateGuitarParser, $234747a9630b4642$export$8db6c706fc9142b2 as CHORUS, $234747a9630b4642$export$c5a6fe907430212e as INDETERMINATE, $234747a9630b4642$export$c53d0f541b41b88e as NONE, $234747a9630b4642$export$4d318981b5a83836 as NUMERIC, $234747a9630b4642$export$27c95a7104c1f7aa as SYMBOL, $234747a9630b4642$export$f1c9dd0f5207dd5e as TAB, $234747a9630b4642$export$4b194284baed1659 as VERSE};
//# sourceMappingURL=module.js.map
